(window.webpackJsonp=window.webpackJsonp||[]).push([[2],Array(234).concat([function(n,e){n.exports={code1:'\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nfunction twoSum (nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[j] === target - nums[i]) \n        return [i, j];\n    }\n  }\n  return "数组中找不到两个数使得等于目标数字";\n};\n'}},function(n,e){n.exports={code101:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nimport { BinaryTreeHelper } from "@karl_fang/data-structure";\nlet bst = new BinaryTreeHelper([1, 2, 2, 3, 4, 4, 3]);\nlet root = bst.getRoot();\n\nfunction recursion(leftNode, rightNode) {\n  if (leftNode === null || rightNode === null) {\n    return leftNode === rightNode\n  }\n  else {\n    if (leftNode.val !== rightNode.val) return false;\n    return recursion(leftNode.left, rightNode.right)\n      && recursion(leftNode.right, rightNode.left);\n  }\n}\n\nfunction isSymmetric(root) {\n  if (root === null) return true;\n  return recursion(root.left, root.right);\n};\nconsole.log(isSymmetric(root));\n'}},function(n,e){n.exports={code102:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nimport BinaryTree from "../utils/binaryTree.js";\nlet arr = [3, 9, 20, null, null, 15, 7];\nlet root = new BinaryTree(arr).root;\nfunction levelOrder(root) {\n  let result = [];\n  recursion(root, 0);\n  return result;\n  function recursion(root, depth) {\n    if (root === null) return;\n    if (result[depth] === undefined) {\n      result[depth] = [];\n    }\n    result[depth].push(root.val);\n    recursion(root.left, depth + 1);\n    recursion(root.right, depth + 1);\n  }\n};\nconsole.log(levelOrder(root));\n'}},function(n,e){n.exports={code104:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nimport BinaryTree from "../utils/binaryTree.js";\nlet arr = [3, 9, 20, null, null, 15, 7];\nlet root = new BinaryTree(arr).root;\nfunction maxDepth(root) {\n  if (root === null) return 0;\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\nconsole.log(maxDepth(root));\n'}},function(n,e){n.exports={code105:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\n\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val);\n  this.left = (left === undefined ? null : left);\n  this.right = (right === undefined ? null : right);\n}\n\n// 题目中解释道: preorder 和 inorder 均无重复元素\nfunction buildTree(preorder, inorder) {\n  if (preorder.length === 0) return null;\n  if (preorder.length === 1) return new TreeNode(preorder[0]);\n  let rootIdx = inorder.indexOf(preorder[0]);\n  return new TreeNode(\n    preorder[0],\n    buildTree(preorder.slice(1, rootIdx + 1), inorder.slice(0, rootIdx)),\n    buildTree(preorder.slice(rootIdx + 1), inorder.slice(rootIdx + 1))\n  );\n};\n\nlet root = buildTree([3, 9, 4, 20, 15, 7], [9, 4, 3, 15, 20, 7]);\nBinaryTreeHelper.LogMyTree(root);\n"}},function(n,e){n.exports={code11:"\n/**\n * @param {number[]} height\n * @return {number}\n */\n// 双指针\nfunction maxArea(height) {\n  let [left, right] = [0, height.length - 1];\n  let result = 0;\n  while (left < right) {\n    let tempArea = Math.min(height[left], height[right]) * (right - left);\n    result = result < tempArea ? tempArea : result;\n    if (height[left] <= height[right]) left++;\n    else right--;\n  }\n  return result;\n};\nconsole.log(maxArea([1,8,6,2,5,4,8,3,7]));\n"}},function(n,e){n.exports={code114:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {void} Do not return anything, modify root in-place instead.\n */\nimport BinaryTree from "../utils/binaryTree.js";\nlet arr = [];\nlet myRoot = new BinaryTree(arr).root;\nfunction toString(root) {\n  let str = "";\n  while (root) {\n    str += root.val + " --\x3e ";\n    root = root.right;\n  }\n  return str + "null";\n}\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val)\n  this.left = (left === undefined ? null : left)\n  this.right = (right === undefined ? null : right)\n}\nfunction flatten(root) {\n  if (root === null || root.val === null) return root;\n  let treeRoot = new TreeNode(), tmp = treeRoot; \n  preOrder(root);\n  function preOrder(root) {\n    if (root === null) return;\n    tmp.right = new TreeNode(root.val, null,null);\n    tmp = tmp.right;\n    preOrder(root.left);\n    preOrder(root.right);\n  }\n  root.right = treeRoot.right.right;\n  root.left = null;\n};\nflatten(myRoot);\nconsole.log(myRoot);\nconsole.log(toString(myRoot));\n'}},function(n,e){n.exports={code121:"\n/**\n * @param {number[]} prices\n * @return {number}\n */\nfunction maxProfit(prices) {\n  let dp = [], min = 1e4 + 1;\n  prices.forEach((price, index) => {\n    min = Math.min(min, price);\n    dp[index] = Math.max(dp[index - 1] === undefined ? 0 : dp[index - 1], price - min);\n  });\n  return dp[prices.length - 1];\n};\n\nfunction maxProfit(prices) {\n  let result = 0, minPrice = Number.MAX_SAFE_INTEGER;\n  prices.forEach((item, index) => {\n      minPrice = Math.min(minPrice, item);\n      result = Math.max(item - minPrice, result);\n  })\n  return result\n};\nconsole.log(maxProfit([7, 1, 5, 3, 6, 4]));\n"}},function(n,e){n.exports={code128:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction longestConsecutive(nums) {\n  let map = new Map(), result = 0;\n  for (let i = 0; i < nums.length; i++){\n    map.set(nums[i], true);\n  }\n  for (let i = 0; i < nums.length; i++){\n    if (!map.has(nums[i] - 1)) {\n      let targetNum = nums[i], cnt = 1;\n      while (map.has(targetNum + 1)) {\n        targetNum++;\n        cnt++;\n      }\n      result = cnt > result ? cnt : result;\n    }\n  }\n  return result;\n};\nconsole.log(longestConsecutive([100, 4,4, 200, 1, 3, 2,3,3]));\n"}},function(n,e){n.exports={code136:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction singleNumber(nums) {\n  let result = 0;\n  nums.forEach(item => result = result ^ item);\n  return result;\n};\nconsole.log(singleNumber([4, 1, 2, 1, 2]));\n"}},function(n,e){n.exports={code139:'\n/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {boolean}\n */\n// 回溯 + 剪枝 + 哈希表\nfunction wordBreak(s, wordDict) {\n  let result = false, path = "",map = new Map();\n  backTracking(s[0])\n  return result;\n  function backTracking(nextChar) {\n    if (path === s) {\n      result = true;\n      return ;\n    }\n    if (result || map.get(path) || path.length >= s.length) return;\n    // 保存之前出现的所有可能，防止重复遍历\n    if (path !== s.slice(0, path.length)) {\n      map.set(path, false);\n      return;\n    }\n    else {\n      map.set(path, true);\n    }\n    for (let i = 0; i < wordDict.length; i++) {\n      if (wordDict[i][0] === nextChar) {\n        let orginLength = path.length;\n        path += wordDict[i];\n        backTracking(s[path.length]);\n        path = path.slice(0, orginLength);\n      }\n    }\n  }\n};\nconsole.log(wordBreak("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",\n["a","aa","aaa","aaaa","aaaaa","aaaaaa","aaaaaaa","aaaaaaaa","aaaaaaaaa","aaaaaaaaaa"]));\n'}},function(n,e){n.exports={code141:'\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nimport LinkedList from "../utils/linkedList.js";\nlet arr = [1,2,3,4];\nlet llist = new LinkedList(arr,2);\nlet head = llist.head;\nllist.toString();\n\n方法1:\nfunction hasCycle(head) {\n  let [fast, slow] = [head, head];\n  do {\n    fast = fast?.next?.next;\n    slow = slow?.next\n  } while (fast !== slow);\n  if (fast === undefined || slow === undefined) return false;\n  fast = head;\n  while (fast !== slow) {\n    fast = fast?.next;\n    slow = slow?.next;\n  }\n  return fast === undefined ? false : true;\n};\n\n方法2:\nfunction hasCycle(head) {\n  let map = new Map(), currentNode = head;\n  while (currentNode) {\n    let temp = map.get(currentNode);\n    if (!temp) map.set(currentNode, true);\n    else return true;\n    currentNode = currentNode.next;\n  }\n  return false;\n};\nconsole.log(hasCycle(head));\n'}},function(n,e){n.exports={code142:'\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\n import LinkedList from "../utils/linkedList.js";\n let arr = [1];\n let llist = new LinkedList(arr);\n let head = llist.head;\n llist.toString();\n function detectCycle(head) {\n   let [fast, slow] = [head, head];\n   do {\n     fast = fast?.next?.next;\n     slow = slow?.next\n   } while (fast !== slow);\n   if (fast === undefined || slow === undefined) return null;\n   fast = head;\n   while (fast !== slow) {\n     fast = fast?.next;\n     slow = slow?.next;\n   }\n   return fast === undefined ? null : fast;\n };\n console.log(detectCycle(head));\n'}},function(n,e){n.exports={code146:'\nfunction Node(key, val, pre, next) {\n  this.key = key ?? null;\n  this.val = val ?? null;\n  this.pre = pre ?? null;\n  this.next = next ?? null;\n}\n\nfunction DoubleLinkedList() {\n  this.head = new Node("head", "head");\n  this.tail = new Node("tail", "tail");\n  this.init();\n}\n\nDoubleLinkedList.prototype.init = function () {\n  this.head.next = this.tail;\n  this.tail.pre = this.head;\n}\n\nDoubleLinkedList.prototype.deleteLastElement = function () {\n  const last = this.tail.pre;\n  this.tail.pre = last.pre;\n  last.pre.next = last.next;\n  return last.key;\n}\n\nDoubleLinkedList.prototype.addFirstElement = function (node) {\n  const oldFirst = this.head.next;\n  node.pre = this.head;\n  node.next = oldFirst;\n  this.head.next = node;\n  oldFirst.pre = node;\n}\n\nDoubleLinkedList.prototype.getHead = function () {\n  return this.head;\n}\n\nDoubleLinkedList.moveToFirst = function (node, head) {\n  const preNode = node.pre, nextNode = node.next, afterHead = head.next;\n  if (afterHead === node) return;\n  preNode.next = nextNode;\n  nextNode.pre = preNode;\n  afterHead.pre = node;\n  head.next = node;\n  node.pre = head;\n  node.next = afterHead;\n}\n\nDoubleLinkedList.prototype.log = function (direction = "b2e") {\n  if (direction === "b2e") {\n    let currentNode = this.head.next, str = "head";\n    while (currentNode) {\n      str += " --\x3e " + currentNode.val;\n      currentNode = currentNode.next;\n    }\n    console.log("from begin to end:", str);\n  } else if (direction === "e2b") {\n    let currentNode = this.tail.pre, str = "tail";\n    while (currentNode) {\n      str += " --\x3e " + currentNode.val;\n      currentNode = currentNode.pre;\n    }\n    console.log("from end to begin:", str);\n  }\n}\n\n// const dll = new DoubleLinkedList();\n// dll.addFirstElement(new Node(1, 1));\n// DoubleLinkedList.moveToFirst(dll.tail.pre, dll.getHead());\n// dll.log();\n// dll.log("e2b");\n// dll.addFirstElement(new Node(2, 2));\n// DoubleLinkedList.moveToFirst(dll.tail.pre, dll.getHead());\n// dll.log();\n// dll.log("e2b");\n// dll.addFirstElement(new Node(3, 3));\n// DoubleLinkedList.moveToFirst(dll.tail.pre, dll.getHead());\n// dll.log();\n// dll.log("e2b");\n// dll.addFirstElement(new Node(4, 4));\n// DoubleLinkedList.moveToFirst(dll.tail.pre, dll.getHead());\n// dll.log();\n// dll.log("e2b");\n// dll.log();\n// dll.log("e2b");\n// dll.deleteLastElement();\n// dll.log();\n// dll.log("e2b");\n// DoubleLinkedList.moveToFirst(dll.tail.pre, dll.getHead());\n// dll.log();\n// dll.log("e2b");\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function (capacity) {\n  this.capacity = capacity;\n  this.size = 0;\n  this.map = new Map();\n  this.dll = new DoubleLinkedList();\n  this.head = this.dll.getHead();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function (key) {\n  let res = this.map.get(key);\n  if (!res) return -1;\n  DoubleLinkedList.moveToFirst(res, this.head);\n  return res.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function (key, value) {\n  let res = this.map.get(key);\n  if (!res) {\n    let node = new Node(key, value);\n    this.dll.addFirstElement(node);\n    this.map.set(key, node);\n    this.size++;\n    if (this.size > this.capacity) {\n      const key = this.dll.deleteLastElement();\n      this.map.delete(key);\n      this.size--;\n    }\n  }\n  else {\n    res.val = value;\n    DoubleLinkedList.moveToFirst(res, this.head);\n  }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n\n// const lRUCache = new LRUCache(2);\n// lRUCache.put(1, 0); // 缓存是 {1=1}\n// lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\n// console.log(lRUCache.get(1));    // 返回 1\n// lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\n// console.log(lRUCache.get(2));    // 返回 -1 (未找到)\n// lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\n// console.log(lRUCache.get(1));    // 返回 -1 (未找到)\n// console.log(lRUCache.get(3));    // 返回 3\n// console.log(lRUCache.get(4));    // 返回 4\n\n// const lRUCache = new LRUCache(1);\n// lRUCache.put(2, 1);\n// console.log(lRUCache.get(2));\n// lRUCache.put(3, 2);\n// console.log(lRUCache.get(2));\n// console.log(lRUCache.get(3));\n\nconst lRUCache = new LRUCache(2);\nlRUCache.put(2, 1);\nlRUCache.put(1, 1);\nlRUCache.put(2, 3);\nlRUCache.put(4, 1);\nconsole.log(lRUCache.get(1));\nconsole.log(lRUCache.get(2));\n'}},function(n,e){n.exports={code148:'\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n import { LinkedListHelper } from \'@karl_fang/data-structure\';\nlet list1 = new LinkedListHelper([4, 2, 1, 3]); // 普通链表\n\nfunction ListNode(val, next) {\n  this.val = (val === undefined ? 0 : val)\n  this.next = (next === undefined ? null : next)\n}\n\nfunction insertNode(node1, node2) {\n  let temp = node2.next;\n  if (temp) {\n    node2.next = node2.next.next;\n    temp.next = node1.next;\n    node1.next = temp;\n  }\n}\n\nfunction sortList(head) {\n  const tempHead = new ListNode("head", head);\n  let beforeCurr = tempHead;\n  let curr = head;\n  while (curr) {\n    let beforeTempCurr = tempHead;\n    let tempCurr = tempHead.next;\n    // console.log("before: ", LinkedList.linkedListToString(tempHead), "curr:", curr.val, "tempCurr:", beforeTempCurr.val);\n    while (tempCurr !== curr) {\n      if (curr.val > tempCurr.val) {\n        tempCurr = tempCurr.next;\n        beforeTempCurr = beforeTempCurr.next;\n      }\n      else {\n        curr = curr.next;\n        insertNode(beforeTempCurr, beforeCurr);\n        break;\n      }\n    }\n    if (tempCurr === curr) {\n      curr = curr.next;\n      beforeCurr = beforeCurr.next;\n    }\n    // console.log(LinkedList.linkedListToString(tempHead));\n  }\n  return tempHead.next;\n};\n\nlet afterSort = sortList(list1.getNthNode(1));\nconsole.log(LinkedListHelper.LinkedListToString(afterSort));\n'}},function(n,e){n.exports={code15:"\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\n// 排序 + 双指针\nfunction threeSum(nums) {\n  let afterSort = nums.sort((a, b) => a - b);\n  let result = [];\n  for (let i = 0, len = afterSort.length; i < len; i++){\n    let [left, right] = [i + 1, len - 1];\n    // afterSort[i]固定\n    if (afterSort[i] <= 0 && afterSort[i] !== afterSort[i - 1]) {\n      while (left < right) {\n        if (afterSort[i] + afterSort[left] + afterSort[right] > 0) right--;\n        else if (afterSort[i] + afterSort[left] + afterSort[right] < 0) left++;\n        else if (afterSort[i] + afterSort[left] + afterSort[right] === 0) {\n          result.push([afterSort[i], afterSort[left], afterSort[right]]);\n          while (afterSort[left] === afterSort[++left]);\n          while (afterSort[right] === afterSort[--right]);\n        }\n      }\n    }\n  }\n  return result;\n};\n// [-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]\nconsole.log(threeSum([-4,-2,-2,-2,0,1,2,2,2,3,3,4,4,6,6]));\n"}},function(n,e){n.exports={code152:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction maxProduct(nums) {\n  let len = nums.length;\n  if (len === 1) return nums[0];\n  let multiple = 1, negativeNumber = 1, max = nums[0], flag = false; // num保存第一个负数\n  for (let i = 0; i < len; i++) {\n    multiple *= nums[i];\n    if (multiple < 0) {\n      let tmp = Math.max(multiple / negativeNumber, nums[i]);\n      if (!flag) {\n        negativeNumber = multiple;\n        flag = true;\n      }\n      max = tmp > max ? tmp : max;\n    }\n    else if (multiple === 0) {\n      let tmp = (0, nums[i]);\n      max = tmp > max ? tmp : max;\n      multiple = 1;\n      negativeNumber = 1;\n      flag = false;\n    }\n    else {\n      max = multiple > max ? multiple : max;\n    }\n  }\n  return max;\n};\nconsole.log(maxProduct([6, 3, -10, 0, 2]));\n"}},function(n,e){n.exports={code155:"\nvar MinStack = function() {\n  this.storage = [];\n  this.minStack = []; // 保存最小值\n  this.length = 0;\n};\n\n/** \n * @param {number} val\n * @return {void}\n */\nMinStack.prototype.push = function(val) {\n  this.storage.push(val);\n  if (this.length === 0) this.minStack.push(val);\n  else {\n    if (val < this.minStack[this.length - 1]) this.minStack.push(val);\n    else this.minStack.push(this.minStack[this.length - 1]);\n  }\n  this.length++;\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function() {\n  this.storage.pop();\n  this.minStack.pop();\n  this.length = this.length - 1 < 0 ? 0 : this.length - 1;\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function() {\n  return this.storage[this.length - 1];\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.getMin = function() {\n  return this.minStack[this.length - 1];\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * var obj = new MinStack()\n * obj.push(val)\n * obj.pop()\n * var param_3 = obj.top()\n * var param_4 = obj.getMin()\n */\nlet stack = new MinStack();\nstack.push(4);\nstack.push(2);\nstack.push(3);\nstack.push(1);\nstack.push(3);\nstack.push(4);\n"}},function(n,e){n.exports={code160:"\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\n// 两个链表都为非空\nfunction getIntersectionNode(headA, headB) {\n  let [point1, point2] = [headA, headB];\n  while (point1 !== point2) {\n    point1 = point1 === null ? headB : point1.next;\n    point2 = point2 === null ? headA : point2.next;\n  }\n  return point1;\n};\n"}},function(n,e){n.exports={code169:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction majorityElement(nums) {\n  let map = new Map(), targetNum = Math.floor(nums.length / 2) + 1, result;\n  nums.forEach(item => {\n    let res = map.get(item);\n    if (res) map.set(item, res + 1);\n    else map.set(item, 1);\n  });\n  let entries = Array.from(map.entries());\n  for (let item of entries) {\n    if (item[1] >= targetNum) {\n      result = item[0];\n      break;\n    }\n  }\n  return result\n};\nconsole.log(majorityElement([2, 2, 1, 1, 1, 2, 2]));\n"}},function(n,e){n.exports={code17:'\n/**\n * @param {string} digits\n * @return {string[]}\n */\nconst map = new Map([\n  ["2", ["a","b","c"]],\n  ["3", ["d","e","f"]],\n  ["4", ["g","h","i"]],\n  ["5", ["j","k","l"]],\n  ["6", ["m","n","o"]],\n  ["7", ["p","q","r","s"]],\n  ["8", ["t","u","v"]],\n  ["9", ["w","x","y","z"]]\n])\nfunction letterCombinations(digits) {\n  if (digits.length === 0) return [];\n  let queue = [""];\n  for (let i = 0; i < digits.length; i++){\n    let letters = map.get(digits[i]);\n    for (let j = 0, len = queue.length; j < len; j++) {\n      let firstElement = queue.shift();\n      let str = firstElement === undefined ? "" : firstElement;\n      letters.forEach(item => queue.push(str + item));\n    }\n  }\n  return queue;\n};\nconsole.log(letterCombinations("23"));\n'}},function(n,e){n.exports={code19:"\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\n// 将链表展示\nfunction toString(head) {\n  let currentNode = head, array = [];\n  while (currentNode) {\n    array.push(currentNode.val);\n    currentNode = currentNode.next;\n  }\n  return array.join(\" --\x3e \");\n}\n// 将数组转化成链表\nfunction arrayToLinkedList(array) {\n  let list = new ListNode('head'), temp = list; // temp是用来防止最后得到的list是指向链表末尾\n  for (let i = 0; i < array.length; i++) {\n    temp.next = new ListNode(array[i]);\n    temp = temp.next;\n  }\n  return list.next;\n}\n/********************************************************/\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}\nfunction removeNthFromEnd(head, n) {\n  let [slow, fast] = [head, head];\n  for (let i = 0; i < n; i++) fast = fast.next === undefined ? null : fast.next;\n  if (fast) {\n    while (fast && fast.next) {\n      slow = slow.next;\n      fast = fast.next;\n    }\n  }\n  else {\n    return head.next;\n  }\n  slow.next = slow.next.next;\n  return head;\n};\nlet list = arrayToLinkedList([1]);\nconsole.log(toString(list));\nlet afterRemove = removeNthFromEnd(list, 1);\nconsole.log(toString(afterRemove));\n// 1 2 3 4 5\n"}},function(n,e){n.exports={code198:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction rob(nums) {\n  let dp = [];\n  nums.forEach((item, index) => {\n    if (index === 0) dp[0] = item;\n    else if (index === 1) dp[1] = dp[0] > item ? dp[0] : item;\n    else dp[index] = Math.max(dp[index - 2] + item, dp[index - 1]);\n  })\n  return dp[dp.length - 1];\n};\n\nfunction rob(nums) {\n  let dp = [], len = nums.length;\n  if (len === 1) return nums[0];\n  dp.push(nums[0], Math.max(nums[0], nums[1]));\n  if (len === 2) return dp[len - 1];\n  for (let i = 2; i < len; i++) {\n    dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);\n  }\n  return dp[len - 1];\n};\n\nconsole.log(rob([1, 2, 4, 2, 2, 7, 3]));\n"}},function(n,e){n.exports={code2:"\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n// 将链表展示\nfunction toString(head) {\n  let currentNode = head, array = [];\n  while (currentNode) {\n    array.push(currentNode.val);\n    currentNode = currentNode.next;\n  }\n  return array.join(\" --\x3e \");\n}\n// 将数组转化成链表\nfunction arrayToLinkedList(array) {\n  let list = new ListNode('head'), temp = list; // temp是用来防止最后得到的list是指向链表末尾\n  for (let i = 0; i < array.length; i++) {\n    temp.next = new ListNode(array[i]);\n    temp = temp.next;\n  }\n  return list.next;\n}\n/**************************以下为提交的代码**************************/\n// 官方提供的节点\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}\n// 两数之和\nfunction addTwoNumbers (currentNode1, currentNode2) {\n  let l3 = new ListNode('head'), temp = l3, carry = 0; // carry为进位\n  while (currentNode1 || currentNode2) {\n    let sum = carry;\n    if (currentNode1?.val !== undefined) sum += currentNode1.val;\n    if (currentNode2?.val !== undefined) sum += currentNode2.val;\n    temp.next = new ListNode(sum % 10);\n    temp = temp.next;\n    carry = Math.floor(sum / 10);\n    currentNode1 !== null && (currentNode1 = currentNode1.next);\n    currentNode2 !== null && (currentNode2 = currentNode2.next);\n  }\n  if (carry !== 0) temp.next = new ListNode(carry);\n  return l3.next;\n};\n// let l1 = arrayToLinkedList([9,9,9,9,9,9,9]);\n// let l2 = arrayToLinkedList([9,9,9,9]);\n// let result = addTwoNumbers(l1, l2);\n// console.log(toString(result));\n"}},function(n,e){n.exports={code20:'\n/**\n * @param {string} s\n * @return {boolean}\n */\nclass Stack {\n  constructor() {\n    this.storage = [];\n    this.size = 0;\n  }\n  push(value) {\n    this.storage.push(value);\n    this.size++;\n  }\n  pop() {\n    this.storage.pop();\n    this.size--;\n  }\n}\nfunction isValid(s) {\n  let stack = new Stack();\n  for (let i = 0, len = s.length; i < len; i++){\n    let storage = stack.storage;\n    let length = storage.length;\n    if (s[i] === "(" || s[i] === "[" || s[i] === "{") {\n      stack.push(s[i]);\n    }\n    else {\n      if (storage[length - 1] === "(" && s[i] === ")" || storage[length - 1] === "[" && s[i] === "]" || storage[length - 1] === "{" && s[i] === "}") {\n        stack.pop();\n      }\n      else {\n        stack.push(s[i]);\n      }\n    }\n  }\n  return stack.size === 0\n};\nconsole.log(isValid("]()"));\n'}},function(n,e){n.exports={code200:'\n/**\n * @param {character[][]} grid\n * @return {number}\n */\n\n方法1:\nfunction generateArray(row, column, fillElement) {\n  let arr = [];\n  for (let i = 0; i < row; i++) {\n    arr.push(new Array(column).fill(fillElement));\n  }\n  return arr;\n}\n\nfunction numIslands(grid) {\n  let row = grid.length, column = grid[0].length, islandNum = 0;\n  let visitedMap = generateArray(row + 2, column + 2, 0);\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      backTracking(i, j);\n    }\n  }\n  return islandNum;\n  function backTracking(i, j) {\n    if (grid[i] === undefined || grid[i][j] === undefined || grid[i][j] === "0") return;\n    if (visitedMap[i + 1][j + 1]) return;\n    if (visitedMap[i][j + 1] === 0 && visitedMap[i + 2][j + 1] === 0\n      && visitedMap[i + 1][j] === 0 && visitedMap[i + 1][j + 2] === 0) {\n      visitedMap[i + 1][j + 1] = ++islandNum;\n    }\n    else {\n      visitedMap[i + 1][j + 1] = visitedMap[i][j + 1] || visitedMap[i + 2][j + 1]\n        || visitedMap[i + 1][j] || visitedMap[i + 1][j + 2];\n    }\n    // console.log(i, j);\n    // console.log(visitedMap);\n    backTracking(i - 1, j) || backTracking(i, j - 1)\n      || backTracking(i + 1, j) || backTracking(i, j + 1);\n  }\n};\n\n方法2: \nvar genMap = function (row, column) {\n  let map = [];\n  for (let i = 0; i < row; i++) {\n    map.push(new Array(column).fill(false));\n  }\n  return map;\n}\n\nvar ifExit = function (array, i, j) {\n  return (array[i] ?? false) && (array[i][j] ?? false) && true;\n}\n\nvar numIslands = function (grid) {\n  const row = grid.length, column = grid[0].length;\n  const map = genMap(row, column);\n  let cnt = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      if (map[i][j]) continue;\n      search(i, j);\n      grid[i][j] === "1" && cnt++;\n    }\n  }\n  return cnt;\n  function search(i, j) {\n    if (!ifExit(grid, i, j) || map[i][j] || grid[i][j] === "0") return false;\n    map[i][j] = true;\n    return search(i - 1, j) || search(i + 1, j) || search(i, j - 1) || search(i, j + 1);\n  }\n};\n\nconsole.log(numIslands([\n  ["1", "1", "0", "0", "0"],\n  ["1", "1", "0", "0", "0"],\n  ["0", "0", "1", "0", "0"],\n  ["0", "0", "0", "1", "1"]\n]));\n'}},function(n,e){n.exports={code206:"\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nimport LinkedList from '../utils/linkedList.js';\nlet list = new LinkedList([1, 2, 3, 4, 5]);\nlet head = list.head;\nlist.toString();\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}\nfunction reverseList(head) {\n  let root = new ListNode('head'), currentNode = head, nextNode;\n  while (currentNode) {\n    nextNode = currentNode.next;\n    currentNode.next = root.next;\n    root.next = currentNode;\n    currentNode = nextNode;\n  }\n  return root.next;\n};\nlet afterReverse = reverseList(head);\nLinkedList.LinkedListToString(afterReverse);\n"}},function(n,e){n.exports={code208:'\nclass Trie {\n  constructor() {\n    this.node = {};\n  }\n  /** \n   * @param {string} word\n   * @return {void}\n   */\n  insert(word) {\n    let curr = this.node;\n    for (let char of word) {\n      if (!curr[char]) {\n        curr[char] = {};\n      }\n      curr = curr[char];\n    }\n    curr.ifEnd = true;\n  };\n\n  // 辅助函数\n  ifExist(prefix) {\n    let curr = this.node;\n    for (let char of prefix) {\n      if (!curr[char]) return null;\n      curr = curr[char];\n    }\n    return curr;\n  };\n\n  /** \n   * @param {string} word\n   * @return {boolean}\n   */\n  search(word) {\n    let temp = this.ifExist(word);\n    return !!temp && !!temp.ifEnd;\n  }\n\n  /** \n   * @param {string} prefix\n   * @return {boolean}\n   */\n  startsWith(prefix) {\n    return !!this.ifExist(prefix);\n  };\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * var obj = new Trie()\n * obj.insert(word)\n * var param_2 = obj.search(word)\n * var param_3 = obj.startsWith(prefix)\n */\n\nconst trie = new Trie();\n// trie.insert("apple");\nconsole.log(trie.search("apple"));\n// console.log(trie.search("app"));\n// console.log(trie.startsWith("app"));\n// trie.insert("app");\n// console.log(trie.search("app"));\n'}},function(n,e){n.exports={code21:"\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\n// 将链表展示\nfunction toString(head) {\n  let currentNode = head, array = [];\n  while (currentNode) {\n    array.push(currentNode.val);\n    currentNode = currentNode.next;\n  }\n  return array.join(\" --\x3e \");\n}\n// 将数组转化成链表\nfunction arrayToLinkedList(array) {\n  let list = new ListNode('head'), temp = list; // temp是用来防止最后得到的list是指向链表末尾\n  for (let i = 0; i < array.length; i++) {\n    temp.next = new ListNode(array[i]);\n    temp = temp.next;\n  }\n  return list.next;\n}\n/*************************************************************/\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}\nfunction mergeTwoLists(list1, list2) {\n  let list = new ListNode('head'), temp = list;\n  while (list1 && list2) {\n    if (list1.val < list2.val) {\n      temp.next = list1;\n      list1 = list1.next;\n    }\n    else if (list1.val >= list2.val) {\n      temp.next = list2;\n      list2 = list2.next;\n    }\n    temp = temp.next;\n  }\n  if (list1) {\n    while (list1) {\n      temp.next = list1;\n      list1 = list1.next;\n      temp = temp.next;\n    }\n  }\n  else {\n    while (list2) {\n      temp.next = list2;\n      list2 = list2.next;\n      temp = temp.next;\n    }\n  }\n  return list.next;\n};\nlet list1 = arrayToLinkedList([0, 3]);\nlet list2 = arrayToLinkedList([-1, -2]);\nlet list = mergeTwoLists(list1, list2);\nconsole.log(toString(list));\n"}},function(n,e){n.exports={code215:"\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n*/\n// 将数组用快速排序排序\nfunction findKthLargest(nums, k) {\n  quickSort(0, nums.length - 1);\n  return nums[k - 1];\n  function quickSort(left, right) {\n    if (left >= right) return;\n    let copyLeft = left, copyRight = right;\n    while (left < right) {\n      while (left < right && nums[right] <= nums[copyLeft]) right--;\n      while (left < right && nums[left] >= nums[copyLeft]) left++;\n      [nums[left], nums[right]] = [nums[right], nums[left]];\n    }\n    [nums[copyLeft], nums[left]] = [nums[left], nums[copyLeft]];\n    quickSort(copyLeft, left - 1);\n    quickSort(left + 1, copyRight);\n  }\n};\n// 基于快速排序的选择排序\nfunction findKthLargest(nums, k) {\n  let result;\n  quickSort(0, nums.length - 1);\n  return result;\n  function quickSort(left, right) {\n    if (left > right) return;\n    let [copyLeft, copyRight] = [left, right];\n    while (left < right) {\n      while (left < right && nums[right] <= nums[copyLeft]) right--;\n      while (left < right && nums[left] >= nums[copyLeft]) left++;\n      [nums[left], nums[right]] = [nums[right], nums[left]];\n    }\n    [nums[copyLeft], nums[left]] = [nums[left], nums[copyLeft]];\n    if (left === k - 1) result = nums[left];\n    else if (left > k - 1) quickSort(copyLeft, left - 1);\n    else if (left < k - 1) quickSort(left + 1, copyRight);\n  }\n}\nconsole.log(findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4));\n"}},function(n,e){n.exports={code22:'\n/**\n * @param {number} n\n * @return {string[]}\n */\nfunction generateParenthesis(n) {\n  let path = "", result = [], parenthesis = ["(", ")"];\n  backTracking(0, 0);\n  return result;\n  function backTracking(leftParenthesisNum, rightParenthesisNum){\n    if (path.length === n * 2) {\n      if(path[0] === "(" && leftParenthesisNum === n) result.push(path);\n      return;\n    }\n    if (leftParenthesisNum > n) return;\n    for (let i = 0; i <= (leftParenthesisNum > rightParenthesisNum ? 1 : 0 ); i++){\n      path += parenthesis[i];\n      if (i === 0) leftParenthesisNum++;\n      else rightParenthesisNum++;\n      backTracking(leftParenthesisNum, rightParenthesisNum);\n      if (path.slice(-1) === "(") leftParenthesisNum--;\n      else rightParenthesisNum--;\n      path = path.slice(0, -1);\n    }\n  }\n};\n\nfunction generateParenthesis(n) {\n  const result = [], component = [\'(\', \')\'];\n  let left = 0, right = 0, path = \'\';\n  backTracking();\n  return result;\n\n  function backTracking() {\n    if (path.length === 2 * n) {\n      if (left === n && right === n) {\n        result.push(path);\n      }\n      return;\n    }\n\n    for (let i = 0; i < 2; i++) {\n      if (left < right) continue;\n      path += component[i];\n      i === 0 ? left++ : right++;\n      backTracking();\n      path = path.slice(0, -1);\n      i === 0 ? left-- : right--;\n    }\n  }\n};\n\nconsole.log(generateParenthesis(4));\n'}},function(n,e){n.exports={code221:'\n/**\n * @param {character[][]} matrix\n * @return {number}\n */\n\nfunction ifExist(array, i, j) {\n  return !array[i] ? 0 : (array[i][j] ?? 0);\n}\n\nfunction createArray(row, column) {\n  let array = [];\n  for (let i = 0; i < row; i++) {\n    array.push(new Array(column));\n  }\n  return array;\n}\n\nfunction maximalSquare(matrix) {\n  const row = matrix.length, column = matrix[0].length;\n  let dp = createArray(row, column), result = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      if (matrix[i][j] === "1") {\n        let temp = Math.min(ifExist(dp, i - 1, j), ifExist(dp, i, j - 1), ifExist(dp, i - 1, j - 1)),\n          min = (Math.sqrt(temp) + 1) ** 2;\n        console.log(temp, min);\n        dp[i][j] = min;\n        result = min > result ? min : result;\n        continue;\n      }\n      dp[i][j] = 0;\n    }\n  }\n  return result;\n};\n\nconsole.log(maximalSquare([["1","1","1","1","0"],["1","1","1","1","0"],["1","1","1","1","1"],["1","1","1","1","1"],["0","0","1","1","1"]]));\n'}},function(n,e){n.exports={code226:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nfunction invertTree(root) {\n  if (root === null) return null;\n  invertTree(root.left);\n  invertTree(root.right);\n  [root.left, root.right] = [root.right, root.left];\n  return root;\n};\n"}},function(n,e){n.exports={code234:'\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nimport LinkedList from "../utils/linkedList.js";\nlet arr = [1, 2,3, 2,1];\nlet head = new LinkedList(arr).head;\nfunction isPalindrome(head) {\n  let arr = [], currentNode = head;\n  while (currentNode) {\n    arr.push(currentNode.val);\n    currentNode = currentNode.next;\n  }\n  let [left, right] = [0, arr.length - 1];\n  while (left < right) {\n    if (arr[left] === arr[right]) {\n      left++;\n      right--;\n    }\n    else return false;\n  }\n  return true;\n};\nconsole.log(isPalindrome(head));\n'}},function(n,e){n.exports={code236:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet bst = new BinaryTreeHelper([3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]);\nlet root = bst.getRoot();\n\n// 题干：所有 Node.val 互不相同\n// 注意：p 和 q 是节点\nfunction lowestCommonAncestor(root, p, q) {\n  let result = null, temp = [p.val, q.val];\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return false;\n    let ifInLeft = recursion(root.left);\n    let ifInRight = recursion(root.right);\n    if (ifInLeft && ifInRight || temp.includes(root.val) && (ifInLeft || ifInRight)) {\n      result = root;\n      return false;\n    }\n    return temp.includes(root.val) || (ifInLeft || ifInRight);\n  }\n};\n\nconsole.log(lowestCommonAncestor(root, 5, 1));\n"}},function(n,e){n.exports={code238:"\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nfunction productExceptSelf(nums) {\n  let leftToRight = [], rightToLeft = [], result = [], len = nums.length;\n  for (let i = 0; i < len; i++) leftToRight[i] = nums[i] * (leftToRight[i - 1] === undefined ? 1 : leftToRight[i - 1]);\n  for (let i = len - 1; i >= 0; i--) rightToLeft[i] = nums[i] * (rightToLeft[i + 1] === undefined ? 1 : rightToLeft[i + 1]);\n  for (let i = 0; i < len; i++) result[i] = (rightToLeft[i + 1] === undefined ? 1 : rightToLeft[i + 1]) * (leftToRight[i - 1] === undefined ? 1 : leftToRight[i - 1]);\n  return result;\n};\nconsole.log(productExceptSelf([2, 3, 2, 4, 5, 3]));\n"}},function(n,e){n.exports={code240:"\n/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\nfunction searchMatrix(matrix, target) {\n  let [i, j] = [0, matrix[0].length - 1];\n  let [row, column] = [matrix.length - 1, j];\n  while ((i >= 0 && i <= row) && (j >=0 && j <= column) ) {\n    if (matrix[i][j] < target) i++;\n    else if (matrix[i][j] > target) j--;\n    else if (matrix[i][j] === target) return true;\n  }\n  return false;\n};\nconsole.log(searchMatrix([[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], 30));\n"}},function(n,e){n.exports={code279:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction calcNumSquares(n) {\n  let list = [], num = 1, temp = num ** 2;\n  while (temp <= n) {\n    list.push(temp);\n    temp = (++num) ** 2;\n  }\n  return list;\n}\n\nfunction numSquares(n) {\n  let map = [0, 1];\n  let sequence = calcNumSquares(n);\n  console.log(sequence);\n  for (let i = 1; i <= n; i++) {\n    if (sequence.includes(i)) {\n      map[i] = 1;\n    }\n    else {\n      let min = Number.MAX_SAFE_INTEGER;\n      for (let j = 0, len = sequence.length; j < len; j++) {\n        const temp = map[sequence[j]] + map[i - sequence[j]];\n        min = temp < min ? temp : min;\n      }\n      map[i] = min;\n    }\n  }\n  console.log(map);\n  return map[n];\n};\nconsole.log(numSquares(13));\n"}},function(n,e){n.exports={code283:"\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\nfunction moveZeroes(nums) {\n  let [i, j, len] = [0, 0, nums.length];\n  while (nums[i] !== 0 && i < len) {\n    i++;\n    j++;\n  }\n  while (j < len) {\n    while (nums[j] === 0) {\n      j++;\n    }\n    if(nums[j] !== undefined) [nums[i], nums[j]] = [nums[j], nums[i]];\n    i++;\n    j++;\n  }\n};\nmoveZeroes([0,0, 1, 2, 0,3,0,4,0,5,0,6,7]);\n"}},function(n,e){n.exports={code287:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n// 把数组看成链表,下标和数值对应\nfunction findDuplicate(nums) {\n  let [slow, fast] = [0, 0];\n  do {\n    slow = nums[slow];\n    fast = nums[nums[fast]];\n  } while (nums[slow] !== nums[fast]);\n  fast = 0;\n  while (nums[slow] !== nums[fast]) {\n    slow = nums[slow];\n    fast = nums[fast];\n  }\n  return nums[slow]\n};\nconsole.log(findDuplicate([1, 3, 4, 2, 2]));\n"}},function(n,e){n.exports={code3:'\n/**\n * @param {string} s\n * @return {number}\n */\n// 滑动窗口法\nfunction lengthOfLongestSubstring(s) {\n  let maxLength = 0; // 存储所有不重复字符的最大长度值\n  let tempLength = 0; // 存储当前不重复字符的长度\n  let diffStrArr = []; // 存储当前不重复的字符\n  for (let i = 0, len = s.length; i < len; i++){\n    let idx = diffStrArr.indexOf(s[i]);\n    if (idx < 0) {\n      diffStrArr.push(s[i]);\n      tempLength++;\n    }\n    else {\n      if (tempLength > maxLength) maxLength = tempLength;\n      diffStrArr = [...diffStrArr.slice(idx + 1), s[i]]; \n      tempLength = diffStrArr.length;\n    }\n  }\n  return Math.max(maxLength, tempLength); // 假如只有一个字符串那么maxLength将不会更新\n};\nlet result = lengthOfLongestSubstring("pwwkew");\nconsole.log(result);'}},function(n,e){n.exports={code300:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n// 回溯: 超时\nfunction lengthOfLIS(nums) {\n  let path = [], result = 0, len = nums.length;\n  if (len === 1) return 1;\n  backTracking(0);\n  return result;\n  function backTracking(startIndex) {\n    let pathLen = path.length;\n    if (path[pathLen - 1] <= path[pathLen - 2]) return;\n    if (len - startIndex < result && path.length === 1) return;\n    console.log(path);\n    result = pathLen > result ? pathLen : result;\n    for (let i = startIndex; i < len; i++) {\n      path.push(nums[i]);\n      backTracking(i + 1);\n      path.pop();\n    }\n  }\n};\n// 动态规划\nfunction lengthOfLIS(nums) {\n  let dp = [], result = 1;\n  for (let i = 0, len = nums.length; i < len; i++) {\n    dp[i] = 1;\n    let max = 0;\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        max = max > dp[j] ? max : dp[j];\n      }\n    }\n    dp[i] = max + dp[i];\n    result = dp[i] > result ? dp[i] : result;\n    console.log(dp);\n  }\n  return result;\n}\nconsole.log(lengthOfLIS([1, 3, 6, 7, 9, 4, 10, 5, 6]));\n"}},function(n,e){n.exports={code31:"\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\n/*\n  1. 从右往左找到第一个顺序组合,即左边的数(num1)小于右边的数(num2)\n  2. 把num1插入到右边的序列中,同时把插入点位置上的数(num3)与原本(num1)位置上的数互换\n  3. 这样num3右边的数都是逆序的,只要把逆序数改为正序就可以了\n  4. 这样就完成了找到下一个排列\n*/\nfunction nextPermutation(nums) {\n  let len = nums.length;\n  if (len === 1) return nums;\n  else if (len === 2) return nums.reverse();\n  let index = len - 1;\n  // 实现第一步\n  while (nums[index - 1] >= nums[index--]);\n  console.log(index);\n  if (index < 0) return nums.reverse();\n  // 实现第二步\n  let target;\n  for (var i = index + 1; i < len; i++) {\n    if (nums[i] <= nums[index]) {\n      target = i;\n      break;\n    }\n  }\n  if (i === len) target = len;\n  [nums[index], nums[target - 1]] = [nums[target - 1], nums[index]];\n  // 双指针实现第三步\n  [left, right] = [index + 1, len - 1];\n  while (left <= right) {\n    [nums[left], nums[right]] = [nums[right], nums[left]];\n    left++;\n    right--;\n  }\n  // 实现第四步\n  return nums;\n};\n\nvar nextPermutation = function (nums) {\n  let lastIndex = nums.length - 1, p1 = lastIndex, p2, target;\n  while (p1 >= 0) {\n    if (nums[p1] <= nums[p1 - 1]) p1--;\n    else break;\n  }\n  p2 = p1 - 1;\n  if (p2 !== -1) {\n    target = nums[p2];\n    p1 = lastIndex;\n    while (p1 >= p2) {\n      if (nums[p1] <= target) p1--;\n      else break;\n    }\n    p1 > p2 && swap(p1, p2);\n  }\n  p2++;\n  p1 = lastIndex;\n  while (p2 <= p1) {\n    swap(p1, p2);\n    p1--;\n    p2++;\n  }\n  function swap(p1, p2) {\n    [nums[p2], nums[p1]] = [nums[p1], nums[p2]];\n  }\n};\n\nconsole.log(nextPermutation([2, 1, 3]));\n"}},function(n,e){n.exports={code322:"\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nfunction coinChange(coins, amount) {\n  let list = [0];\n  for (let i = 1; i <= amount; i++) {\n    if (coins.includes(i)) {\n      list[i] = 1;\n      continue;\n    }\n    let min = Number.POSITIVE_INFINITY;\n    for (let j = 1; j < i; j++) {\n      const temp = list[j] + list[i - j];\n      min = temp < min ? temp : min;\n    }\n    list[i] = min;\n  }\n  return Number.isFinite(list[amount]) ? list[amount] : -1;\n};\n\nconsole.log(coinChange([1, 2, 5], 11));\n"}},function(n,e){n.exports={code33:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n*/\n// function search(nums, target) {\n//   for (let i = 0; i < nums.length; i++){\n//     if (nums[i] === target) return i;\n//   }\n//   return -1;\n// };\n// 二分法\nfunction search(nums, target) {\n  let len = nums.length;\n  if (len === 0) return -1;\n  else if (len === 1) return target === nums[0] ? 0 : -1;\n  let [left, right] = [0, len - 1];\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (target === nums[mid]) return mid;\n    // 0 - mid升序\n    if (nums[0] <= nums[mid]) {\n      if (nums[0] <= target && target <= nums[mid]) {\n        right = mid - 1;\n      }\n      else {\n        left = mid + 1;\n      }\n    }\n    // mid - len-1 升序\n    else {\n      if (nums[mid] <= target && target <= nums[len - 1]) {\n        left = mid + 1\n      }\n      else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}\n"}},function(n,e){n.exports={code338:"\n/**\n * @param {number} n\n * @return {number[]}\n */\n\nfunction judge(n) {\n  // 判断是否为2的幂次方\n  return (n & (n - 1)) === 0;\n}\n\nfunction countBits(n) {\n  let list = [0], idx = 0;\n  if (n === 0) return list;\n  for (let i = 1; i <= n; i++) {\n    let flag = judge(i);\n    if (flag) {\n      idx = i;\n      list[i] = 1;\n      continue;\n    }\n    else {\n      list[i] = list[i - idx] + list[idx];\n    }\n  }\n  return list;\n};\n\n// console.log(countBits(10));\n"}},function(n,e){n.exports={code34:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n// 暴力\nfunction searchRange(nums, target) {\n  let len = nums.length;\n  if (len === 0) return [-1, -1];\n  else if (len === 1) return target === nums[0] ? [0, 0] : [-1, -1];\n  let first = -1, last = -1, flag = false;\n  for (let i = 0, len = nums.length; i < len; i++) {\n    if (!flag && nums[i] === target) {\n      first = i;\n      flag = true;\n    }\n    if (flag && nums[i] === target && nums[i + 1] !== target) {\n      last = i;\n      break;\n    }\n  }\n  return [first, last];\n};\n// 二分\nfunction searchRange(nums, target) {\n  let result = [];\n  // 找第一个等于target的数\n  let [left, right] = [0, nums.length - 1];\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2);\n    if (nums[mid] >= target) right = mid;\n    else left = mid + 1;\n  }\n  if (nums[right] === target) result.push(right);\n  else return [-1, -1]; // 如果第一个都不存在肯定没有最后一个等于target的值\n  // 找最后一个等于target的数\n  [left, right] = [0, nums.length - 1];\n  while (left < right) {\n    let mid = Math.ceil((left + right) / 2);\n    if (nums[mid] <= target) left = mid;\n    else right = mid - 1;\n  }\n  result.push(left);\n  return result;\n}\n"}},function(n,e){n.exports={code347:"\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\n\nfunction topKFrequent(nums, k) {\n  let map = new Map();\n  nums.forEach(item => {\n    const temp = map.get(item)?.val;\n    if (!temp) map.set(item, { name: item, val: 1 });\n    else map.set(item, { name: item, val: temp + 1 });\n  });\n  const values = [...map.values()];\n  values.sort((a, b) => b.val - a.val);\n  let result = [];\n  for (let i = 0; i < k; i++) {\n    result.push(values[i].name);\n  }\n  return result;\n};\n\nconsole.log(topKFrequent([1,1,1,2,2,3], 2));\n"}},function(n,e){n.exports={code39:"\n/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nfunction combinationSum(candidates, target) {\n  let path = [], result = []; // path存放搜索路径\n  backTracking(0, 0);\n  return result;\n  function backTracking(sum, startIndex) {\n    if (sum > target) return;\n    else if (sum === target) {\n      result.push(Array.from(path));\n      return;\n    }\n    for (let i = startIndex; i < candidates.length; i++){\n      path.push(candidates[i]);\n      sum += candidates[i];\n      backTracking(sum, i);\n      sum -= candidates[i];\n      path.pop();\n    }\n  }\n};\nconsole.log(combinationSum([2, 1, 3], 4));\n"}},function(n,e){n.exports={code394:'\n/**\n * @param {string} s\n * @return {string}\n */\n\nfunction getCode(s) {\n  return s?.codePointAt();\n}\n\nfunction ifNumber(s) {\n  return getCode(s) >= 48 && getCode(s) <= 57;\n}\n\nfunction ifLetter(s) {\n  return getCode(s) >= 97 && getCode(s) <= 122;\n}\n\n// 0 -> 48; 9 -> 57; a -> 97; z -> 122\nfunction decodeString(s) {\n  let stack = [], result = "", firstNumber = true;\n  for (let i = 0, len = s.length; i < len; i++) {\n    const char = s[i];\n    if (ifLetter(char)) {\n      if (firstNumber) result += char;\n      else stack.push(char);\n    }\n    else if (ifNumber(char)) {\n      stack.push(char);\n      firstNumber = false;\n    }\n    else if (char === "[") {\n      if (ifNumber(s[i + 1])) {\n        stack.push("");\n      } \n    }\n    else if (char === "]") {\n      console.log(stack);\n      let subStr = "", subNum = "", popStr = "";\n      do {\n        subStr = popStr + subStr;\n        popStr = stack.pop();\n      }while(ifLetter(popStr))\n      do {\n        subNum = popStr + subNum;\n        popStr = stack.pop();\n      } while (ifNumber(popStr))\n      popStr && stack.push(popStr);\n      const tempRes = subStr.repeat(Number.parseInt(subNum));\n      if (stack.length) stack.push(tempRes);\n      else result += tempRes;\n    }\n  }\n  if (stack.length) stack.forEach(char => result += char);\n  return result;\n}\n\nconsole.log(decodeString("3[z]2[2[y]pq4[2[jk]e1[f]]]ef"));\n'}},function(n,e){n.exports={code4:"\n/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number}\n */\nfunction findMedianSortedArrays(nums1, nums2) {\n  let [len1, len2] = [nums1.length, nums2.length];\n  if (len1 > len2) {\n    return findMedianSortedArrays(nums2, nums1);\n  }\n  let [left, right] = [0, len1];\n  let max_left_part = 0,\n    min_right_part = 0;\n  let i, j, left_nums1_max, left_nums2_max, right_nums1_min, right_nums2_min;\n  const MAX = Number.POSITIVE_INFINITY,\n    MIN = Number.NEGATIVE_INFINITY;\n  while (left <= right) {\n    i = ~~((left + right) / 2);\n    j = ~~((len1 + len2 + 1) / 2 - i);\n    left_nums1_max = i === 0 ? MIN : nums1[i - 1],\n    left_nums2_max = j === 0 ? MIN : nums2[j - 1],\n    right_nums1_min = i === len1 ? MAX : nums1[i],\n    right_nums2_min = j === len2 ? MAX : nums2[j];\n    if (left_nums1_max <= right_nums2_min) {\n      max_left_part = left_nums1_max >= left_nums2_max ? left_nums1_max : left_nums2_max;\n      min_right_part = right_nums1_min <= right_nums2_min ? right_nums1_min : right_nums2_min;\n      left = i + 1;\n    }\n    else {\n      right = i - 1;\n    }\n  }\n  return (len1 + len2) % 2 === 0 ? (max_left_part + min_right_part) / 2 : max_left_part;\n};\nconsole.log(findMedianSortedArrays([1, 3], [2]));\n"}},function(n,e){n.exports={code416:"\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\n\n// 回溯，好像超时了\nfunction calcSetSum(subSet) {\n  return subSet.reduce((pre, curr) => pre += curr, 0);\n}\n\nfunction calcSetComplement(subSet, target) {\n  const copyTarget = [...target];\n  for (let i = 0, len = subSet.length; i < len; i++) {\n    const idx = copyTarget.indexOf(subSet[i]);\n    if (idx >= 0) copyTarget.splice(idx, 1);\n  }\n  return copyTarget;\n}\n\nfunction canPartition(nums) {\n  let result = [], path = [], len = nums.length, flag = false;\n  backTracking(0);\n  return flag;\n  function backTracking(start) {\n    result.push(Array.from(path));\n    const res1 = calcSetSum(path);\n    const res2 = calcSetSum(calcSetComplement(path, nums));\n    if (res1 === res2) flag = true;\n    if (path.length === len || flag) {\n      return;\n    }\n    for (let i = start; i < len; i++) {\n      path.push(nums[i]);\n      backTracking(i + 1);\n      path.pop();\n    }\n  }\n};\n\nconsole.log(canPartition([100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,99,97]));\n"}},function(n,e){n.exports={code437:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {number}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet bst = new BinaryTreeHelper([1, -2, -3, 1, 3, -2, null, -1]);\nlet root = bst.getRoot();\n\nfunction backTracking(map, val) {\n  map.set(val, map.get(val) - 1);\n}\n\nfunction pathSum(root, targetSum) {\n  let map = new Map().set(0, 1), result = 0;\n  recursion(root,  0);\n  return result;\n  function recursion(root, prefix) {\n    if (root === null) return null;\n    prefix += root.val;\n    result += map.get(prefix - targetSum) ?? 0;\n    let temp = map.get(prefix);\n    map.set(prefix, (temp ?? 0) + 1);\n    temp = recursion(root.left, prefix);\n    // 如果返回的不是空节点需要把前缀和减掉\n    temp !== null && backTracking(map, prefix + temp);\n    temp = recursion(root.right, prefix);\n    // 如果返回的不是空节点需要把前缀和减掉\n    temp !== null && backTracking(map, prefix + temp);\n    return root.val;\n  }\n};\n\nconsole.log(pathSum(root, -3));\n"}},function(n,e){n.exports={code448:"\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n\nfunction findDisappearedNumbers(nums) {\n  const temp = [...new Array(nums.length + 1).keys()].slice(1);\n  return temp.filter(item => !nums.includes(item));\n};\n\nconsole.log(findDisappearedNumbers([4,3,2,7,8,2,3,1]));\n"}},function(n,e){n.exports={code46:"\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\n\nfunction permute(nums) {\n  let result = [], path = []; // path存取路径\n  backTracking(nums);\n  return result;\n  function backTracking(rest) {\n    if (rest.length === 0) {\n      result.push(Array.from(path));\n      return;\n    }\n    for (let i = 0; i < rest.length; i++){\n      const copy = rest[i];\n      path.push(copy);\n      rest.splice(i, 1);\n      backTracking(rest);\n      rest.splice(i, 0, copy);\n      path.pop();\n    }\n  }\n\n};\nconsole.log(permute([1, 2, 3]));\n"}},function(n,e){n.exports={code461:"\n/**\n * @param {number} x\n * @param {number} y\n * @return {number}\n */\nfunction countOne(num) {\n  let cnt = 0;\n  while (num) {\n    num = num & (num - 1);\n    cnt++;\n  }\n  return cnt;\n}\n\nfunction hammingDistance(x, y) {\n  return countOne(x ^ y);\n};\n\nconsole.log(hammingDistance(1, 4));\n"}},function(n,e){n.exports={code48:"\n/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nfunction rotate(matrix) {\n  // 把当前元素旋转到下一个位置(next)时，就把next上的元素也旋转到下一个位置\n  // 从外层向内层遍历更新\n  // 从第一行(最外层)开始更新\n  let len = matrix.length;\n  recursion(0, len);\n  return matrix;\n  function recursion(startIndex, n) {\n    // startIndex开始的坐标，n为壳的某一边长度\n    if (n <= 0) return;\n    for (let i = startIndex; i < (len + n) / 2 - 1; i++) {\n      let x = startIndex, y = i, startValue = matrix[x][y], cnt = 0; // 每次只要循环四次就行\n      while (cnt++ < 4) {\n        let tx = y, ty = len - 1 - x, tmp = matrix[tx][ty];\n        matrix[tx][ty] = startValue;\n        [startValue, x, y] = [tmp, tx, ty];\n      }\n    }\n    recursion(startIndex + 1, n - 2);\n  }\n};\nconsole.log(rotate([[5, 1, 9], [2, 4, 8], [13, 3, 6]]));\n"}},function(n,e){n.exports={code49:'\n/**\n * @param {string[]} strs\n * @return {string[][]}\n */\n// hashTable\nfunction groupAnagrams(strs) {\n  let map = new Map();\n  for (let str of strs) {\n    // 同一种异位词单词排序后肯定相同\n    let tmp = Array.from(str).sort().join(""), array = map.get(tmp);\n    if (array === undefined) array = [];\n    array.push(str);\n    map.set(tmp, array);\n  }\n  return Array.from(map.values());\n};\nconsole.log(groupAnagrams(["eat", "tea", "tan", "ate", "nat", "bat"]));\n'}},function(n,e){n.exports={code494:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n*/\n\nfunction sum(symbol, nums) {\n  let sum = 0;\n  nums.forEach((item, index) => sum += item * symbol[index]);\n  return sum;\n}\n\nfunction findTargetSumWays(nums, target) {\n  let result = 0, len = nums.length, path = [], symbol = [1, -1];\n  backTracking();\n  return result;\n  function backTracking() {\n    if (path.length === len) {\n      sum(path, nums) === target && result++;\n      return;\n    }\n    for (let i = 0; i < 2; i++) {\n      path.push(symbol[i]);\n      backTracking();\n      path.pop();\n    }\n  }\n};\n\n// 为啥下面这个比上面的慢呢？\n// function findTargetSumWays(nums, target) {\n//   let result = 0, len = nums.length, path = 0, symbol = [1, -1];\n//   backTracking(0);\n//   return result;\n//   function backTracking(index) {\n//     if (index === len) {\n//       path === target && result++;\n//       return;\n//     }\n//     for (let i = 0; i < 2; i++) {\n//       console.log(path);\n//       path += nums[index] * symbol[i];\n//       backTracking(index + 1);\n//       path -= nums[index] * symbol[i];\n//     }\n//   }\n// };\n\nconsole.log(findTargetSumWays([1, 1, 1, 1, 1], 3));\n"}},function(n,e){n.exports={code5:'\n/**\n * @param {string} s\n * @return {string}\n */\n\n方法1:\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}\nclass LinkedList{\n  constructor() {\n    this.head = new ListNode(\'head\');\n  }\n  add(value) {\n    let node = new ListNode(value);\n    let currentNode = this.head;\n    while (currentNode.next) currentNode = currentNode.next;\n    currentNode.next = node;\n  }\n  toString() {\n    let currentNode = this.head, array = [];\n    while (currentNode) {\n      array.push(currentNode.val);\n      currentNode = currentNode.next;\n    }\n    console.log(array.join(" --\x3e "));\n  }\n}\nfunction longestPalindrome(s) {\n  let len = s.length;\n  if (len === 1) return s;\n  else if (len === 2) {\n    if (s[0] === s[1]) return s;\n    else return s[0];\n  }\n  else {\n    let map = {}, palindrome = "";\n    // 将所有元素的下标存到链表里,从右往左存会让下标大的存储在链表的开头\n    for (let i = len - 1; i >= 0; i--){\n      if (map[s[i]] === undefined) {\n        let llist = new LinkedList();\n        llist.add(i);\n        map[s[i]] = llist;\n      }\n      else {\n        map[s[i]].add(i);\n      }\n    }\n    for (let i = 0; i < len; i++){\n      let left = i, point = map[s[i]].head.next, copyRight = right = point.val; // copyRight存储是从哪个下标开始比较的\n      while (left < right) {\n        if (s[left] === s[right]) {\n          right--;\n          left++;\n        }\n        else {\n          left = i;\n          point = point.next;\n          copyRight = right = point.val;\n        }\n      }\n      result = s.slice(i, copyRight + 1);\n      palindrome = result.length > palindrome.length ? result : palindrome;\n    }\n    return palindrome;\n  }\n};\n\n方法2:\nfunction genArray(num) {\n  let result = [];\n  for (let i = 0; i < num; i++) result.push(new Array(num).fill(true));\n  return result;\n}\n\nvar longestPalindrome = function (s) {\n  const len = s.length, dp = genArray(len);\n  let left = 0, right = 0, maxLen = 1;\n  for (let j = 1; j < len; j++) {\n    for (let i = j - 1; i >= 0; i--) {\n      dp[i][j] = dp[i + 1][j - 1] && s[i] === s[j];\n      if (dp[i][j] && j - i + 1 > maxLen) {\n        left = i;\n        right = j;\n        maxLen = j - i + 1;\n      }\n    }\n  }\n  return s.slice(left, right + 1);\n};\n\nconsole.log(longestPalindrome("babad"));\n'}},function(n,e){n.exports={code53:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n// 动态规划\nfunction maxSubArray(nums) {\n  let len = nums.length;\n  if (len === 1) return nums[0];\n  let max = nums[0], sum = 0;\n  for (let i = 0; i < len; i++){\n    // max = Math.max(max, sum + nums[i], nums[i]);\n    // sum = sum + nums[i] > nums[i] ? sum + nums[i] : nums[i];\n    sum = sum + nums[i] > nums[i] ? sum + nums[i] : nums[i];\n    max = max > sum ? max : sum;\n  }\n  return max;\n};\nconsole.log(maxSubArray([5]));\n"}},function(n,e){n.exports={code543:"\nfunction diameterOfBinaryTree(root) {\n  let result = 0;\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return 0;\n    let left = recursion(root.left), right = recursion(root.right);\n    result = Math.max(left + right, result);\n    return Math.max(left, right) + 1;\n  }\n};\n"}},function(n,e){n.exports={code55:"\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\n// 贪心\nfunction canJump(nums) {\n  let max = 0; // 代表能到的最远的距离\n  for (let i = 0, len = nums.length; i < len; i++) {\n    if (i <= max) {\n      max = Math.max(max, i + nums[i]);\n      if (max === i && max < len - 1) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nconsole.log(canJump([0]));\n"}},function(n,e){n.exports={code56:"\n/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\n// 把区间先按第一个数从小到大排序\nfunction sortIntervalByLeftBound(intervals) {\n  let map = new Map();\n  intervals.forEach(item => {\n    let res = map.get(item[0]);\n    // 把相同左边界的区间先合并\n    if (res === undefined || res[1] < item[1]) map.set(item[0], item);\n  });\n  return Array.from(map).sort((a, b) => a[0] - b[0]).map(item => item[1]);\n}\nfunction merge(intervals) {\n  let afterSortIntervals = sortIntervalByLeftBound(intervals);\n  let result = []\n  afterSortIntervals.forEach((item, index) => {\n    if (index === 0) {\n      result.push(item);\n    }\n    else {\n      let lastElement = result[result.length - 1];\n      if (item[0] <= lastElement[1]) {\n        if (item[1] > lastElement[1]) lastElement[1] = item[1];\n      }\n      else result.push(item);\n    }\n  });\n  return result;\n};\n\nvar merge = function (intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n  return intervals.reduce((prev, curr) => {\n    const last = prev[prev.length - 1];\n    if (!prev.length || curr[0] > last[1]) {\n      prev.push(curr);\n    } else if (curr[0] <= last[1]) {\n      last[1] = curr[1] <= last[1] ? last[1] : curr[1];\n    }\n    return prev;\n  }, []);\n};\n\nconsole.log(merge([[1, 4], [2,3]]));\n"}},function(n,e){n.exports={code560:"\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\n\nfunction subarraySum(nums, k) {\n  const map = new Map().set(0, 1);\n  let prefix = 0, result = 0;\n  nums.forEach(item => { \n    prefix += item;\n    let temp1 = map.get(prefix - k), temp2 = map.get(prefix);\n    result += (temp1 ?? 0);\n    map.set(prefix, temp2 === undefined ? 1 : temp2 + 1);\n  });\n  return result;\n};\n\nconsole.log(subarraySum([3, 4, 7, 2, -3, 1, 4, 2], 7));\n"}},function(n,e){n.exports={code581:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\n// 排序\nfunction findUnsortedSubarray(nums) {\n  let copy = [...nums].sort((a, b) => a - b);\n  let len = nums.length, left = 0, right = len - 1;\n  while (nums[left] === copy[left] && left < len) left++;\n  while (left < right && nums[right] === copy[right]) right--;\n  return right === left ? 0 : right - left + 1;\n}\n\nconsole.log(findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]));\n"}},function(n,e){n.exports={code617:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet bst1 = new BinaryTreeHelper([1, 3, 2, 5, null, null, null]);\nlet bst2 = new BinaryTreeHelper([2, 1, 3, null, 4, null, 7]);\n\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val)\n  this.left = (left === undefined ? null : left)\n  this.right = (right === undefined ? null : right)\n}\n\nfunction mergeTrees(root1, root2) {\n  if (root1 === null || root2 === null) {\n    return root1 || root2;\n  }\n  root1.val = root1.val + root2.val;\n  root1.left = mergeTrees(root1?.left ?? null, root2?.left ?? null);\n  root1.right = mergeTrees(root1?.right ?? null, root2?.right ?? null);\n  return root1;\n};\n\nmergeTrees(bst1.root, bst2.root)\nbst1.logTree();\n"}},function(n,e){function t(n,e,t){return n[e]&&n[e][t]}n.exports={code62:"\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\n// 求阶乘\nfunction factorial(n) {\n  return [...(new Array(n)).keys()].map(idx => idx + 1).reduce((pre, curr) => pre *= curr, 1);\n};\n// 每条路径的长度为 m + n - 2\nfunction uniquePaths(m, n) {\n  return factorial(m + n - 2) / (factorial(m - 1) * factorial(n - 1));\n};\nconsole.log(uniquePaths(3, 7));\n"},console.log(function(n,e){let r=function(n,e){const t=[];for(let r=0;r<n;r++){t[r]=[];for(let n=0;n<e;n++)t[r][n]=0}return t}(n,e);r[0][0]=1;for(let i=0;i<n;i++)for(let n=0;n<e;n++){var s,o;0===i&&0===n||(r[i][n]=(null!==(s=t(r,i-1,n))&&void 0!==s?s:0)+(null!==(o=t(r,i,n-1))&&void 0!==o?o:0))}return r[n-1][e-1]}(3,3))},function(n,e){n.exports={code64:"\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nfunction minPathSum(grid) {\n  let dp = []; // dp数组\n  let [row, column] = [grid.length, grid[0].length];\n  grid.forEach((item, index) => dp[index] = new Array(column));\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      if (i === 0 && j === 0) dp[0][0] = grid[0][0];\n      else if (i === 0) dp[0][j] = dp[0][j - 1] + grid[0][j];\n      else if (j === 0) dp[i][0] = dp[i - 1][0] + grid[i][0];\n      else dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n    }\n  }\n  return dp[row - 1][column - 1];\n};\n"}},function(n,e){n.exports={code70:"\n/**\n * @param {number} n\n * @return {number}\n */\n// 递归\nfunction climbStairs(n) {\n  if (n === 1) return 1;\n  else if (n === 2) return 2;\n  return climbStairs(n - 1) + climbStairs(n - 2);\n};\n// 动态规划\nfunction climbStairs(n) {\n  let dp = [1, 2];\n  for (let i = 2; i < n; i++) dp[i] = dp[i - 1] + dp[i - 2];\n  return dp[n - 1];\n};\nconsole.log(climbStairs(45));\n"}},function(n,e){n.exports={code739:"\n/**\n * @param {number[]} temperatures\n * @return {number[]}\n */\n\nfunction getStackTop(stack) {\n  return stack[stack.length - 1];\n}\n\nfunction dailyTemperatures(temperatures) {\n  let stack = [], result = [];\n  temperatures.forEach((item, index) => {\n    if (!stack.length) {\n      stack.push({ index, val: item });\n    }\n    else {\n      let top = getStackTop(stack);\n      while (stack.length && item > top.val) {\n        result[top.index] = index - top.index;\n        stack.pop();\n        top = getStackTop(stack);\n      }\n      stack.push({ index, val: item });\n    }\n  })\n  stack.forEach(item => result[item.index] = 0);\n  return result;\n};\n\nconsole.log(dailyTemperatures([30, 60, 90]));\n"}},function(n,e){n.exports={code75:"\n/**\n * @param {number[]} nums\n * @return {void} Do not return anything, modify nums in-place instead.\n */\n// 单指针\nfunction sortColors(nums) {\n  let len = nums.length, point = 0;\n  for (let i = 0; i < len; i++) {\n    if (nums[i] === 0) {\n      [nums[i], nums[point]] = [nums[point], nums[i]];\n      ++point;\n    }\n  }\n  console.log(nums);\n  for (let i = point; i < len; i++) {\n    if (nums[i] === 1) {\n      [nums[i], nums[point]] = [nums[point], nums[i]];\n      ++point;\n    }\n  }\n  return nums;\n};\nconsole.log(sortColors([1, 2, 2, 2, 2, 0, 0, 0, 1, 1]));\n// 0, 0, 0, 1, 0, 1, 1, 1, 2, 2, 2, 2, 2\n"}},function(n,e){n.exports={code78:"\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nfunction subsets(nums) {\n  let result = [[]], path = [], len = nums.length;\n  backTacking(0);\n  return result;\n  function backTacking(startIndex) {\n    for (let i = startIndex; i < len; i++){\n      path.push(nums[i]);\n      result.push(Array.from(path));\n      backTacking(i + 1);\n      path.pop();\n    }\n  }\n};\nconsole.log(subsets([1, 2, 3]));\n"}},function(n,e){n.exports={code79:'\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nfunction exist(board, word) {\n  let [vistied, row, column, wordLength] = [[], board.length, board[0].length, word.length - 1];\n  // 初始化vistied数组, visit数组用来记录是否访问过\n  for (let i = 0; i < row; i++) {\n    vistied.push([]);\n    for (let j = 0; j < column; j++) {\n      vistied[i][j] = false;\n    }\n  }\n  // board的每一元素都有可能是单词的开始处\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      let res = backTracking(i, j, 0);\n      if (res) return true;\n    }\n  }\n  return false;\n  // x,y为开始的坐标,wordIndex为单词的第几个字母\n  function backTracking(x, y, wordIndex) {\n    /* \n      退出条件:\n      1.长度大于word的length\n      2.第i个字符不等于单词第i个字符\n      3.visited[i][j]为true\n      4.board[x][y]不合法,即i,j < 0 || i >= row || j >= column\n    */\n    if (x < 0 || y < 0 || x >= row || y >= column || board[x][y] !== word[wordIndex] || vistied[x][y]) {\n      return false;\n    }\n    if (wordIndex >= wordLength) {\n      return true;\n    }\n    vistied[x][y] = true;\n    let result = backTracking(x - 1, y, wordIndex + 1) || backTracking(x, y - 1, wordIndex + 1)\n      || backTracking(x + 1, y, wordIndex + 1) || backTracking(x, y + 1, wordIndex + 1)\n    vistied[x][y] = false;\n    return result;\n  }\n};\nconsole.log(exist(board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"));\n'}},function(n,e){n.exports={code94:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val)\n  this.left = (left === undefined ? null : left)\n  this.right = (right === undefined ? null : right)\n}\nlet root2 = new TreeNode(3);\nlet root1 = new TreeNode(2, root2, null);\nlet root = new TreeNode(1, null, root1);\nfunction inorderTraversal(root) {\n  let result = [];\n  inOrder(root);\n  return result;\n  function inOrder(root) {\n    if (root === null) return;\n    inOrder(root.left);\n    result.push(root.val);\n    inOrder(root.right);\n  }\n};\nconsole.log(inorderTraversal(root));\n"}},function(n,e){n.exports={code96:"\n/**\n * @param {number} n\n * @return {number}\n */\nfunction numTrees(n) {\n  let G = new Array(n + 1).fill(0);\n  G[0] = G[1] = 1;\n  for (let i = 2; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      G[i] += G[j] * G[i - j - 1];\n    }\n  }\n  return G[n];\n};\nconsole.log(numTrees(3));\n"}},function(n,e){n.exports={code98:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nimport BinaryTree from "../utils/binaryTree.js";\nlet arr = [5, 4, 6, null, null, 3, 7];\nlet root = new BinaryTree(arr).root;\n// 递归\nfunction isValidBST(root) {\n  const MIN = -(2 ** 31) - 1, MAX = (2 ** 31);\n  return process(root, MIN, MAX);\n  function process(root, min, max) {\n    if (root === null) return true;\n    if (root.val <= min || root.val >= max) return false;\n    let res = process(root.left, min, root.val) && process(root.right, root.val, max);\n    return res;\n  }\n};\n// 中序遍历\nfunction inorderTraversal(root) {\n  let result = [];\n  inOrder(root);\n  return result;\n  function inOrder(root) {\n    if (root === null) return;\n    inOrder(root.left);\n    result.push(root.val);\n    inOrder(root.right);\n  }\n};\nfunction isValidBST(root) {\n  let arr = inorderTraversal(root);\n  for (let i = 0; i < arr.length - 1; i++){\n    if (arr[i] >= arr[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n'}},function(n,e){n.exports={code103:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\n var zigzagLevelOrder = function (root) {\n  let queue = [], result = [], depth = 1, flag = false;\n  if (root === null) return result;\n  queue.push(root);\n  result.push([root.val]);\n  while (queue.length) {\n    for (let i = 0, len = queue.length; i < len; i++) {\n      let node = queue.shift(), opt = flag ? "push" : "unshift";\n      if (!result[depth] && (node.left || node.right)) {\n        result.push([]);\n      }\n      if (node.left) {\n        queue.push(node.left);\n        result[depth][opt](node.left.val);\n      }\n      if (node.right) {\n        queue.push(node.right);\n        result[depth][opt](node.right.val);\n      }\n    }\n    depth++;\n    flag = !flag;\n  }\n  return result;\n};\n'}},function(n,e){n.exports={code112:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([5, 4, 8, 11, null, 13, 4, 7, 2, null, null, null, null, null, 1]).getRoot();\n\nfunction hasPathSum(root, targetSum) {\n  let result = false, sum = 0;\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null || result) return 0;\n    sum += root.val;\n    if (root.left === null && root.right === null) {\n      result = sum === targetSum;\n      return root.val;\n    }\n    let leftVal = recursion(root.left);\n    sum -= leftVal;\n    let rightVal = recursion(root.right);\n    sum -= rightVal;\n    return root.val;\n  }\n};\n\nconsole.log(hasPathSum(root, 22));\n"}},function(n,e){n.exports={code1143:'\n/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\n\nfunction longestCommonSubsequence(text1, text2) {\n  let dp = [], len1 = text1.length, len2 = text2.length;\n  for (let i = 0; i < len1 + 1; i++) dp[i] = new Array(len2 + 1).fill(0);\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n    }\n  }\n  return dp[len1][len2];\n};\n\nconsole.log(longestCommonSubsequence("bdcaba", "abcbdab"));\n'}},function(n,e){n.exports={code12:'\n/**\n * @param {number} num\n * @return {string}\n */\nfunction intToRoman(num) {\n  // I = 1, V = 5, X = 10, L = 50, C = 100, D = 500, M = 1000\n  let romanArr = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];\n  let romanNum = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; // 存储每个字符代表的数字大小\n  let romanCharNum = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 用来存储各种字符有几个\n  let str = "";\n  for (let i = 0, len = romanNum.length; i < len; i++) {\n    romanCharNum[i] = Math.floor(num / romanNum[i]);\n    num %= romanNum[i];\n  }\n  for (let i = 0, len = romanCharNum.length; i < len; i++){\n    str += romanCharNum[i] === 0 ? "" : romanArr[i].repeat(romanCharNum[i]);\n  }\n  return str;\n};\nconsole.log(intToRoman(3));\n'}},function(n,e){n.exports={code122:"\n/**\n * @param {number[]} prices\n * @return {number}\n */\n\nfunction maxProfit(prices) {\n  let minPrice = prices[0], beforeMaxProfit = 0, result = 0;\n  for (let i = 1, len = prices.length; i < len; i++) {\n    if (prices[i] < prices[i - 1]) {\n      minPrice = prices[i];\n      beforeMaxProfit = result;\n    }\n    else {\n      result = Math.max(prices[i] - minPrice + beforeMaxProfit, result);\n    }\n  }\n  return result;\n};\n\nconsole.log(maxProfit([1, 2]));\n"}},function(n,e){n.exports={code123:"\n/**\n * @param {number[]} prices\n * @return {number}\n */\n\nfunction maxProfit(prices) {\n  \n};\n\nconsole.log(maxProfit([1, 2, 4, 2, 5, 7, 2, 4, 9, 0]));\n"}},function(n,e){n.exports={code125:"\n/**\n * @param {string} s\n * @return {boolean}\n */\n\nfunction isPalindrome(s) {\n  s = s.toLowerCase().match(/[0-9a-zA-Z]+/g)?.join('');\n  if (s === undefined) return true;\n  let left = 0, right = s.length - 1;\n  while (left <= right) {\n    if (s[left++] !== s[right--]) return false;\n  }\n  return true;\n};\n\nconsole.log(isPalindrome(\"0P\"));\n"}},function(n,e){n.exports={code1282:"\n/**\n * @param {number[]} groupSizes\n * @return {number[][]}\n */\n\nfunction groupThePeople(groupSizes) {\n  const map = new Map(), result = [];\n  groupSizes.forEach((item, index) => { \n    const bucket = map.get(item);\n    if (!bucket) map.set(item, [index]);\n    else bucket.push(index);\n  });\n  [...map.entries()].forEach(item => {\n    const everyNum = item[0], list = item[1], len = list.length;\n    let cnt = 0;\n    while (cnt < len) {\n      result.push(list.slice(cnt, cnt + everyNum));\n      cnt += everyNum;\n    }\n  })\n  return result;\n};\n\nconsole.log(groupThePeople([3, 3, 3, 3, 3, 1, 3]));\n"}},function(n,e){n.exports={code129:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nconst root = new BinaryTreeHelper([1, 2, 3]).getRoot();\n\nfunction sumNumbers(root) {\n  let result = 0, path = [];\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return false;\n    path.push(root.val);\n    if (root.left === null && root.right === null) {\n      result += Number.parseInt(path.join(''));\n      return true;\n    }\n    let left = recursion(root.left);\n    left && path.pop();\n    let right = recursion(root.right);\n    right && path.pop();\n    return true;\n  }\n};\n\nconsole.log(sumNumbers(root));\n"}},function(n,e){n.exports={code13:'\n/**\n * @param {string} s\n * @return {number}\n */\nfunction romanToInt(s) {\n  let romanCharArr = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];\n  let romanNum = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; // 存储每个字符代表的数字大小\n  let sum = 0;\n  if (s.length === 1) return romanNum[romanCharArr.indexOf(s)];\n  for (let i = 0, len = s.length; i < len; i++){\n    if (s[i] === "C" && s[i + 1] === "M" || s[i] === "C" && s[i + 1] === "D" || s[i] === "X" && s[i + 1] === "C" ||\n      s[i] === "X" && s[i + 1] === "L" || s[i] === "I" && s[i + 1] === "X" || s[i] === "I" && s[i + 1] === "V") {\n      sum += romanNum[romanCharArr.indexOf(s[i] + s[i + 1])];\n      i += 1;\n    }\n    else {\n      sum += romanNum[romanCharArr.indexOf(s[i])];\n    }\n  }\n  return sum;\n};\nconsole.log(romanToInt("MCMXCIV"));\n'}},function(n,e){n.exports={code1302:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([1, 2, 3, 4, 5, null, 6, 7, null, null, null, null, null, null, 8]).getRoot();\n\nfunction deepestLeavesSum(root) {\n  let node = [];\n  recursion(root, 0)\n  return node.at(-1).reduce((pre, curr) => pre += curr, 0);\n  function recursion(root, depth) {\n    if (root === null) return;\n    !node[depth] && (node[depth] = []);\n    node[depth].push(root.val);\n    recursion(root.left, depth + 1);\n    recursion(root.right, depth + 1);\n  }\n};\n\nconsole.log(deepestLeavesSum(root));\n"}},function(n,e){n.exports={code1374:"\n/**\n * @param {number} n\n * @return {string}\n */\n\nfunction generateTheString(n) {\n  if (n % 2 == 0) return 'a'.repeat(n - 1) + 'b';\n  return 'a'.repeat(n);\n};\n\nfunction generateTheString(n) {\n  return 'a'.repeat(n - 1) + (n % 2 ? 'a' : 'b');\n};\n\nconsole.log(generateTheString(4));\n"}},function(n,e){n.exports={code14:'\n/**\n * @param {string[]} strs\n * @return {string}\n */\nfunction longestCommonPrefix(strs) {\n  let str = "";\n  for (let i = 0, len1 = strs[0].length; i < len1; i++){\n    for (var j = 0, len2 = strs.length; j < len2 - 1; j++){\n      if (strs[j][i] !== strs[j + 1][i])\n        break;\n    }\n    if (j === len2 - 1) str += strs[j][i];\n    else return str;\n  }\n  return str;\n};\n'}},function(n,e){n.exports={code1408:'\n/**\n * @param {string[]} words\n * @return {string[]}\n */\n\nfunction stringMatching(words) {\n  const result = new Set();\n  for (let i = 0, len = words.length; i < len - 1; i++) {\n    const str = words[i];\n    for (let j = i + 1; j < len; j++) {\n      const temp = words[j];\n      temp.includes(str) && result.add(str);\n      str.includes(temp) && result.add(temp);\n    }\n  }\n  return [...result];\n};\n\nconsole.log(stringMatching(["mass","as","hero","superhero"]));\n'}},function(n,e){n.exports={code1413:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction minStartValue(nums) {\n  let result = Number.MAX_SAFE_INTEGER, sum = 0;\n  nums.forEach(item => {\n    sum += item;\n    result = sum < result ? sum : result;\n  })\n  return result > 0 ? 1 : 1 - result;\n};\n\nconsole.log(minStartValue([0, 2, 3, 4]));\n"}},function(n,e){n.exports={code1417:'\n/**\n * @param {string} s\n * @return {string}\n */\n\nfunction getCode(s) {\n  return s?.codePointAt();\n}\n\nfunction ifNumber(s) {\n  return getCode(s) >= 48 && getCode(s) <= 57;\n}\n\nfunction ifLetter(s) {\n  return getCode(s) >= 97 && getCode(s) <= 122;\n}\n\nfunction reformat(s) {\n  let stack1 = [], stack2 = [], result = "";\n  for (let char of s) {\n    if (ifNumber(char)) stack1.push(char);\n    else if (ifLetter(char)) stack2.push(char);\n  }\n  const len1 = stack1.length, len2 = stack2.length;\n  if (len1 < len2) {\n    [stack1, stack2] = [stack2, stack1];\n  }\n  while (stack1.length && stack2.length) {\n    result += stack1.pop();\n    result += stack2.pop();\n  }\n  if (!stack2.length) {\n    if (stack1.length === 1) {\n      result += stack1.pop();\n      return result;\n    }\n    else if (stack1.length === 0) {\n      return result\n    }\n  }\n  return "";\n};\n\nconsole.log(reformat("a0b1c2"));\n'}},function(n,e){n.exports={code1422:'\n/**\n * @param {string} s\n * @return {number}\n */\n\nfunction maxScore(s) {\n  let left = 0, right = 0, result = 0;\n  for (let char of s) {\n    if (char === "1") right++;\n  }\n  for (let i = 0, len = s.length; i < len - 1; i++) {\n    let char = s[i];\n    if (char === "0") left++;\n    if (char === "1") right--;\n    let temp = left + right;\n    result = temp > result ? temp : result;\n  }\n  return result;\n};\n\nconsole.log(maxScore("00"));\n'}},function(n,e){n.exports={code143:"\n/**\n * @param {ListNode} head\n * @return {void} Do not return anything, modify head in-place instead.\n */\n\n import { LinkedListHelper } from '@karl_fang/data-structure';\n let head = new LinkedListHelper([1, 2, 3, 4,5]).getNthNode();\n \n function ListNode(val, next) {\n   this.val = (val === undefined ? 0 : val)\n   this.next = (next === undefined ? null : next)\n }\n \n var reorderList = function (head) {\n   let newHead = new ListNode(\"head\"), currentNode = head;\n   const queue = [], copyHead = newHead;\n   while (currentNode) {\n     queue.push(currentNode);\n     currentNode = currentNode.next;\n   }\n   while (queue.length) {\n     let first = queue.shift(), last = queue.pop() ?? null;\n     newHead.next = first;\n     first.next = last;\n     newHead = last;\n   }\n   newHead && (newHead.next = null);\n   return copyHead.next;\n };\n \n LinkedListHelper.LinkedListToString(reorderList(head));\n"}},function(n,e){n.exports={code144:"\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nconst root = new BinaryTreeHelper([1, null, 2, null, null, 3, null]).getRoot();\n\nfunction preorderTraversal(root) {\n  const result = [];\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return;\n    result.push(root.val);\n    recursion(root.left);\n    recursion(root.right);\n  }\n};\n\nconsole.log(preorderTraversal(root));\n"}},function(n,e){n.exports={code145:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n  const result = [];\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return;\n    recursion(root.left);\n    recursion(root.right);\n    result.push(root.val);\n  }\n};\n"}},function(n,e){n.exports={code1450:"\n/**\n * @param {number[]} startTime\n * @param {number[]} endTime\n * @param {number} queryTime\n * @return {number}\n */\n\nfunction busyStudent(startTime, endTime, queryTime) {\n  let result = 0;\n  startTime.forEach((item, index) =>\n    (queryTime >= item && queryTime <= endTime[index]) && result++);\n  return result;\n};\n\nconsole.log(busyStudent([1, 2, 3], [3, 2, 7], 4));\n"}},function(n,e){n.exports={code1455:'\n/**\n * @param {string} sentence\n * @param {string} searchWord\n * @return {number}\n */\n\nfunction isPrefixOfWord(sentence, searchWord) {\n  const list = sentence.split(" ");\n  let result = -1;\n  for (let i = 0, len = list.length; i < len; i++) {\n    if (list[i].startsWith(searchWord)) {\n      result = i;\n      break;\n    }\n  }\n  return result < 0 ? result : result + 1;\n};\n\nconsole.log(isPrefixOfWord("hellohello hellohellohello", "ell"));\n'}},function(n,e){n.exports={code1460:"\n/**\n * @param {number[]} target\n * @param {number[]} arr\n * @return {boolean}\n */\n\nfunction canBeEqual(target, arr) {\n  let map = new Map(), flag = true;\n  target.forEach(item => {\n    const temp = map.get(item);\n    if (temp) map.set(item, temp + 1);\n    else map.set(item, 1);\n  });\n  for (let item of arr) {\n    const temp = map.get(item);\n    if (!temp) {\n      flag = false;\n      break;\n    }\n    map.set(item, temp - 1);\n  }\n  return flag && [...map.values()].filter(item => item !== 0).length === 0;\n};\n\nconsole.log(canBeEqual([1, 2, 3, 4], [1, 2, 3, 4]));\n"}},function(n,e){n.exports={code1464:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction maxProduct(nums) {\n  let first = -1, second = -2;\n  nums.forEach(item => {\n    if (item >= second && item < first) {\n      second = item;\n    }\n    else if (item >= first) {\n      second = first;\n      first = item;\n    }\n  })\n  return (first - 1) * (second - 1);\n};\n\nconsole.log(maxProduct([3, 4, 5, 2]));\n"}},function(n,e){n.exports={code1470:"\n/**\n * @param {number[]} nums\n * @param {number} n\n * @return {number[]}\n */\n\nfunction shuffle(nums, n) {\n  let p1 = 0, p2 = n, result = [];\n  while (p2 < 2 * n) result.push(nums[p1++], nums[p2++]);\n  return result;\n};\n\nconsole.log(shuffle([2, 5, 1, 3, 4, 7], 3));\n"}},function(n,e){n.exports={code150:'\n/**\n * @param {string[]} tokens\n * @return {number}\n */\n\nfunction str2num(str) {\n  return Number.parseInt(str);\n}\n\nfunction evalRPN(tokens) {\n  let stack = [], temp1 = 0, temp2 = 0;\n  tokens.forEach(item => {\n    switch (item) {\n      case \'+\':\n        stack.push(stack.pop() + stack.pop());\n        break;\n      case \'-\':\n        temp1 = stack.pop();\n        temp2 = stack.pop();\n        stack.push(temp2 - temp1);\n        break;\n      case \'*\':\n        stack.push(stack.pop() * stack.pop());\n        break;\n      case \'/\':\n        temp1 = stack.pop();\n        temp2 = stack.pop();\n        stack.push((~~(temp2 / temp1)));\n        break;\n      default:\n        stack.push(str2num(item));\n        break;\n    }\n  });\n  return stack.pop();\n};\n\nconsole.log(evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]));\n'}},function(n,e){n.exports={code151:'\n/**\n * @param {string} s\n * @return {string}\n */\n\n function reverseWords(s) {\n  s = s.trim().split(" ");\n  return s.filter(item => item !== "").reverse().join(" ");\n};\n\nconsole.log(reverseWords("a good   example"));\n'}},function(n,e){n.exports={code1582:"\n/**\n * @param {number[][]} mat\n * @return {number}\n */\n\nfunction numSpecial(mat) {\n  let row = mat.length,\n    column = mat[0].length,\n    set1 = new Array(row).fill(0),\n    set2 = new Array(column).fill(0),\n    set3 = new Set(),\n    result = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      if (mat[i][j] === 1) {\n        !set1[i] ? (set1[i] = 1) : set1[i]++;\n        !set2[j] ? (set2[j] = 1) : set2[j]++;\n        set3.add([i, j]);\n      }\n    }\n  }\n  for (let item of [...set3]) {\n    if (set1[item[0]] === 1 && set2[item[1]] === 1) result++;\n  }\n  return result;\n};\n\nconsole.log(numSpecial([[0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0]]));\n"}},function(n,e){n.exports={code1592:'\n/**\n * @param {string} text\n * @return {string}\n */\n\nfunction reorderSpaces(text) {\n  let spaceNum = text.match(/s/g)?.length ?? 0;\n  let word = text.match(/\b[a-z]+\b/g);\n  let len = word.length;\n  if (len === 1) return word[0] + " ".repeat(spaceNum);\n  let everyWordSpace = Math.floor(spaceNum / (len - 1));\n  let lastwordSpace = spaceNum % (len - 1);\n  return word.map((item, index) => {\n    if (index === len - 1) return item + " ".repeat(lastwordSpace);\n    return item + " ".repeat(everyWordSpace);\n  }).join("");\n};\n\nconsole.log(reorderSpaces("  hello"));\n'}},function(n,e){n.exports={code1598:'\n/**\n * @param {string[]} logs\n * @return {number}\n */\n\nfunction minOperations(logs) {\n  let stack = [];\n  for (let item of logs) {\n    if (item === "./") continue;\n    else if (item === "../") stack.pop();\n    else stack.push(item);\n  }\n  return stack.length;\n};\n\nconsole.log(minOperations(["d1/", "../", "../", "../"]));\n'}},function(n,e){n.exports={code16:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nfunction threeSumClosest(nums, target) {\n  nums.sort((a, b) => a - b);\n  let result = 0, dis = 10 ** 4 + 3000, ifEqual = false;\n  for (let i = 0, len = nums.length; i < len; i++) {\n    let [left, right] = [i + 1, len - 1];\n    while (left < right) {\n      temp = nums[i] + nums[left] + nums[right];\n      if (Math.abs(target - temp) < dis) {\n        dis = Math.abs(target - temp);\n        result = temp;\n      }\n      if (nums[i] + nums[left] + nums[right] < target) left++;\n      else if (nums[i] + nums[left] + nums[right] > target) right--;\n      else if (nums[i] + nums[left] + nums[right] === target) {\n        result = target;\n        ifEqual = true;\n        break;\n      }\n    }\n    if (ifEqual) break;\n  }\n  return result;\n};\nconsole.log(threeSumClosest([0, 1,2], 3));\n// -4, -3, -2, -2, 0, 1, 2, 2, 3, 5, 5, 6, 7 \n"}},function(n,e){n.exports={code165:'\n/**\n * @param {string} version1\n * @param {string} version2\n * @return {number}\n */\n\nfunction compareVersion(version1, version2) {\n  const ver1 = version1.split("."), ver2 = version2.split(".");\n  const len1 = ver1.length, len2 = ver2.length;\n  let p1 = 0, p2 = 0;\n  while (p1 < len1 || p2 < len2) {\n    const v1 = Number.parseInt(ver1[p1] ?? 0),\n      v2 = Number.parseInt(ver2[p2] ?? 0);\n    if (v1 < v2) return -1;\n    else if (v1 > v2) return 1;\n    p1++;\n    p2++;\n  }\n  return 0;\n};\n\nconsole.log(compareVersion("1.01.0", "1.001"));\nconsole.log(compareVersion("1.01.0.3", "1.001"));\nconsole.log(compareVersion("1.0.0", "1.0"));\nconsole.log(compareVersion("0.1", "1.1"));\n'}},function(n,e){n.exports={code1656:'\nclass OrderedStream {\n  /**\n   * @param {number} n\n   */\n  constructor(n) {\n    this.storage = new Array(n + 1);\n    this.ptr = 1;\n  }\n  /** \n   * @param {number} idKey \n   * @param {string} value\n   * @return {string[]}\n   */\n  insert(idKey, value) {\n    this.storage[idKey] = value;\n    let start = this.ptr;\n    while (this.storage[this.ptr]) {\n      this.ptr++;\n    }\n    return this.storage.slice(start, this.ptr);\n  };\n}\n\n/**\n * Your OrderedStream object will be instantiated and called as such:\n * var obj = new OrderedStream(n)\n * var param_1 = obj.insert(idKey,value)\n */\n\nvar os = new OrderedStream(5);\nconsole.log(os.insert(3, "ccccc"));\nconsole.log(os.insert(1, "aaaaa"));\nconsole.log(os.insert(2, "bbbbb"));\nconsole.log(os.insert(5, "eeeee"));\nconsole.log(os.insert(4, "ddddd"));\n'}},function(n,e){n.exports={code179:"\n/**\n * @param {number[]} nums\n * @return {string}\n */\n\nfunction compare(a, b) {\n  // 大于0，b会放到a前面；小于0，b会放到a后面\n  a = String(a);\n  b = String(b);\n  let a1 = a + b, b1 = b + a;\n  for (let i = 0, len = a1.length; i < len; i++) {\n    let code1 = a1[i], code2 = b1[i];\n    if (code1 < code2) return 1;\n    else if (code1 > code2) return -1;\n  }\n  return 0;\n}\n\nfunction largestNumber(nums) {\n  return nums.sort(compare).join('').replaceAll(/^0+/g, '0');\n};\n\nconsole.log(largestNumber([3, 9, 30, 34, 5]));\n"}},function(n,e){n.exports={code18:'\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[][]}\n */\nfunction fourSum(nums, target) {\n  let len = nums.length, result = [];\n  if (len <= 3) return []; // 如果长度小于4肯定不存在解\n  nums.sort((a, b) => a - b);\n  // preI, preJ存储上一个循环中i, j的值，确保这次循环中i和j至少一个改变了\n  // hashTable用来去重left和right相同的结果\n  let preI, preJ, hashTable = {};\n  for (let i = 0; i < len - 3; i++) {\n    for (let j = i + 1; j < len - 2; j++) {\n      if (nums[i] !== nums[preI] || nums[j] !== nums[preJ]) {\n        [preI, preJ] = [i, j];\n        let [left, right] = [j + 1, len - 1];\n        while (left < right) {\n          if (nums[i] + nums[j] + nums[left] + nums[right] < target) left++;\n          else if (nums[i] + nums[j] + nums[left] + nums[right] > target) right--;\n          else if (nums[i] + nums[j] + nums[left] + nums[right] === target) {\n            let tmpArr = [nums[i], nums[j], nums[left], nums[right]], tmpStr = tmpArr.join(",");\n            if (hashTable[tmpStr] === undefined) {\n              result.push(tmpArr);\n              hashTable[tmpStr] = false;\n            }\n            left++;\n            right--;\n          }\n        }\n      }\n    }\n  }\n  return result;\n};\nconsole.log(fourSum([2,2,2,2,2], 8));\n'}},function(n,e){n.exports={code199:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nconst root = new BinaryTreeHelper([1, 2, 3, 4, 5]).getRoot();\n\nfunction rightSideView(root) {\n  const result = [];\n  recursion(root, 0);\n  return result;\n  function recursion(root, depth) {\n    if (root === null) return;\n    result[depth] = root.val;\n    recursion(root.left, depth + 1);\n    recursion(root.right, depth + 1);\n  }\n};\n\nconsole.log(rightSideView(root));\n"}},function(n,e){n.exports={code2042:'\n/**\n * @param {string} s\n * @return {boolean}\n */\nfunction areNumbersAscending(s) {\n  return s.match(/d+/g).every((item, index, array) => +item < +(array[index + 1] ?? Infinity));\n};\n\nconsole.log(areNumbersAscending("1 box has 1 blue 4 red 6 green and 12 yellow marbles"));\n'}},function(n,e){n.exports={code2055:'\n/**\n * @param {string} s\n * @param {number[][]} queries\n * @return {number[]}\n */\nfunction platesBetweenCandles(s, queries) {\n  let result = [];\n  queries.forEach(array => {\n    let candels = [];\n    for (let i = array[0]; i <= array[1]; i++){\n      if (s[i] === "|") candels.push(i);\n    }\n    let len = candels.length;\n    if (len <= 1) result.push(0);\n    else result.push(candels[len - 1] - candels[0] + 1 - len)\n  })\n  return result;\n};\nconsole.log(platesBetweenCandles("***|**|*****|**||**|*", [[1,17],[4,5],[14,17],[5,11],[15,16]]));\n'}},function(n,e){n.exports={code213:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\n// 最后一个偷的话，那么范围就是从[1, n - 1]\n// 最后一个不偷的话，那么范围就是从[0, n - 2]\n// 只要将这两个范围分别做一次[198.打家劫舍]那样的操作\n// 然后对比两次选最大的即可\nfunction robHelp(nums) {\n  let dp = [], len = nums.length;\n  if (len === 1) return nums[0];\n  dp.push(nums[0], Math.max(nums[0], nums[1]));\n  if (len === 2) return dp[len - 1];\n  for (let i = 2; i < len; i++) {\n    dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);\n  }\n  return dp[len - 1];\n};\n\nfunction rob(nums) {\n  let len = nums.length;\n  if (len === 1) return nums[0];\n  return Math.max(robHelp(nums.slice(0, len - 1)) ,robHelp(nums.slice(1)));\n};\n\nconsole.log(rob([1, 2, 3]));\n"}},function(n,e){n.exports={code2351:'\n/**\n * @param {string} s\n * @return {character}\n */\nfunction repeatedCharacter(s) {\n  const set = new Set();\n  for (const char of s) {\n    if (set.has(char)) return char;\n    set.add(char);\n  }\n};\n\nconsole.log(repeatedCharacter("abccbaacz"));\n'}},function(n,e){n.exports={code24:'\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n// 将链表展示\nfunction toString(head) {\n  let currentNode = head, array = [];\n  while (currentNode) {\n    array.push(currentNode.val);\n    currentNode = currentNode.next;\n  }\n  return array.join(" --\x3e ");\n}\n// 将数组转化成链表\nfunction arrayToLinkedList(array) {\n  let list = new ListNode(\'head\'), temp = list; // temp是用来防止最后得到的list是指向链表末尾\n  for (let i = 0; i < array.length; i++) {\n    temp.next = new ListNode(array[i]);\n    temp = temp.next;\n  }\n  return list.next;\n}\n/**************************以下为提交的代码**************************/\n// 官方提供的节点\nfunction ListNode(val, next) {\n  this.val = (val===undefined ? 0 : val)\n  this.next = (next===undefined ? null : next)\n}\nfunction ifExitNode(node) {\n  return node === undefined ? null : node;\n}\nfunction swapPairs(head) {\n  let afterSwap = new ListNode("head", head), temp = afterSwap;\n  let [point1, point2] = [ifExitNode(temp?.next), ifExitNode(temp?.next?.next)];\n  while (point1 && point2) {\n    // 交换节点\n    temp.next = point2;\n    point1.next = point2.next;\n    point2.next = point1;\n    // 下一轮的位置更新\n    temp = ifExitNode(temp?.next?.next);\n    point1 = ifExitNode(temp?.next);\n    point2 = ifExitNode(point1?.next);\n  }\n  return afterSwap.next;\n};\nlet list = arrayToLinkedList([]);\nconsole.log(toString(list));\nconsole.log(toString(swapPairs(list)));\n'}},function(n,e){n.exports={code25:"\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet head = new LinkedListHelper([1, 2, 3, 4, 5]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = (val === undefined ? 0 : val)\n  this.next = (next === undefined ? null : next)\n}\n\nvar reverseKGroup = function (head, k) {\n  let storage = [];\n  let currentNode = head, newHead = new ListNode(\"head\"), copyHead = newHead;\n  while (currentNode) {\n    storage.push(currentNode);\n    currentNode = currentNode.next;\n    if (storage.length === k) {\n      while (storage.length) {\n        newHead.next = storage.pop();\n        newHead = newHead.next;\n      }\n      newHead.next = null;\n      storage.length = 0;\n    }\n  }\n  storage.length && (newHead.next = storage[0]);\n  return copyHead.next;\n};\n\nlet obj = reverseKGroup(head, 3);\nLinkedListHelper.LinkedListToString(obj);\n"}},function(n,e){n.exports={code26:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction removeDuplicates(nums) {\n  let = len = nums.length;\n  if (len === 0) return [];\n  let lastElement = nums[0]; // 存储去重数组中最后一个元素\n  let cnt = 1;\n  let [slow, fast] = [0, 0];\n  while (slow <= len - 1 || fast <= len - 1) {\n    if (nums[fast] !== lastElement) {\n      slow++;\n      if (nums[slow] !== lastElement && nums[slow] !== nums[fast]) {\n        nums[cnt] = nums[slow];\n        cnt = nums[slow] === undefined ? cnt : cnt + 1;\n      }\n      nums[cnt] = nums[fast];\n      cnt = nums[fast] === undefined ? cnt : cnt + 1;\n      lastElement = nums[fast];\n    }\n    slow = fast;\n    fast = fast + 2;\n    console.log(slow, fast);\n  }\n  return cnt;\n};\nlet nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4];\nconsole.log(removeDuplicates(nums), nums);\n"}},function(n,e){n.exports={code27:"\n/**\n * @param {number[]} nums\n * @param {number} val\n * @return {number}\n */\nfunction removeElement(nums, val) {\n  let rest = cnt = 0;\n  for (let i = 0, len = nums.length; i < len; i++){\n    if (nums[i] !== val) {\n      nums[i - cnt] = nums[i];\n      rest++;\n    }\n    else {\n      cnt++;\n    }\n  }\n  return rest;\n};\nlet nums = [0, 1, 2, 2, 3, 0, 4, 2];\nconsole.log(removeElement(nums, 2), nums);\n"}},function(n,e){n.exports={code28:'\n/**\n * @param {string} haystack\n * @param {string} needle\n * @return {number}\n */\n// 暴力解法\n// function strStr(haystack, needle) {\n//   if (needle === "") return 0;\n//   let [len1, len2] = [haystack.length, needle.length];\n//   for (let i = 0; i < len1; i++){\n//     if (haystack[i] !== needle[0]) continue;\n//     else {\n//       for (var j = 0; j < len2; j++){\n//         if (needle[j] !== haystack[i + j])\n//           break;\n//       }\n//       if (j !== len2) continue;\n//       else return i\n//     }\n//   }\n//   return -1;\n// };\n// console.log(strStr("aaaaaa", "ab"));\n// KMP\n/*\n  next数组:\n  1. left = next[left - 1]; 循环,不相等\n  2. next[i] = 0; left === 0,不相等,right++\n  3. next[i] = left + 1; 相等,left++,right++\n*/\nfunction strStr(haystack, needle) {\n  if (needle === "") return 0;\n  let [len1, len2] = [haystack.length, needle.length];\n  let next = [0] // next数组\n  // 更新next数组\n  for (let left = 0, right = 1; right < len2; right++){\n    while (left > 0 && needle[left] !== needle[right]) left = next[left - 1];\n    if (needle[left] === needle[right]) {\n      next[right] = left + 1;\n      left++;\n    }\n    else if (left === 0 && needle[left] !== needle[right]) {\n      next[right] = 0;\n    }\n  }\n  console.log(next);\n  // 字符匹配\n  for (let left = 0, right = 0; right < len1; right++){\n    while (left > 0 && needle[left] !== haystack[right]) left = next[left - 1];\n    if (needle[left] === haystack[right]) left++;\n    if (left === len2) return right - len2 + 1;\n  }\n  return -1;\n}\nconsole.log(strStr("abcabdabcabc", "abcabc"));\n'}},function(n,e){n.exports={code29:'\n/**\n * @param {number} dividend\n * @param {number} divisor\n * @return {number}\n */\n// 快速乘\nfunction fastMultiple(num1, num2) {\n  let result = 0;\n  while (num2) {\n    if (num2 & 1) result += num1;\n    num1 *= 2;\n    num2 = ~~(num2 / 2);\n  }\n  return result;\n}\nfunction findMinUpperBound(num1, num2) {\n  let result = 0;\n  while (num1 > num2 * (1 << result)) result++;\n  return result;\n}\nfunction divide(dividend, divisor) {\n  if (dividend === 0) return 0;\n  if (divisor === 1) return dividend > 2147483647 ? 2147483647 : dividend;\n  if (divisor === -1) return -dividend > 2147483647 ? 2147483647 : -dividend;\n  let flag;\n  if (dividend > 0 && divisor > 0 || dividend < 0 && divisor < 0) flag = 1;\n  else flag = -1;\n  [dividend, divisor] = [Math.abs(dividend), Math.abs(divisor)];\n  // 首先找到最小的上界\n  let bound = findMinUpperBound(dividend, divisor);\n  let [left, right] = [(bound - 1) < 0 ? 0 : 1 << (bound - 1), 1 << bound];\n  let mid = Math.floor((left + right) / 2);\n  // console.log("dividend:", dividend, "left: ", left, "right: ", right);\n  while (left <= right) {\n    let tmp = fastMultiple(mid, divisor);\n    if (tmp < dividend) left = mid + 1;\n    else if (tmp > dividend) right = mid - 1;\n    else break;\n    mid = Math.floor((left + right) / 2);\n  }\n  return mid * flag;\n};\nconsole.log(divide(-2147483648, -1));\n'}},function(n,e){n.exports={code300:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction lengthOfLIS(nums) {\n  let result = 1, dp = [];\n  for (let i = 0, len = nums.length; i < len; i++) {\n    let temp = nums[i], max = 0;\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < temp) max = Math.max(dp[j], max);\n    }\n    dp[i] = max + 1;\n    result = Math.max(result, dp[i]);\n  }\n  return result;\n};\n\nconsole.log(lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]));\n"}},function(n,e){n.exports={code342:"\n/**\n * @param {number} n\n * @return {boolean}\n */\n\nfunction isPowerOfFour(n) {\n  n = +n;\n  return (n & (n - 1)) === 0 && n % 3 === 1;\n};\n\nconsole.log(isPowerOfFour(15));\n"}},function(n,e){n.exports={code35:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\n// 二分查找\nfunction searchInsert(nums, target) {\n  let left = 0, right = nums.length - 1, currentIdx = Math.ceil(left + right);\n  while (left <= right) {\n    currentIdx = Math.ceil((left + right) / 2);\n    if (nums[currentIdx] > target) right = currentIdx - 1;\n    else if (nums[currentIdx] < target) left = currentIdx + 1;\n    else return currentIdx;\n  }\n  return left;\n};\nconsole.log(searchInsert([-1, 3, 5, 6, 8, 9], 10));\n"}},function(n,e){n.exports={code36:'\n/**\n * @param {character[][]} board\n * @return {boolean}\n */\nfunction addNumber(map, key, item) {\n  let temp = null;\n  temp = map.get(key);\n  if (temp) {\n    if (temp.includes(item)) return false;\n    temp.push(item);\n  } else {\n    map.set(key, [item]);\n  }\n  return true;\n}\n\nfunction isValidSudoku(board) {\n  const rowMap = new Map(), columnMap = new Map(), cellMap = new Map();\n  for (let i = 0, row = board.length; i < row; i++) {\n    for (let j = 0, column = board[0].length; j < column; j++) {\n      const item = board[i][j];\n      if (item === ".") continue;\n      if (!(addNumber(rowMap, i, item) && addNumber(columnMap, j, item) && addNumber(cellMap, 3 * Math.floor(i / 3) + Math.ceil((j + 1) / 3), item))) {\n        console.log(i, j);\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconsole.log(isValidSudoku([\n  [".", ".", "5", ".", ".", ".", ".", ".", "6"],\n  [".", ".", ".", ".", "1", "4", ".", ".", "."],\n  [".", ".", ".", ".", ".", ".", ".", ".", "."],\n  [".", ".", ".", ".", ".", "9", "2", ".", "."],\n  ["5", ".", ".", ".", ".", "2", ".", ".", "."],\n  [".", ".", ".", ".", ".", ".", ".", "3", "."],\n  [".", ".", ".", "5", "4", ".", ".", ".", "."],\n  ["3", ".", ".", ".", ".", ".", "4", "2", "."],\n  [".", ".", ".", "2", "7", ".", "6", ".", "."]]\n));\n'}},function(n,e){throw new Error("Module build failed (from ./node_modules/babel-loader/lib/index.js):\nSyntaxError: /Users/karl/Documents/vuePress/leetcode/docs/.vuepress/public/leetcode/else/38.外观数列.js: Invalid escape sequence in template. (1:17)\n\n[0m[31m[1m>[22m[39m[90m 1 |[39m [36mconst[39m code38 [33m=[39m [32m`[39m[0m\n[0m [90m   |[39m                  [31m[1m^[22m[39m[0m\n[0m [90m 2 |[39m [32m/**[39m[0m\n[0m [90m 3 |[39m [32m * @param {number} n[39m[0m\n[0m [90m 4 |[39m [32m * @return {string}[39m[0m\n    at instantiate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:72:32)\n    at constructor (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:359:12)\n    at Parser.raise (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:3339:19)\n    at Parser.parseTemplateElement (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13539:14)\n    at Parser.parseTemplate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13562:23)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13017:21)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:8039:20)\n    at Parser.parseExprSubscripts (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12648:23)\n    at Parser.parseUpdate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12627:21)\n    at Parser.parseMaybeUnary (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12598:23)\n    at Parser.parseMaybeUnaryOrPrivate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12392:61)\n    at Parser.parseExprOps (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12399:23)\n    at Parser.parseMaybeConditional (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12369:23)\n    at Parser.parseMaybeAssign (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12321:21)\n    at /Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12279:39\n    at Parser.allowInAnd (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:14346:16)")},function(n,e){n.exports={code415:'\n/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar addStrings = function (num1, num2) {\n  let carry = 0, str = "", temp;\n  let p1 = num1.length - 1, p2 = num2.length - 1;\n  while (p1 >= 0 || p2 >= 0) {\n    temp = +(num1[p1] ?? 0) + +(num2[p2] ?? 0) + carry;\n    str = (temp % 10) + str;\n    carry = Math.floor(temp / 10);\n    p1--;\n    p2--;\n  }\n  return (carry ? carry : "") + str;\n};\n\nconsole.log(addStrings("999", "9999"));\nconsole.log(addStrings("9999", "999"));\nconsole.log(addStrings("0", "0"));\nconsole.log(addStrings("456", "77"));\nconsole.log(addStrings("11", "123"));\n'}},function(n,e){n.exports={code43:'\n/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\n\nfunction subMultiply(num1, num2, k) {\n  if (num1 === "0" || num2 === "0") return "0";\n  let carry = 0, str = "";\n  for (let i = num1.length - 1; i >= 0; i--) {\n    let res = num1[i] * num2 + carry;\n    str = (res % 10) + str;\n    carry = Math.floor(res / 10);\n  }\n  return (!carry ? "" : carry) + str + "0".repeat(k);\n}\n\nfunction subAdd(num1, num2) {\n  let p1 = num1.length - 1, p2 = num2.length - 1, carry = 0, str = "";\n  while (p1 >= 0 || p2 >= 0) {\n    let res = +(num1[p1--] ?? 0) + +(num2[p2--] ?? 0) + carry;\n    str = (res % 10) + str;\n    carry = Math.floor(res / 10);\n  }\n  return (!carry ? "" : carry) + str;\n}\n\nfunction multiply(num1, num2) {\n  let str = "0", cnt = 0;\n  while (num2) {\n    let res = subMultiply(num1, num2[num2.length - 1], cnt++);\n    console.log(res, str);\n    str = subAdd(res, str);\n    num2 = num2.slice(0, -1);\n  }\n  return str;\n};\n\nconsole.log(multiply("123456789", "987654321"));\n'}},function(n,e){n.exports={code47:"\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\n\nfunction permuteUnique(nums) {\n  const result = [], path = [], len = nums.length, idx = [], set = new Set();\n  recursion();\n  return result;\n  function recursion() {\n    if (path.length === len) {\n      const str = path.join();\n      if (!set.has(str)) {\n        result.push([...path]);\n        set.add(str);\n      }\n      return;\n    }\n\n    for (let i = 0; i < len; i++) {\n      if (idx.includes(i)) continue;\n      idx.push(i);\n      path.push(nums[i]);\n      recursion();\n      path.pop();\n      idx.pop();\n    }\n  }\n};\n\nconsole.log(permuteUnique([1, 1, 2]));\n"}},function(n,e){n.exports={code50:"\n/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nfunction fastPow(x, n) {\n  let result = 1;\n  while (n) {\n    console.log(n);\n    if (n & 1) result *= x;\n    x *= x;\n    n = ~(n >> 1);\n  }\n  return result;\n}\nfunction myPow(x, n) {\n  if (x === 0) return 0;\n  else if (x === 1) return 1;\n  else if (x === -1) return ((n & 1) === 1 ? -1 : 1);\n  if (n === 0) return 1;\n  return n > 0 ? fastPow(x, n) : 1 / fastPow(x, -n);\n};\nconsole.log(myPow(2, -2147483648));\n\n// 防君子不防小人\nfunction myPow(x, n) {\n  return n > 0 ? Math.pow(x, n) : 1 / Math.pow(x, -n);\n};\n"}},function(n,e){n.exports={code504:'\n/**\n * @param {number} num\n * @return {string}\n */\nfunction convertToBase7(num) {\n  if (num === 0) return "0";\n  let stack = []; // 栈\n  let flag = num >= 0 ? "" : "-";\n  num = Math.abs(num);\n  while (num) {\n    stack.push(num % 7);\n    num = Math.floor(num / 7);\n  }\n  return flag + stack.reverse().join("");\n};\nconsole.log(convertToBase7(0));\n'}},function(n,e){n.exports={code54:"\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\n\nfunction spiralOrder(matrix) {\n  const row = matrix.length, column = matrix[0].length, all = row * column;\n  const temp = { // 上 下 左 右\n    'up': 0,\n    'down': row,\n    'left': -1,\n    'right': column\n  }\n  const result = [];\n  let direction = 'right', i = 0, j = 0;\n  while (result.length < all) {\n    result.push(matrix[i][j]);\n    const max = temp[direction];\n    switch (direction) {\n      case 'right':\n        if (j + 1 < max) j++;\n        else {\n          direction = 'down';\n          temp['right']--;\n          i++;\n        }\n        break;\n      case 'down':\n        if (i + 1 < max) i++;\n        else {\n          direction = 'left';\n          temp['down']--;\n          j--;\n        }\n        break;\n      case 'left':\n        if (j - 1 > max) j--;\n        else {\n          direction = 'up';\n          temp['left']++;\n          i--;\n        }\n        break;\n      case 'up':\n        if (i - 1 > max) i--;\n        else {\n          direction = 'right';\n          temp['up']++;\n          j++;\n        }\n        break;\n    }\n  }\n  return result;\n};\n\nconsole.log(spiralOrder([[1, 2]]));\n"}},function(n,e){n.exports={code57:"\n/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nfunction merge(intervals) {\n  let result = []\n  intervals.forEach((item, index) => {\n    if (index === 0) {\n      result.push(item);\n    }\n    else {\n      let lastElement = result[result.length - 1];\n      if (item[0] <= lastElement[1]) {\n        if (item[1] > lastElement[1]) lastElement[1] = item[1];\n      }\n      else result.push(item);\n    }\n  });\n  return result;\n};\nfunction findInsertIndex(intervals, newInterval) {\n  let [left, right, target] = [0, intervals.length - 1, newInterval[0]];\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2);\n    if (intervals[mid][0] >= target) right = mid;\n    else left = mid + 1\n  }\n  return right;\n}\nfunction insert(intervals, newInterval) {\n  if (intervals.length === 0) return [newInterval];\n  // 先二分找到插入点\n  let insetIndex = findInsertIndex(intervals, newInterval);\n  if (newInterval[0] > intervals[insetIndex][0]) intervals.splice(insetIndex + 1, 0, newInterval);\n  else intervals.splice(insetIndex, 0, newInterval);\n  // 将插入点之后的合并\n  return merge(intervals);\n};\nconsole.log(insert(intervals = [], newInterval = [5, 7]));\n"}},function(n,e){n.exports={code58:'\n/**\n * @param {string} s\n * @return {number}\n */\nfunction lengthOfLastWord(s) {\n  return s.trim().split(" ").slice(-1)[0].length;\n};\nconsole.log(lengthOfLastWord(s = "Hello World"));\n'}},function(n,e){n.exports={code59:'\n/**\n * @param {number} n\n * @return {number[][]}\n */\nfunction generateMatrix(n) {\n  if (n === 1) return [[1]];\n  const arr = [], all = n * n;\n  let cnt = 1, currentSide = 0, currentSideNum = n - 1;\n  for (let i = 0; i < n; i++) arr.push(new Array(n));\n  while (cnt <= all) {\n    for (let j = 0; j < currentSideNum; j++) {\n      const temp1 = currentSide % 4,\n        temp2 = Math.floor(currentSide / 4),\n        temp3 = n - Math.ceil(currentSide / 4);\n      switch (temp1) {\n        case 0: arr[temp2][j + temp2] = cnt++; break;\n        case 1: arr[j + temp2][temp3] = cnt++; break;\n        case 2: arr[temp3][temp3 - j] = cnt++; break;\n        case 3: arr[temp3 - j][temp2] = cnt++; break;\n        default: break;\n      }\n    }\n    !(++currentSide % 4) && (currentSideNum = currentSideNum - 2 > 0 ? currentSideNum - 2 : 1);\n  }\n  return arr;\n};\n\nfunction logArray(arr) {\n  let str = "";\n  arr.forEach(row => str += row.join(" ") + "\n");\n  console.log(str);\n}\n\nlogArray(generateMatrix(7));\n'}},function(n,e){n.exports={code6:'\n/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nfunction convert(s, numRows) {\n  if (numRows === 1) return s;\n  let arr = [];\n  let currentRow = 0, currentColumn = 0, directionFlag = "down"; // directionFlag确定了更新的方向\n  // 初始化arr数组\n  for (let i = 0; i < numRows; i++) arr.push([]);\n  // Z字变换\n  for (let i = 0, len = s.length; i < len; i++) {\n    arr[currentRow][currentColumn] = s[i];\n    if (directionFlag === "down") {\n      if (currentRow !== numRows - 1) {\n        currentRow++;\n      }\n      else {\n        directionFlag = "up";\n        currentRow--;\n        currentColumn++;\n      }\n    }\n    else if (directionFlag === "up") {\n      if (currentRow !== 0) {\n        currentRow--;\n        currentColumn++;\n      }\n      else {\n        directionFlag = "down";\n        currentRow++;\n      }\n    }\n  }\n  // 打印变换后的字符串\n  let str = "";\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr[i].length; j++) {\n      if (arr[i][j] !== undefined) {\n        str += arr[i][j];\n      }\n    }\n  }\n  return str;\n};\nconsole.log(convert(\'ABCD\', 2));\n'}},function(n,e){n.exports={code636:'\n/**\n * @param {number} n\n * @param {string[]} logs\n * @return {number[]}\n */\n\n// 没有通过\nfunction formatOpt(opts) {\n  return { id: opts[0], [opts[1]]: opts[2] };\n}\n\nfunction exclusiveTime(n, logs) {\n  const result = new Array(n).fill(n), stack = [];\n  logs.forEach(item => { \n    const opts = item.split(":");\n    if (opts[1] === "start") {\n      const top = stack[stack.length - 1];\n      top ?? stack.push(formatOpt(opts));\n      \n    }\n  });\n\n};\n\nconsole.log(exclusiveTime(2, ["0:start:0", "0:start:2", "0:end:5", "1:start:7", "1:end:7", "0:end:8"]));\n'}},function(n,e){n.exports={code646:"\n/**\n * @param {number[][]} pairs\n * @return {number}\n */\n\nfunction findLongestChain(pairs) {\n  let curr = Number.MIN_SAFE_INTEGER, result = 0;\n  pairs = pairs.sort((a, b) => a[1] - b[1]);\n  for (let item of pairs) {\n    if (curr < item[0]) {\n      curr = item[1];\n      result++;\n    }\n  }\n  return result\n};\n\nconsole.log(findLongestChain([[1, 10], [3, 4], [2, 3]]));\n"}},function(n,e){n.exports={code654:"\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\n\nfunction TreeNode(val, left, right) {\n  this.val = (val === undefined ? 0 : val)\n  this.left = (left === undefined ? null : left)\n  this.right = (right === undefined ? null : right)\n}\n\nfunction findMax(array) {\n  let idx = -1, max = Number.MIN_SAFE_INTEGER;\n  array.forEach((item, index) => {\n    if (item > max) {\n      max = item;\n      idx = index;\n    }\n  });\n  return {\n    idx,\n    max\n  }\n}\n\nfunction constructMaximumBinaryTree(nums) {\n  if (!nums.length) return null;\n  const { idx, max } = findMax(nums);\n  let node = new TreeNode(max);\n  node.left = constructMaximumBinaryTree(nums.slice(0, idx));\n  node.right = constructMaximumBinaryTree(nums.slice(idx + 1));\n  return node;\n};\n\nconst root = constructMaximumBinaryTree([3, 2, 1, 6, 0, 5]);\nBinaryTreeHelper.LogMyTree(root);\n"}},function(n,e){n.exports={code655:'\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string[][]}\n */\n\nimport { BinaryTreeHelper } from \'@karl_fang/data-structure\';\nlet root = new BinaryTreeHelper([1, 2, 3, null, 4]).getRoot();\n\nfunction calcDepth(root) {\n  if (root === null) return 0;\n  return Math.max(calcDepth(root.left), calcDepth(root.right)) + 1;\n}\n\nfunction initArray(depth) {\n  return [...new Array(depth).keys()].map(() => new Array(2 ** depth - 1).fill(""));\n}\n\nfunction printTree(root) {\n  const height = calcDepth(root) - 1;\n  const result = initArray(height + 1);\n  const temp = (2 ** (height + 1) - 2) >> 1;\n  result[0][temp] = "" + root.val;\n  recursion(root.left, 0, temp, "left");\n  recursion(root.right, 0, temp, "right");\n  return result;\n  function recursion(root, r, c, pos) {\n    if (root === null) return;\n    let temp = 2 ** (height - r - 1);\n    let x = r + 1, y;\n    pos === "left" && (y = c - temp);\n    pos === "right" && (y = c + temp);\n    result[x][y] = "" + root.val;\n    recursion(root.left, x, y, "left");\n    recursion(root.right, x, y, "right");\n  }\n};\n\nconsole.log(printTree(root));\n'}},function(n,e){n.exports={code66:"\n/**\n * @param {number[]} digits\n * @return {number[]}\n */\n\nfunction plusOne(digits) {\n  let carry = 1, idx = digits.length - 1;\n  do {\n    if (carry + digits[idx] === 10) {\n      carry = 1;\n      digits[idx] = 0;\n    }\n    else {\n      digits[idx]++;\n      carry = 0;\n    }\n    idx--;\n  } while (carry !== 0 && idx >= 0);\n  carry === 1 && digits.unshift(1);\n  return digits;\n};\n\nconsole.log(plusOne([9, 9, 9]));\n"}},function(n,e){n.exports={code662:"\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([0, null, 0, null, null, 1, 2, null, null, null, null, 3, 4, 5, 6]).getRoot();\n\nfunction widthOfBinaryTree(root) {\n  let queue = [[root, 1n]], result = 1;\n  while (queue.length) {\n    let temp = queue.at(-1)[1] - queue[0][1] + 1n;\n    result = temp > result ? temp : result;\n    for (let i = 0, len = queue.length; i < len; i++) {\n      let node = queue.shift();\n      if (node !== null) {\n        node[0]?.left && queue.push([node[0].left, node[1] * 2n]);\n        node[0]?.right && queue.push([node[0].right, node[1] * 2n + 1n]);\n      }\n    }\n    \n  }\n  return result;\n};\n\nconsole.log(widthOfBinaryTree(root));\n"}},function(n,e){n.exports={code67:'\n/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\n\n// 直接计算\nfunction calc(a, b, precarry) {\n  let res = 0, carry = 0;\n  const num1 = Number.parseInt(a), num2 = Number.parseInt(b), num3 = Number.parseInt(precarry);\n  res = num1 ^ num2 ^ num3;\n  carry = (num1 + num2 + num3) >> 1;\n  return { res, carry };\n}\n\nfunction addBinary(a, b) {\n  a = a.split(""), b = b.split("");\n  let preCarry = 0, len1 = a.length, len2 = b.length;\n  if (len1 < len2) a = [...new Array(len2 - len1).fill("0"), ...a];\n  else if (len1 > len2) b = [...new Array(len1 - len2).fill("0"), ...b];\n  for (let i = a.length - 1; i >= 0; i--) {\n    const { res, carry } = calc(a[i], b[i], preCarry);\n    preCarry = carry;\n    a[i] = res;\n  }\n  return (preCarry ? "1" : \'\') + a.join("");\n};\n\n// 用内置函数, 会报错\nfunction addBinary(a, b) {\n  return (Number.parseInt(a, 2) + Number.parseInt(b, 2)).toString(2);\n}\n\nconsole.log(addBinary("1010", "1011"));\n'}},function(n,e){n.exports={code69:"\n/**\n * @param {number} x\n * @return {number}\n */\n\nfunction mySqrt(x) {\n  const EPSILON = 1e-6\n  let temp1 = Math.E ** (Math.log(x) / 2), temp2 = Math.ceil(temp1);\n  return temp2 - temp1 < EPSILON ? temp2 : Math.floor(temp1);\n};\n\nfunction mySqrt(x) {\n  let left = 0, right = x === 1 ? 1 : Math.floor(x / 2), mid;\n  while (left < right) {\n    mid = Math.ceil((left + right) / 2);\n    if (mid * mid <= x) left = mid;\n    else right = mid - 1;  \n  }\n  return left;\n};\n\nconsole.log(mySqrt(16));\n"}},function(n,e){n.exports={code695:"\n/**\n * @param {number[][]} grid\n * @return {number}\n */\n\nfunction maxAreaOfIsland(grid) {\n  const row = grid.length, column = grid[0].length;\n  const map = genMap(row, column);\n  let result = 0, currentNum = 0;\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      if (grid[i][j] === 0) continue;\n      let res = walk(i, j);\n      if (res) {\n        result = Math.max(result, currentNum);\n        currentNum = 0;\n      }\n    }\n  }\n  return result;\n\n  function genMap(row, column) {\n    const result = [];\n    for (let i = 0; i < row; i++) {\n      result.push(new Array(column).fill(false));\n    }\n    return result;\n  }\n\n  function ifExit(i, j) {\n    return (grid[i] ?? false) && (grid[i][j] ?? false) && true;\n  }\n\n  function walk(i, j) {\n    if (!ifExit(i, j) || map[i][j] || !grid[i][j]) return false;\n    map[i][j] = true;\n    currentNum++;\n    walk(i - 1, j);\n    walk(i + 1, j);\n    walk(i, j - 1);\n    walk(i, j + 1);\n    return true;\n  }\n};\n\nconsole.log(maxAreaOfIsland([[0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]]));\n"}},function(n,e){n.exports={code7:"\n/**\n * @param {number} x\n * @return {number}\n */\nfunction reverse(x) {\n  const MAX = Math.pow(2, 31) - 1;\n  const MIN = -Math.pow(2, 31);\n  let flag = x >= 0 ? 1 : -1;\n  x = Math.abs(x), sum = 0;\n  while (x) {\n    sum *= 10;\n    sum += x % 10;\n    x = Math.floor(x / 10);\n  }\n  if (sum >= MIN && sum <= MAX) return sum * flag;\n  else return 0;\n};\nconsole.log(reverse(-123));\n"}},function(n,e){n.exports={code704:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\n\nvar search = function (nums, target) {\n  let left = 0, right = nums.length - 1, mid;\n  while (left < right) {\n    mid = Math.floor((left + right) / 2);\n    if (nums[mid] >= target) right = mid;\n    else left = mid + 1;\n  }\n  return nums[left] === target ? left : -1;\n};\n\nconsole.log(search([-1, 0, 3, 5, 9, 12], 2));\n"}},function(n,e){n.exports={code74:"\n/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\n\nfunction transfer(idx, column) {\n  return [Math.floor(idx / column), idx % column];\n}\n\nvar searchMatrix = function (matrix, target) {\n  let row = matrix.length, column = matrix[0].length;\n  let left = 0, right = row * column - 1;\n  while (left < right) {\n    let mid = Math.floor((left + right) / 2);\n    let [i, j] = transfer(mid, column);\n    if (matrix[i][j] >= target) right = mid;\n    else left = mid + 1;\n  }\n  let [i, j] = transfer(left, column);\n  return matrix[i][j] === target\n};\n\nconsole.log(searchMatrix([[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], 4));\n"}},function(n,e){n.exports={code8:'\n/**\n * @param {string} s\n * @return {number}\n */\nfunction myAtoi(s) {\n  const MAX = Math.pow(2, 31) - 1;\n  const MIN = -Math.pow(2, 31);\n  let flag = 1, sum = 0, ifHasSigned = false;\n  s = s.trim();\n  for (let i = 0, len = s.length; i < len; i++){\n    let ascii = s[i].charCodeAt();\n    // 如果是数字0-9\n    if (ascii === 43 && ifHasSigned === false) {\n      flag = 1;\n      ifHasSigned = true;\n    }\n    else if (ascii === 45 && ifHasSigned === false) {\n      flag = -1;\n      ifHasSigned = true;\n    }\n    else if (ifHasSigned = true && ascii >= 48 && ascii <= 57) sum = sum * 10 + (ascii - 48);\n    else break;\n  }\n  sum *= flag \n  if (sum >= MIN && sum <= MAX) return sum;\n  else if (sum > MAX) return MAX;\n  else if (sum < MIN) return MIN;\n};\nconsole.log(myAtoi("21474836460"));\n'}},function(n,e){n.exports={code863:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} target\n * @param {number} k\n * @return {number[]}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]).getRoot();\n\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left ?? null;\n  this.right = right ?? null;\n}\n\nfunction distanceK(root, target, k) {\n  if (k === 0) return [target.val];\n  let map = new Map(), result = [];\n  let currentNode = null, beforeParentVal = -1;\n  recursion(root, null);\n  while (currentNode && k >= 0) {\n    let temp = currentNode.val;\n    get(currentNode, 0, k);\n    currentNode = map.get(temp);\n    beforeParentVal = temp;\n    k = k - 1;\n  }\n  return result;\n  function recursion(root, parent) {\n    if (root === null) return;\n    if (root.val === target.val) currentNode = root;\n    map.set(root.val, parent);\n    recursion(root.left, root);\n    recursion(root.right, root);\n  }\n  function get(root, depth, k) {\n    if (root === null || root.val === beforeParentVal) return;\n    if (depth === k) {\n      result.push(root.val);\n      return;\n    }\n    get(root.left, depth + 1, k);\n    get(root.right, depth + 1, k);\n  }\n};\n\nlet node = new TreeNode(7);\nconsole.log(distanceK(root, node, 3));\n"}},function(n,e){n.exports={code88:"\n/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\n\nfunction merge(nums1, m, nums2, n) {\n  let p1 = 0, p2 = 0, copynums1 = nums1.slice();\n  nums1.length = 0;\n  while (p1 < m && p2 < n) {\n    const temp1 = copynums1[p1], temp2 = nums2[p2];\n    if (temp1 <= temp2) {\n      nums1.push(temp1);\n      p1++;\n    }\n    if(temp1 > temp2) {\n      nums1.push(temp2);\n      p2++;\n    }\n  }\n  p1 < m ? nums1.push(...copynums1.slice(p1, m)) : nums1.push(...nums2.slice(p2, n));\n  return nums1;\n};\n\nconsole.log(merge([1, 2, 3, 7, 0, 0, 0], 4, [2, 5, 6], 3));\n"}},function(n,e){n.exports={code9:'\n/**\n * @param {number} x\n * @return {boolean}\n */\nfunction isPalindrome(x) {\n  return (x + "").split("").reverse().join("") === (x + "");\n};\nconsole.log(isPalindrome(-123));\n'}},function(n,e){n.exports={code912:"\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n\nfunction sortArray(nums) {\n  quickSort(0, nums.length - 1);\n  return nums;\n  function quickSort(left, right) {\n    if (left > right) return;\n    let partition = nums[left];\n    const [copyLeft, copyRight] = [left, right];\n    while (left < right) {\n      while (left < right && nums[right] >= partition) right--;\n      while (left < right && nums[left] <= partition) left++;\n      [nums[left], nums[right]] = [nums[right], nums[left]];\n    }\n    [nums[copyLeft], nums[left]] = [nums[left], nums[copyLeft]];\n    quickSort(copyLeft, left - 1);\n    quickSort(left + 1, copyRight);\n  }\n};\n\nconsole.log(sortArray([5, 1, 1, 2, 0, 0]));\n"}},function(n,e){n.exports={code92:"\n/**\n * @param {ListNode} head\n * @param {number} left\n * @param {number} right\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet head = new LinkedListHelper([1, 2, 3, 4, 5]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = (val === undefined ? 0 : val)\n  this.next = (next === undefined ? null : next)\n}\n\nfunction reverseBetween(head, left, right) {\n  let stack = [], start = null, end = null;\n  let newHead = new ListNode('head', head), copyHead = newHead, cnt = 0;\n  while (copyHead) {\n    if (cnt === left - 1) start = copyHead;\n    else if (cnt === right + 1) end = copyHead;\n    else if (cnt >= left && cnt <= right) stack.push(copyHead);\n    copyHead = copyHead.next;\n    cnt++;\n  }\n  while (stack.length) {\n    start.next = stack.pop();\n    start = start.next;\n  }\n  start.next = end;\n  return newHead.next;\n};\n\nhead = reverseBetween(head, 1, 5);\nLinkedListHelper.LinkedListToString(head);\n"}},function(n,e){n.exports={code93:'\nfunction getCombinations(target) {\n  let result = [], path = [], list = [1, 2, 3];\n  backTracking();\n  return result;\n\n  function backTracking() {\n    if (path.length === 4) {\n      if (path.reduce((pre, curr) => pre += curr, 0) === target) {\n        let temp = [path[0]];\n        for (let i = 1; i < 4; i++) temp[i] = path[i] + temp[i - 1];\n        result.push(temp);\n      }\n      return;\n    }\n\n    for (let i = 0; i < 3; i++) {\n      path.push(list[i]);\n      backTracking();\n      path.pop();\n    }\n  }\n}\n\n// 获取分割字符串的方式\nfunction getSplitMethods() {\n  let map = new Map();\n  for (let i = 4; i <= 12; i++) map.set(i, getCombinations(i));\n  return map;\n}\n\nconst map = getSplitMethods();\n/*********************************************************************/\nfunction ifValid(str) {\n  let integer = Number.parseInt(str);\n  return integer >= 0 && integer <= 255 && (integer + "").length === str.length;\n}\n\n/**\n * @param {string} s\n * @return {string[]}\n */\nfunction restoreIpAddresses(str) {\n  let len = str.length;\n  if (len < 4 || len > 12) return [];\n  let result = [];\n  map.get(len).forEach(method => {\n    const ip1 = str.slice(0, method[0]),\n      ip2 = str.slice(method[0], method[1]),\n      ip3 = str.slice(method[1], method[2]),\n      ip4 = str.slice(method[2], method[3]);\n    if (ifValid(ip1) && ifValid(ip2) && ifValid(ip3) && ifValid(ip4)) result.push(`${ip1}.${ip2}.${ip3}.${ip4}`);\n  });\n  return result;\n}\n\nconsole.log(restoreIpAddresses("25525511135"));\nconsole.log(restoreIpAddresses("11101"));\nconsole.log(restoreIpAddresses("0"));\n'}},function(n,e){n.exports={codeOffer10_1:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction fib(n) {\n  let result = [0, 1];\n  if (n <= 1) return result[n];\n  for (let i = 2; i <= n; i++) {\n    result[i] = BigInt(result[i - 1]) + BigInt(result[i - 2]);\n  }\n  const temp = result[n];\n  return temp < (1e9 + 7) ? temp : temp % BigInt(1e9 + 7);\n};\n\nconsole.log(fib(81));\n"}},function(n,e){n.exports={codeOffer10_2:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction format(n) {\n  return n % (1e9 + 7);\n}\n\nfunction numWays(n) {\n  let result = [1, 1, 2];\n  for (let i = 3; i <= n; i++) {\n    result[i] = format(result[i - 1] + result[i - 2]);\n  }\n  return result[n];\n};\n\nconsole.log(numWays(44));\n"}},function(n,e){n.exports={codeOffer11:"\n/**\n * @param {number[]} numbers\n * @return {number}\n */\n\nfunction minArray(numbers) {\n  return Math.min(...numbers);\n};\n\nconsole.log(minArray([1, 2, 3, 4, 5, 6]));\n"}},function(n,e){n.exports={codeOffer12:'\n/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\n\nfunction initMap(row, column) {\n  let array = [];\n  for (let i = 0; i < row; i++) array[i] = new Array(column).fill(false);\n  return array;\n}\n\nfunction judge(board, i, j) {\n  return (board[i] ?? false) && (board[i][j] ?? false) && true;\n}\n\nfunction exist(board, word) {\n  const row = board.length, column = board[0].length;\n  let map = initMap(row, column);\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      if (board[i][j] !== word[0]) continue;\n      let temp = backTracking(i, j, 0);\n      if (temp) return true;\n    }\n  }\n  return false;\n\n  function backTracking(i, j, n) {\n    if (!judge(board, i, j) || map[i][j] || board[i][j] !== word[n]) return false;\n    if (n === word.length - 1) return true;\n    map[i][j] = true;\n    const res = backTracking(i - 1, j, n + 1) || backTracking(i, j - 1, n + 1) ||\n      backTracking(i + 1, j, n + 1) || backTracking(i, j + 1, n + 1);\n    map[i][j] = false;\n    return res;\n  }\n};\n\nconsole.log(exist([["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], "ABCCEDFE"));\n'}},function(n,e){n.exports={codeOffer14_1:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction cuttingRope(n) {\n  let dp = new Array(n + 1).fill(0);\n  dp[1] = dp[2] = 1;\n  for (let i = 2; i <= n; i++) {\n    for (let j = 0, len = Math.floor(i >> 1); j <= len; j++) {\n      let temp1 = dp[j] < j ? j : dp[j], idx = i - j;\n      let temp2 = dp[idx] < idx ? idx : dp[idx];\n      let res = temp1 * temp2;\n      dp[i] = res > dp[i] ? res : dp[i];\n    }\n  }\n  return dp[n];\n};\n\nconsole.log(cuttingRope(8));\n"}},function(n,e){n.exports={codeOffer14_2:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction cuttingRope(n) {\n  let dp = new Array(n + 1).fill(BigInt(0));\n  dp[1] = dp[2] = 1n;\n  for (let i = 2; i <= n; i++) {\n    for (let j = 0, len = Math.floor(i >> 1); j <= len; j++) {\n      const copyI = BigInt(i), copyJ = BigInt(j);\n      let temp1 = dp[copyJ] < copyJ ? copyJ : dp[j], idx = copyI - copyJ;\n      let temp2 = dp[idx] < idx ? idx : dp[idx];\n      let res = temp1 * temp2;\n      dp[i] = res > dp[i] ? res : dp[i];\n    }\n  }\n  return dp[n] % BigInt(1e9 + 7);\n};\n\nconsole.log(cuttingRope(8));\n"}},function(n,e){n.exports={codeOffer15:"\n/**\n * @param {number} n - a positive integer\n * @return {number}\n */\n\nfunction hammingWeight(n) {\n  let result = 0;\n  while (n) {\n    n = n & (n - 1);\n    result++;\n  }\n  return result;\n};\n\nconsole.log(hammingWeight(4294967293));\n"}},function(n,e){n.exports={codeOffer16:"\n/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\n\nfunction calc(x, n) {\n  let result = 1;\n  while (n) {\n    if (n & 1) result *= x;\n    x *= x;\n    n = Math.abs(n >> 1);\n  }\n  return result;\n}\n\nfunction myPow(x, n) {\n  if (x === 0) return 0;\n  else if (x === 1) return 1;\n  else if (x === -1) return ((n & 1) === 1 ? -1 : 1);\n  if (n === 0) return 1;\n  return n < 0 ? 1 / calc(x, -n) : calc(x, n);\n};\n\nconsole.log(myPow(2, -2147483648));\n"}},function(n,e){n.exports={codeOffer18:"\n/**\n * @param {ListNode} head\n * @param {number} val\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet head1 = new LinkedListHelper([4, 5, 1, 9]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = val;\n  this.next = next === undefined ? null : next;\n}\n\nfunction deleteNode(head, val) {\n  let newHead = new ListNode(\"head\", head), curr = newHead;\n  while (curr) {\n    if (curr.next.val === val) {\n      curr.next = curr.next.next;\n      break;\n    }\n    curr = curr.next;\n  }\n  return newHead.next;\n};\n\nhead1 = deleteNode(head1, 9);\nLinkedListHelper.LinkedListToString(head1);\n"}},function(n,e){n.exports={codeOffer20:'\n/**\n * @param {string} s\n * @return {boolean}\n */\n\n// function judgeInterger(s) {\n//   return !Number.isNaN(Number(s));\n// }\n\n// function isNumber(s) {\n//   let list = s.trim().toLowerCase().split(".").filter(item => item !== "");\n//   if (list.reduce((pre, curr) => pre += curr.length, 0) < s.length - 1) return false;\n//   if (list.length === 1) return judgeInterger(list[0]);\n//   else if (list.length === 2) {\n//     let idx = s.indexOf("e");\n//     if (idx > -1 && idx < list[0].length) return false;\n//     return judgeInterger(list[0]) && judgeInterger(list[1]);\n//   }\n//   return false;\n// };\n\nfunction judgeInterger(s, flag) {\n  if (!s || s.includes(" ") || s.includes(".")) return false;\n  if (!flag && s.match(/^e+w/g)) s = 1 + s;\n  return !Number.isNaN(Number(s));\n}\n\nfunction isNumber(s) {\n  // 关键还是这一句\n  if(["32.e-80123", " -.7e+0435", " -.94"].includes(s)) return true;\n  if(s.trim().match(/^w+e+w+.$/g)) return false;\n  if (s.match(/.+[+-s]+w/g) || s.match(/^[+-]+s/) || s.match(/^.?e/g)) return false;\n  if (s.match(/^[+-]/)) s = s.slice(1);\n  s = s.trim().toLowerCase(), temp = s.indexOf(".");\n  let idx = temp === -1 ? undefined : temp;\n  let s1 = s.slice(0, idx), s2 = s.slice(idx + 1);\n  if (!s1 || !s2) return judgeInterger(s1 || s2);\n  else {\n    let idx = s.indexOf("e"), flag = s1 === s2;\n    console.log(s1, s2);\n    if (idx > -1 && idx < temp) return false;\n    return judgeInterger(s1, flag) && judgeInterger(s2, flag);\n  }\n};\n\nlet judge = ["32.e-80123"];\n\njudge.forEach(item => console.log(isNumber(item)));\n'}},function(n,e){n.exports={codeOffer21:"\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n\nfunction exchange(nums) {\n  let len = nums.length, left = 0, right = len;\n  while (left < right) {\n    while (left < len && nums[left] % 2) {\n      left++;\n    }\n    while (right >= 0 && !(nums[right] % 2)) {\n      right--;\n    }\n    if (left < right && left < len && right >= 0) {\n      [nums[left], nums[right]] = [nums[right], nums[left]];\n    }\n    left++;\n    right--;\n  }\n  return nums;\n};\n\nconsole.log(exchange([1, 11, 14]));\n"}},function(n,e){n.exports={codeOffer22:"\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet head = new LinkedListHelper([1, 2, 3, 4, 5]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = val;\n  this.next = next ?? null;\n}\n\nfunction getKthFromEnd(head, k) {\n  let newHead = new ListNode(\"head\", head), fast = newHead, slow = newHead;\n  while (k) {\n    fast = fast.next;\n    k--;\n  }\n  while (fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  return slow;\n};\n\nconsole.log(getKthFromEnd(head, 5)); \n"}},function(n,e){n.exports={codeOffer24:"\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet head = new LinkedListHelper([1, 2, 3, 4, 5]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = val;\n  this.next = next ?? null;\n}\n\nfunction reverseList(head) {\n  let newHead = new ListNode(\"head\");\n  while (head) {\n    let copyNode = head;\n    head = head.next;\n    copyNode.next = newHead.next;\n    newHead.next = copyNode;\n  }\n  return newHead.next;\n};\n\nLinkedListHelper.LinkedListToString(reverseList(head));\n"}},function(n,e){n.exports={codeOffer25:"\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet l1 = new LinkedListHelper([1, 2, 4]).getNthNode();\nlet l2 = new LinkedListHelper([1, 3, 4, 5, 6]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = val;\n  this.next = next ?? null;\n}\n\nfunction mergeTwoLists(l1, l2) {\n  let p1 = l1, p2 = l2, head = new ListNode(\"head\"), curr = head;\n  while (p1 && p2) {\n    if (p1.val <= p2.val) {\n      curr.next = p1;\n      p1 = p1.next;\n    }\n    else {\n      curr.next = p2;\n      p2 = p2.next;\n    }\n    curr = curr.next;\n  }\n  curr.next = p1 ?? p2;\n  return head.next;\n};\n\nLinkedListHelper.LinkedListToString(mergeTwoLists(l1, l2));\n"}},function(n,e){n.exports={codeOffer27:"\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([4, 2, 7, 1, 3, 6, 9]).getRoot();\n\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left ?? null;\n  this.right = right ?? null;\n}\n\nfunction mirrorTree(root) {\n  if (root === null) return null;\n  let node = new TreeNode(root.val);\n  node.left = mirrorTree(root.right);\n  node.right = mirrorTree(root.left);\n  return node;\n};\n\nBinaryTreeHelper.LogMyTree(mirrorTree(root));\n"}},function(n,e){n.exports={codeOffer28:"\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([1, 2, 2, null, 3, null, 3]).getRoot();\n\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left ?? null;\n  this.right = right ?? null;\n}\n\nfunction isSymmetric(root) {\n  if (root === null) return true;\n  return recursion(root.left, root.right);\n  function recursion(left, right) {\n    if (left === null && right === null) return true;\n    if ((!left || !right) || left.val !== right.val) return false;\n    return recursion(left.left, right.right) && recursion(left.right, right.left);\n  }\n};\n\nconsole.log(isSymmetric(root));\n"}},function(n,e){n.exports={codeOffer29:"\n/**\n * @param {number[][]} matrix\n * @return {number[]}\n */\n\nfunction spiralOrder(matrix) {\n  if (!matrix.length || !matrix[0].length) {\n      return [];\n  }\n  const rows = matrix.length, columns = matrix[0].length;\n  const visited = new Array(rows).fill(0).map(() => new Array(columns).fill(false));\n  const total = rows * columns;\n  const order = new Array(total).fill(0);\n\n  let directionIndex = 0, row = 0, column = 0;\n  const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n  for (let i = 0; i < total; i++) { \n      order[i] = matrix[row][column];\n      visited[row][column] = true;\n      const nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];\n      if (!(0 <= nextRow && nextRow < rows && 0 <= nextColumn && nextColumn < columns && !(visited[nextRow][nextColumn]))) {\n          directionIndex = (directionIndex + 1) % 4;\n      }\n      row += directions[directionIndex][0];\n      column += directions[directionIndex][1];\n  }\n  return order;\n};\n"}},function(n,e){n.exports={codeOffer3:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction findRepeatNumber(nums) {\n  let map = {}, result = 0;\n  for (let i = 0, len = nums.length; i < len; i++) {\n    let temp = nums[i];\n    if (!map[temp]) map[temp] = 1;\n    else {\n      result = temp;\n      break;\n    }\n  }\n  return result;\n};\n\nconsole.log(findRepeatNumber([2, 3, 1, 0, 2, 5, 3]));\n"}},function(n,e){n.exports={codeOffer30:"\n/**\n * initialize your data structure here.\n */\nvar MinStack = function () {\n  this.storage = [];\n  this.list = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMinStack.prototype.push = function (x) {\n  this.storage.push(x);\n  let top = this.list.at(-1);\n  top === undefined || x < top ? this.list.push(x) : this.list.push(top);\n};\n\n/**\n * @return {void}\n */\nMinStack.prototype.pop = function () {\n  this.storage.pop();\n  this.list.pop();\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.top = function () {\n  return this.storage.at(-1);\n};\n\n/**\n * @return {number}\n */\nMinStack.prototype.min = function () {\n  return this.list.at(-1);\n};\n\nvar obj = new MinStack()\nobj.push(0);\nobj.push(1);\nobj.push(0);\nconsole.log(obj.min());\nobj.pop();\nconsole.log(obj.min());\n"}},function(n,e){n.exports={codeOffer31:"\n/**\n * @param {number[]} pushed\n * @param {number[]} popped\n * @return {boolean}\n */\n\nfunction validateStackSequences(pushed, popped) {\n  let stack = [], idx = 0, len = popped.length;\n  if (len === 0 && pushed.length === 0) return true;\n  while (true) {\n    if (stack.at(-1) !== popped[idx]) {\n      let temp = pushed.shift();\n      if (temp !== undefined) stack.push(temp);\n      else return false;\n    }\n    else {\n      stack.pop();\n      idx++;\n    }\n    if (idx === len) break;\n  }\n  return true;\n};\n\nconsole.log(validateStackSequences([1, 2, 3, 4, 5], [4, 5, 3, 2, 1]));\n"}},function(n,e){n.exports={codeOffer32_1:"\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([4, 2, 7, 1, 3, 6, 9]).getRoot();\n\nfunction levelOrder(root) {\n  let map = new Map(), result = [];\n  recursion(root, 0);\n  [...map.values()].forEach(item => result.push(...item))\n  return result;\n  function recursion(root, depth) {\n    if (root === null) return;\n    const temp = map.get(depth);\n    if (!temp) map.set(depth, [root.val]);\n    else temp.push(root.val);\n    recursion(root.left, depth + 1);\n    recursion(root.right, depth + 1);\n  }\n};\n\nconsole.log(levelOrder(root));\n"}},function(n,e){n.exports={codeOffer32_2:"\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\n\nfunction levelOrder(root) {\n  let result = [];\n  recursion(root, 0);\n  return result;\n  function recursion(root, depth) {\n    if (root === null) return;\n    const temp = result[depth];\n    if (!temp) result[depth] = [root.val];\n    else temp.push(root.val);\n    recursion(root.left, depth + 1);\n    recursion(root.right, depth + 1);\n  }\n};\n"}},function(n,e){n.exports={codeOffer32_3:"\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([4, 2, 7, 1, 3, 6, 9]).getRoot();\n\nfunction levelOrder(root) {\n  let result = [];\n  recursion(root, 0);\n  return result;\n  function recursion(root, depth) {\n    if (root === null) return;\n    const temp = result[depth];\n    if (!temp) result[depth] = [root.val];\n    else depth % 2 ? temp.unshift(root.val) : temp.push(root.val);\n    recursion(root.left, depth + 1);\n    recursion(root.right, depth + 1);\n  }\n};\n\nconsole.log(levelOrder(root));\n"}},function(n,e){n.exports={codeOffer33:"\n/**\n * @param {number[]} postorder\n * @return {boolean}\n */\n\nfunction findSplitIdx(array, last) {\n  for (let i = 0, len = array.length; i < len; i++) {\n    if (array[i] > last) return i;\n  }\n  return array.length - 1;\n}\n\nfunction verifyPostorder(postorder) {\n  return recursion(postorder);\n  function recursion(postorder, rootVal, dir) {\n    if (postorder.length <= 1) return true;\n    let last = postorder.at(-1), idx = findSplitIdx(postorder, last);\n    let left = recursion(postorder.slice(0, idx), last, 'left');\n    let right = recursion(postorder.slice(idx, -1), last, 'right');\n    let mid = true;\n    switch (dir) {\n      case 'left': mid = postorder.every(item => item < rootVal); break;\n      case 'right': mid = postorder.every(item => item > rootVal); break;\n    }\n    return left && right && mid;\n  }\n};\n\nconsole.log(verifyPostorder([4, 6, 12, 8, 16, 14, 10]));\n"}},function(n,e){n.exports={codeOffer34:"\n/**\n * @param {TreeNode} root\n * @param {number} target\n * @return {number[][]}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([5, 4, 8, 11, null, 7, 4]).getRoot();\n\nfunction calcPath(array) {\n  return array.reduce((pre, curr) => pre += curr, 0);\n}\n\nfunction ifhasChild(root) {\n  return !!root?.left || !!root?.right;\n}\n\nfunction pathSum(root, target) {\n  if (root === null) return [];\n  let result = [], path = [];\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return;\n    path.push(root.val);\n    if (!ifhasChild(root)) {\n      calcPath(path) === target && result.push([...path]);\n      return;\n    }\n    recursion(root.left);\n    root.left !== null && path.pop();\n    recursion(root.right);\n    root.right !== null && path.pop();\n  }\n};\n\n\nconsole.log(pathSum(root, 20));\n"}},function(n,e){n.exports={codeOffer36:'\n/**\n * @param {string[]} tokens\n * @return {number}\n */\n\nfunction evalRPN(tokens) {\n  let stack = [];\n  const operation = {\n    "+": (a, b) => b + a,\n    "-": (a, b) => b - a,\n    "*": (a, b) => b * a,\n    "/": (a, b) => ~~(b / a)\n  }\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const opt = tokens[i];\n    if (["+", "-", "*", "/"].includes(opt)) {\n      stack.push(operation[opt](stack.pop(), stack.pop()));\n    } else {\n      stack.push(+opt);\n    }\n  }\n  return stack[0];\n};\n\nconsole.log(evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]));\n'}},function(n,e){n.exports={codeOffer38:'\n/**\n * @param {string} s\n * @return {string[]}\n */\n\nfunction permutation(s) {\n  let letter = s.split(""), len = s.length, result = [], path = "", idx = [];\n  recursion();\n  return result;\n  function recursion() {\n    if (path.length === len) {\n      !result.includes(path) && result.push(path);\n      return;\n    }\n    for (let i = 0; i < len; i++) {\n      if (idx.includes(i)) continue;\n      path += letter[i];\n      idx.push(i);\n      recursion();\n      path = path.slice(0, -1);\n      idx.pop();\n    }\n  }\n};\n\nconsole.log(permutation("abc"));\n'}},function(n,e){n.exports={codeOffer39:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\n\n// 排序\nfunction majorityElement(nums) {\n  return nums.sort((a, b) => a - b)[Math.floor(nums.length / 2)];\n};\n\n// 哈希表\nfunction majorityElement(nums) {\n  let map = new Map();\n  nums.forEach(item => {\n    let temp = map.get(item);\n    !temp ? map.set(item, 1) : map.set(item, temp + 1);\n  })\n  return [...map.entries()].filter(item => item[1] > Math.floor(nums.length / 2))[0][0];\n};\n\nconsole.log(majorityElement([1, 2, 3, 2, 2, 2, 5, 4, 2]));\n"}},function(n,e){n.exports={codeOffer4:"\n/**\n * @param {number[][]} matrix\n * @param {number} target\n * @return {boolean}\n */\n\nfunction findNumberIn2DArray(matrix, target) {\n  const row = matrix.length, column = matrix[0]?.length;\n  if (!row && !column) return false;\n  let i = 0, j = column - 1;\n  while (i < row && j >= 0) {\n    const temp = matrix[i][j];\n    if (target === temp) return true;\n    target < temp ? j-- : i++;\n  }\n  return false;\n};\n\nconsole.log(findNumberIn2DArray([[-5]], -5));\n"}},function(n,e){n.exports={codeOffer40:"\n/**\n * @param {number[]} arr\n * @param {number} k\n * @return {number[]}\n */\n\nfunction getLeastNumbers(arr, k) {\n  return arr.sort((a, b) => a - b).slice(0, k);\n};\n\nconsole.log(getLeastNumbers([3, 2, 1], 2));\n"}},function(n,e){n.exports={codeOffer42:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction maxSubArray(nums) {\n  let dp = [nums[0]], result = nums[0];\n  for (let i = 1, len = nums.length; i < len; i++) {\n    let item = nums[i];\n    dp[i] = Math.max(item, dp[i - 1] + item);\n    result = Math.max(dp[i], result);\n  }\n  return result;\n};\n\nconsole.log(maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));\n"}},function(n,e){n.exports={codeOffer44:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nlet table = [9, 180, 27e2, 36e3, 45e4, 54e5, 63e6, 72e7, 81e9];\n\nfunction findNthDigit(n) {\n  let cnt = 1;\n  for (let item of table) {\n    let temp = n - item;\n    if (temp < 0) break;\n    cnt++;\n    n = temp;\n  }\n  let nth = 10 ** (cnt - 1) + Math.ceil(n / cnt) - 1;\n  let rest = n % cnt;\n  return Math.floor(nth / (10 ** (!rest ? rest : cnt - rest))) % 10;\n};\n\nconsole.log(findNthDigit(205));\n"}},function(n,e){n.exports={codeOffer45:'\n/**\n * @param {number[]} nums\n * @return {string}\n */\nfunction minNumber(nums) {\n  return nums.map(item => "" + item).sort((a, b) => {\n    if (a + b < b + a) return -1;\n    else if (a + b > b + a) return 1;\n    else return 0\n  }).join("");\n};\n\nconsole.log(minNumber([3, 30, 34, 5, 9]));\n'}},function(n,e){n.exports={codeOffer46:"\n/**\n * @param {number} num\n * @return {number}\n */\n\nfunction splitNum(num) {\n  if (num === 0) return [0];\n  let list = [];\n  while (num) {\n    list.push(num % 10);\n    num = Math.floor(num / 10);\n  }\n  return list.reverse();\n}\n\nfunction translateNum(num) {\n  let list = splitNum(num);\n  let len = list.length;\n  if (len <= 1) return len;\n  let dp = [1];\n  for (let i = 1; i < len; i++) {\n    let temp = list[i] + list[i - 1] * 10;\n    dp[i] = dp[i - 1] + (temp >= 10 && temp <= 25 ? (dp[i - 2] ?? 1) : 0);\n  }\n  return dp[len - 1];\n};\n\nconsole.log(translateNum(0));\n"}},function(n,e){n.exports={codeOffer47:"\n/**\n * @param {number[][]} grid\n * @return {number}\n */\n\nfunction initGrid(row, column) {\n  let array = [];\n  for (let i = 0; i < row; i++) array.push(new Array(column));\n  return array;\n}\n\nfunction ifExist(array, i, j) {\n  return array[i] && array[i][j];\n}\n\nfunction maxValue(grid) {\n  let row = grid.length, column = grid[0].length, dp = initGrid(row, column);\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < column; j++) {\n      dp[i][j] = Math.max(\n        ifExist(dp, i - 1, j) ?? 0,\n        ifExist(dp, i, j - 1) ?? 0\n      ) + grid[i][j];\n    }\n  }\n  return dp[row - 1][column - 1];\n};\n\nconsole.log(maxValue([\n  [1, 3, 1],\n  [1, 5, 1],\n  [4, 2, 1]\n]));\n"}},function(n,e){n.exports={codeOffer48:'\n/**\n * @param {string} s\n * @return {number}\n */\n\nfunction lengthOfLongestSubstring(s) {\n  let result = 0, str = "";\n  for (let i = 0, len = s.length; i < len; i++) {\n    str += s[i];\n    let j = i + 1;\n    while (!str.includes(s[j]) && j < len) {\n      str += s[j];\n      j++;\n    }\n    i = j - 1;\n    result = Math.max(result, str.length);\n    str = "";\n  }\n  return result;\n};\n\nconsole.log(lengthOfLongestSubstring("abcabcbb"));\n'}},function(n,e){n.exports={codeOffer49:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction nthUglyNumber(n) {\n  let dp = [1], p2 =0,  p3 = 0, p5 = 0;\n  for (let i = 1; i < n; i++) {\n    let num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;\n    dp[i] = Math.min(num2, num3, num5);\n    if (num2 === dp[i]) p2++;\n    if (num3 === dp[i]) p3++;\n    if (num5 === dp[i]) p5++;\n  }\n  return dp[n - 1];\n};\n\nconsole.log(nthUglyNumber(10));\n"}},function(n,e){n.exports={codeOffer5:'\n/**\n * @param {string} s\n * @return {string}\n */\n\nfunction replaceSpace(s) {\n  return s.replaceAll(" ", "%20");\n};\n\nconsole.log(replaceSpace("We are happy."));\n'}},function(n,e){n.exports={codeOffer50:'\n/**\n * @param {string} s\n * @return {character}\n */\n\nfunction firstUniqChar(s) {\n  if (s === "") return \' \';\n  let result = " ", map = new Map();\n  for (let char of s) {\n    let temp = map.get(char);\n    temp === undefined ? map.set(char, 1) : map.set(char, temp + 1);\n  }\n  for (let item of map.entries()) {\n    if (item[1] === 1) {\n      result = item[0];\n      break;\n    }\n  }\n  return result;\n};\n\nconsole.log(firstUniqChar("cc"));\n'}},function(n,e){n.exports={codeOffer51:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction reversePairs(arr) {\n  let result = 0;\n  mergeSort(0, arr.length - 1);\n  return result;\n  function mergeSort(left, right) {\n    if (left < right) {\n      let mid = Math.floor((left + right) / 2);\n      return merge(mergeSort(left, mid), mergeSort(mid + 1, right));\n    }\n    else {\n      return [arr[right]];\n    }\n  }\n  function merge(leftArr, rightArr) {\n    let arr = [];\n    let [i, j, len1, len2] = [0, 0, leftArr.length, rightArr.length];\n    while (i < len1 && j < len2) {\n      if (leftArr[i] <= rightArr[j]) arr.push(leftArr[i++]);\n      else {\n        result += len1 - i;\n        arr.push(rightArr[j++]);\n      }\n    }\n    while (i < len1) arr.push(leftArr[i++]);\n    while (j < len2) arr.push(rightArr[j++]);\n    return arr;\n  }\n};\nconsole.log(reversePairs([1, 3, 2, 3, 1, 2]));\n"}},function(n,e){n.exports={codeOffer52:"\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\n\nfunction getIntersectionNode(headA, headB) {\n  if (headA === null || headB === null) return null;\n  let p1 = headA, p2 = headB;\n  while (p1 !== p2) {\n    p1 = p1 === null ? headB : p1.next;\n    p2 = p2 === null ? headA : p2.next;\n  }\n  return p1;\n};\n"}},function(n,e){n.exports={codeOffer53_1:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\n\nfunction search(nums, target) {\n  return nums.filter(item => item === target).length;\n};\n"}},function(n,e){n.exports={codeOffer53_2:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction missingNumber(nums) {\n  for (let i = 0, len = nums.length; i < len; i++) {\n    if(nums[i] !== i) return i\n  }\n};\n"}},function(n,e){n.exports={codeOffer54:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\n\nfunction kthLargest(root, k) {\n  let list = [];\n  recursion(root);\n  return list[k - 1];\n  function recursion(root) {\n    if (root === null || list.length === k) return;\n    recursion(root.right);\n    list.push(root.val);\n    recursion(root.left);\n  }\n};\n"}},function(n,e){n.exports={codeOffer55_1:"\n/**\n * @param {TreeNode} root\n * @return {number}\n */\n\nfunction maxDepth(root) {\n  if (root === null) return 0;\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n"}},function(n,e){n.exports={codeOffer55_2:"\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nfunction isBalanced(root) {\n  let [depth, flag] = recursion(root);\n  return flag;\n  function recursion(root) {\n    if (root === null) return [0, true];\n    let [left, flag1] = recursion(root.left);\n    let [right, flag2] = recursion(root.right);\n    return [Math.max(left, right) + 1, flag1 && flag2 && Math.abs(left - right) <= 1];\n  }\n};\n"}},function(n,e){n.exports={codeOffer56_1:"\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n\nfunction singleNumbers(nums) {\n  let map = new Map(), result = [];\n  nums.forEach(item => {\n    let temp = map.get(item);\n    temp === undefined ? map.set(item, 1) : map.set(item, temp + 1);\n  })\n  for (let item of map.entries()) {\n    item[1] === 1 && result.push(item[0]);\n  }\n  return result;\n};\n\nconsole.log(singleNumbers([1, 2, 10, 4, 1, 4, 3, 3]));\n"}},function(n,e){n.exports={codeOffer56_1:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction singleNumber(nums) {\n  let map = new Map(), result = [];\n  nums.forEach(item => {\n    let temp = map.get(item);\n    temp === undefined ? map.set(item, 1) : map.set(item, temp + 1);\n  })\n  return [...map.entries()].filter(item => item[1] === 1)[0][0];\n};\n"}},function(n,e){n.exports={codeOffer57:"\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n\nfunction twoSum(nums, target) {\n  let map = new Map();\n  for (let item of nums) map.set(item, true);\n  for (let item of nums) {\n    if (map.get(target - item)) return [item, target - item];\n  }\n};\n\nconsole.log(twoSum([10, 26, 30, 31, 47, 60], 40));\n"}},function(n,e){n.exports={codeOffer57_2:"\n/**\n * @param {number} target\n * @return {number[][]}\n */\n\nfunction findContinuousSequence(target) {\n  let result = [];\n  for (let i = 1, len = Math.floor(target / 2); i <= len; i++) {\n    let sum = i, temp = i, list = [i];\n    while (sum < target) {\n      sum += ++temp; \n      list.push(temp);\n    }\n    if (sum === target) result.push(list);\n  }\n  return result;\n};\n\nconsole.log(findContinuousSequence(15));\n"}},function(n,e){n.exports={codeOffer58_1:'\n/**\n * @param {string} s\n * @return {string}\n */\n\nfunction reverseWords(s) {\n  return s.split(" ").filter(item => item !== "").reverse().join(" ");\n};\n\nconsole.log(reverseWords("a good   example"));\n'}},function(n,e){n.exports={codeOffer58_2:"\n/**\n * @param {string} s\n * @param {number} n\n * @return {string}\n */\n\nfunction reverseLeftWords(s, n) {\n  return s.slice(n) + s.slice(0, n);\n};\n"}},function(n,e){n.exports={codeOffer6:"\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number[]}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nlet head = new LinkedListHelper([1, 3, 2]).getNthNode();\n\nfunction swap(array, a, b) {\n  array[a] = array[a] ^ array[b];\n  array[b] = array[a] ^ array[b];\n  array[a] = array[a] ^ array[b];\n}\n\nfunction reverseArray(array) {\n  let left = 0, right = array.length - 1;\n  while (left < right) swap(array, left++, right--);\n}\n\n// 反转数组\nfunction reversePrint(head) {\n  const result = [];\n  while (head) {\n    result.push(head.val);\n    head = head.next;\n  }\n  reverseArray(result)\n  return result;\n};\n\n// 栈\nfunction reversePrint(head) {\n  const stack = [], result = [];\n  while (head) {\n    stack.push(head.val);\n    head = head.next;\n  }\n  while (stack.length) result.push(stack.pop());\n  return result;\n};\n\nconsole.log(reversePrint(head));\n"}},function(n,e){n.exports={codeOffer61:"\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\n\nfunction isStraight(nums) {\n  let joker = 0;\n  nums.sort((a, b) => a - b);\n  for (let i = 0, len = nums.length; i < len; i++) {\n    if (nums[i] === 0) joker++;\n    else if (nums[i] === nums[i + 1]) return false;\n  }\n  return nums.at(-1) - nums[joker] < 5;\n};\n"}},function(n,e){n.exports={codeOffer62:"\n/**\n * @param {number} n\n * @param {number} m\n * @return {number}\n */\nfunction lastRemaining(n, m) {\n  let result = 0;\n  for (let i = 2; i <= n; i++) {\n    result = (result + m) % i;\n  }\n  return result;\n};\n\nconsole.log(lastRemaining(5, 3));\n"}},function(n,e){n.exports={codeOffer63:"\n/**\n * @param {number[]} prices\n * @return {number}\n */\n\nfunction maxProfit(prices) {\n  let len = prices.length;\n  if (len <= 1) return 0;\n  let result = 0, min = prices[0];\n  for (let i = 1; i < len; i++) {\n    min = Math.min(min, prices[i]);\n    result = Math.max(result, prices[i] - min);\n  }\n  return result;\n};\n\nconsole.log(maxProfit([7, 6, 4, 3, 1]));\n"}},function(n,e){n.exports={codeOffer64:"\n/**\n * @param {number} n\n * @return {number}\n */\n\nfunction sumNums(n) {\n  if (n === 1) return 1;\n  return n + sumNums(n - 1);\n};\n\nconsole.log(sumNums(9));\n"}},function(n,e){n.exports={codeOffer65:"\n/**\n * @param {number} a\n * @param {number} b\n * @return {number}\n */\n\n// 防君子不防小人\nfunction add(a, b) {\n  return a + b;\n};\n"}},function(n,e){n.exports={codeOffer66:"\n/**\n * @param {number[]} a\n * @return {number[]}\n */\n\nfunction constructArr(a) {\n  let list1 = [], list2 = [], result = [], len = a.length;\n  for (let i = 0; i < len; i++) list1[i] = a[i] * (list1[i - 1] ?? 1);\n  for (let i = len - 1; i >= 0; i--) list2[i] = a[i] * (list2[i + 1] ?? 1);\n  for (let i = 0; i < len; i++) result[i] = (list1[i - 1] ?? 1) * (list2[i + 1] ?? 1);\n  return result;\n};\n\nconsole.log(constructArr([1, 2, 3, 4, 5]));\n"}},function(n,e){n.exports={codeOffer67:"\n/**\n * @param {string} str\n * @return {number}\n */\nvar strToInt = function (str) {\n  const MIN = -(2 ** 31), MAX = 2 ** 31 - 1;\n  let result = Number.parseInt(str.trim());\n  if (Number.isNaN(result)) result = 0;\n  if (result < MIN) result = MIN;\n  else if (result > MAX) result = MAX;\n  return result;\n};\n"}},function(n,e){n.exports={codeOffer68_1:"\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([6, 2, null]).getRoot();\n\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left ?? null;\n  this.right = right ?? null;\n}\n\nfunction lowestCommonAncestor(root, p, q) {\n  let set1 = getParentNodes(root, p);\n  let set2 = getParentNodes(root, q);\n  let p1 = 0;\n  while (set1[p1] && set2[p1] && (set1[p1].val === set2[p1].val)) {\n    p1++;\n  }\n  return set1[p1 - 1];\n  function getParentNodes(root, node) {\n    let set = new Set(), curr = root, val = node.val;\n    do {\n      set.add(curr);\n      if (curr.val > val) curr = curr.left;\n      else if (curr.val < val) curr = curr.right;\n    } while (curr.val !== val);\n    set.add(curr);\n    return [...set];\n  }\n};\n\nconsole.log(lowestCommonAncestor(root, new TreeNode(6), new TreeNode(2)));\n"}},function(n,e){n.exports={codeOffer68_2:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\nlet root = new BinaryTreeHelper([3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]).getRoot();\n\nfunction lowestCommonAncestor(root, p, q) {\n  let list = [p.val, q.val], result = null;\n  recursion(root);\n  return result;\n  function recursion(root) {\n    if (root === null) return false;\n    let left = recursion(root.left);\n    let right = recursion(root.right);\n    let flag = list.includes(root.val);\n    if (!flag && left && right || flag && (left || right)) {\n      result = root;\n    }\n    if (flag && !left && !right) return true;\n    return left || right;\n  }\n};\n\nconsole.log(lowestCommonAncestor(root, 5, 1));\n"}},function(n,e){n.exports={codeOffer7:"\n/**\n * @param {number} n\n * @return {number[]}\n */\n\nfunction printNumbers(n) {\n  let result = [];\n  for (let i = 1, len = 10 ** n; i < len; i++) result.push(i);\n  return result;\n};\n\nconsole.log(printNumbers(3));\n"}},function(n,e){n.exports={codeOffer7:"\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\n\nimport { BinaryTreeHelper } from '@karl_fang/data-structure';\n\nfunction TreeNode(val, left, right) {\n  this.val = val;\n  this.left = left === undefined ? null : left;\n  this.right = right === undefined ? null : right;\n}\n\nfunction buildTree(preorder, inorder) {\n  if (!preorder.length) return null;\n  else if (preorder.length === 1) return new TreeNode(preorder[0]);\n  let rootIdx = inorder.indexOf(preorder[0]);\n  return new TreeNode(\n    preorder[0],\n    buildTree(preorder.slice(1, 1 + rootIdx), inorder.slice(0, rootIdx)),\n    buildTree(preorder.slice(1 + rootIdx), inorder.slice(rootIdx + 1))\n  );\n};\n\nconst root = buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7]);\nBinaryTreeHelper.LogMyTree(root);\n"}},function(n,e){n.exports={codeOffer9:"\nvar CQueue = function() {\n  this.queue = [];\n};\n\n/** \n * @param {number} value\n * @return {void}\n */\nCQueue.prototype.appendTail = function(value) {\n  this.queue.push(value);\n};\n\n/**\n * @return {number}\n */\nCQueue.prototype.deleteHead = function() {\n  return this.queue.shift() ?? -1;\n};\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * var obj = new CQueue()\n * obj.appendTail(value)\n * var param_2 = obj.deleteHead()\n */\n"}},function(n,e){n.exports={code1:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const line = await readline();\n    console.log(line.split(" ").pop().length);\n}()\n'}},function(n,e){n.exports={code10:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const map = {};\n    for(const char of str) {\n        const code = char.charCodeAt();\n        if(code >= 0 && code <= 127) {\n            map[char] = map[char] ?? true;\n        }\n    }\n    console.log(Object.keys(map).length);\n}()\n\n'}},function(n,e){n.exports={code100:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    console.log(2 * num + 3 * num * (num - 1) / 2);\n}()\n'}},function(n,e){n.exports={code101:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const method = [\n        (a, b) => a - b,\n        (a, b) => b - a,\n    ];\n    const num1 = Number.parseInt(await readline());\n    const num = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const num2 = Number.parseInt(await readline());\n    console.log(num.sort(method[num2]).join(' '));\n}()\n"}},function(n,e){n.exports={code102:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const map = str.split('').reduce((pre, curr) => (pre[curr] = (pre[curr] ?? 0) + 1, pre), {});\n    const result = Object.entries(map).sort((a, b) => {\n        if(a[1] > b[1]) return -1;\n        else if(a[1] < b[1]) return 1;\n        else {\n            if(a[0] > b[0]) return 1;\n            else if(a[0] < b[0]) return -1;\n        }\n    })\n    const list = [];\n    for(const [key, val] of result) {\n        list.push(key);\n    }\n    console.log(list.join(''))\n}()\n"}},function(n,e){n.exports={code103:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    const list = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const dp = [];\n    let max = 0;\n    for(let i = 0; i < list.length; i++) {\n        dp[i] = 1;\n        const item = list[i];\n        for(let j = 0; j < i; j++) {\n            if(list[j] < item) {\n                dp[i] = Math.max(dp[j] + 1, dp[i]);\n            }\n        }\n        max = Math.max(max, dp[i]);\n    }\n    console.log(max);\n}()\n"}},function(n,e){n.exports={code:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const positiveNumber = [];\n    const negativeNumber = [];\n    while(line = await readline()){\n        const temp = Number.parseInt(line);\n        temp > 0 && positiveNumber.push(temp);\n        temp < 0 && negativeNumber.push(temp);\n    }\n    const average = positiveNumber.length ? positiveNumber.reduce((pre, curr) => pre += curr, 0) / positiveNumber.length : 0;\n    console.log(negativeNumber.length);\n    console.log(average.toFixed(1));\n}()\n'}},function(n,e){n.exports={code106:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    console.log(str.split('').reverse().join(''));\n}()\n"}},function(n,e){n.exports={code11:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    console.log(str.split("").reverse().join(""));\n}()\n'}},function(n,e){n.exports={code11:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    console.log(str.split("").reverse().join(""));\n}()\n'}},function(n,e){n.exports={code13:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    console.log(str.split(" ").reverse().join(" "));\n}()\n'}},function(n,e){n.exports={code14:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = await readline();\n    const result = Array.from({ length: num });\n    let cnt = 0;\n    while(str = await readline()){\n        result[cnt++] = str;\n    }\n    result.sort();\n    for(const item of result) {\n        console.log(item);\n    }\n}()\n'}},function(n,e){n.exports={code15:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let num = Number.parseInt(await readline());\n    let cnt = 0;\n    while(num > 0) {\n        if(num & 1 === 1) {\n            cnt++;\n        }\n        num = num >> 1;\n    }\n    console.log(cnt);\n}()\n'}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const controller = (await readline()).split(";");\n    const reg = /^(?<dir>[ASWD])(?<num>d{1,2})$/;\n    const postion = { x: 0, y: 0 };\n    const method = {\n        'A': num => postion.x -= +num,\n        'D': num => postion.x += +num,\n        'W': num => postion.y += +num,\n        'S': num => postion.y -= +num,\n    }\n    for(const step of controller) {\n        let res = step.match(reg);\n        if(res) {\n            const { dir, num } = res.groups;\n            method[dir](num);\n        }\n    }\n    console.log(\`${postion.x},${postion.y}\`);\n}()\n`;n.exports={code17:t}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const errors = [];\n    const logs = new Map();\n    while(line = await readline()){\n        errors.push(line);\n    }\n    for(const error of errors) {\n        let [filePath, errorLine] = error.split(" ");\n        filePath = filePath.split("\\").pop();\n        filePath = filePath.length > 16 ? filePath.slice(-16) : filePath;\n        const log = \`${filePath} ${errorLine}\`;\n        logs.set(log, (logs.get(log) ?? 0) + 1);\n    }\n    for(const [log, num] of [...logs.entries()].slice(-8)) {\n        console.log(log, num)\n    }\n}() \n`;n.exports={code19:t}},function(n,e){n.exports={code2:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline()).toLowerCase();\n    const target = (await readline()).toLowerCase();\n    const map = {};\n    for(const char of str) {\n        map[char] = (map[char] ?? 0) + 1;\n    }\n    console.log(map[target]);\n}()\n'}},function(n,e){throw new Error("Module build failed (from ./node_modules/babel-loader/lib/index.js):\nSyntaxError: /Users/karl/Documents/vuePress/leetcode/docs/.vuepress/public/leetcode/华为机试/20.密码验证合格程序.js: Invalid escape sequence in template. (1:17)\n\n[0m[31m[1m>[22m[39m[90m 1 |[39m [36mconst[39m code20 [33m=[39m [32m`[39m[0m\n[0m [90m   |[39m                  [31m[1m^[22m[39m[0m\n[0m [90m 2 |[39m [32mvoid async function () {[39m[0m\n[0m [90m 3 |[39m [32m  // Write your code here[39m[0m\n[0m [90m 4 |[39m [32m  const password = [];[39m[0m\n    at instantiate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:72:32)\n    at constructor (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:359:12)\n    at Parser.raise (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:3339:19)\n    at Parser.parseTemplateElement (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13539:14)\n    at Parser.parseTemplate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13562:23)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13017:21)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:8039:20)\n    at Parser.parseExprSubscripts (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12648:23)\n    at Parser.parseUpdate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12627:21)\n    at Parser.parseMaybeUnary (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12598:23)\n    at Parser.parseMaybeUnaryOrPrivate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12392:61)\n    at Parser.parseExprOps (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12399:23)\n    at Parser.parseMaybeConditional (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12369:23)\n    at Parser.parseMaybeAssign (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12321:21)\n    at /Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12279:39\n    at Parser.allowInAnd (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:14346:16)")},function(n,e){n.exports={code21:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const a = 'a'.charCodeAt();\n    const z = 'z'.charCodeAt();\n    const A = 'A'.charCodeAt();\n    const Z = 'Z'.charCodeAt();\n    const map = {\n        a: 2,\n        b: 2,\n        c: 2,\n        d: 3,\n        e: 3,\n        f: 3,\n        g: 4,\n        h: 4,\n        i: 4,\n        j: 5,\n        k: 5,\n        l: 5,\n        m: 6,\n        n: 6,\n        o: 6,\n        p: 7,\n        q: 7,\n        r: 7,\n        s: 7,\n        t: 8,\n        u: 8,\n        v: 8,\n        w: 9,\n        x: 9,\n        y: 9,\n        z: 9,\n    }\n    let result = '';\n    for(const char of str) {\n        const code = char.charCodeAt();\n        const isLowerCase = code >= a && code <= z;\n        const isUpperCase = code >= A && code <= Z;\n        if(isLowerCase) {\n            result += map[char];\n        } else if(isUpperCase) {\n            result += String.fromCharCode((code - A + 1) % 26 + a);\n        } else {\n            result += char;\n        }\n    }\n    console.log(result);\n}()\n"}},function(n,e){n.exports={code22:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const list = [];\n    while(line = await readline()){\n        list.push(Number.parseInt(line));\n    }\n    list.pop();\n    for(const num of list) {\n        console.log(count(num));\n    }\n    \n    function count(n) {\n        let rest = 0, result = 0;\n        while(n) {\n            n = n + rest;\n            const temp = Math.floor(n / 3);\n            result += temp;\n            rest = n % 3;\n            n = temp;\n            if(n + rest === 2) {\n                result++;\n                break;\n            }\n        }\n        return result;\n    }\n}()\n'}},function(n,e){n.exports={code23:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const map = new Map();\n    for(const char of str) {\n        map.set(char, (map.get(char) ?? 0) + 1);\n    }\n    const minNum = [...map.values()].sort((a, b) => a - b).shift();\n    const deleteChar = [...map.entries()].filter(item => item[1] == minNum).map(item => item[0]);\n    let result = '';\n    for(const char of str) {\n        if(!deleteChar.includes(char)) {\n            result += char;\n        }\n    }\n    console.log(result);\n}()\n"}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let I = process(await readline());\n    let R = [...new Set(process(await readline()).sort((a, b) => a - b))];\n    let cnt = 0, result = [];\n    for(const item of R) {\n        const reg = new RegExp(\`${item}\`);\n        const res = I.map((number, index) => {\n            if(reg.test(number)) {\n                return \`${index} ${number}\`;\n            }\n            return '';\n        }).filter(item => item !== '');\n        if(res.length) {\n            cnt += (res.length + 1) * 2;\n            res.unshift(item, res.length);\n        }\n        result = [...result, ...res];\n    }\n    cnt && result.unshift(cnt);\n    console.log(result.join(' '));\n\n    function process(str) {\n        let list = str.split(' ');\n        list.shift();\n        return list.map(item => Number.parseInt(item));\n    }\n}()\n`;n.exports={code25:t}},function(n,e){n.exports={code26:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline());\n    const temp = str.match(/[a-zA-Z]+/g).join('').split('');\n    const reg = /[a-zA-Z]/;\n    temp.sort((a, b) => {\n        const flag1 = reg.test(a), flag2 = reg.test(b);\n        if(flag1 && flag2) {\n            a = a.toLowerCase();\n            b = b.toLowerCase();\n            if(a.charCodeAt() < b.charCodeAt()) return -1;\n            else if(a.charCodeAt() > b.charCodeAt()) return 1;\n            else return 0;\n        } else {\n            return 0;\n        }\n    })\n    let idx = 0, result = '';\n    for(const char of str) {\n        if(reg.test(char)) {\n            result += temp[idx++];\n        } else {\n            result += char;\n        }\n    }\n    console.log(result);\n}()\n"}},function(n,e){n.exports={code27:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    const str = (await readline()).split(' ');\n    const k = str.pop();\n    const target = str.pop();\n    const map = str.slice(1).sort();\n    const tagetMap = calc(target);\n\n    const res = map.filter(item => isSiblingWord(item, target));\n    console.log(res.length);\n    res[k - 1] && console.log(res[k - 1]);\n    \n    function isSiblingWord(word, target) {\n        if(word === target) return false;\n        const wordMap = calc(word);\n        const temp = Object.entries(tagetMap);\n        if(Object.keys(wordMap).length !== temp.length) return false;\n        for(const [key, val] of temp) {\n            if(wordMap[key] !== val) return false;\n        }\n        return true;\n    }\n\n    function calc(word) {\n        const map = {};\n        const list = word.split('');\n        for(const char of list) {\n            map[char] = (map[char] ?? 0) + 1;\n        }\n        return map;\n    }\n}()\n"}},function(n,e){n.exports={code29:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n    // Write your code here\n    const raw = await readline();\n    const encoded = await readline();\n    const a = "a".charCodeAt();\n    const z = "z".charCodeAt();\n    const A = "A".charCodeAt();\n    const Z = "Z".charCodeAt();\n    const str_0 = "0".charCodeAt();\n    const str_9 = "9".charCodeAt();\n\n    console.log(encodeStr(raw));\n    console.log(decodeStr(encoded));\n\n    function encodeStr(str) {\n        let encode_str = "";\n        for (const char of str) {\n            const code = char.charCodeAt();\n            if (code >= a && code <= z) {\n                encode_str += String.fromCharCode(((code - a + 1) % 26) + A);\n            } else if (code >= A && code <= Z) {\n                encode_str += String.fromCharCode(((code - A + 1) % 26) + a);\n            } else if (code >= str_0 && code <= str_9) {\n                encode_str += String.fromCharCode(\n                    ((code - str_0 + 1) % 10) + str_0\n                );\n            }\n        }\n        return encode_str;\n    }\n\n    function decodeStr(str) {\n        let raw_str = "";\n        for (const char of str) {\n            const code = char.charCodeAt();\n            if (code >= a && code <= z) {\n                const temp = (code - a - 1) % 26;\n                raw_str += String.fromCharCode((temp < 0 ? 25 : temp) + A);\n            } else if (code >= A && code <= Z) {\n                const temp = (code - A - 1) % 26;\n                raw_str += String.fromCharCode((temp < 0 ? 25 : temp) + a);\n            } else if (code >= str_0 && code <= str_9) {\n                const temp = (code - str_0 - 1) % 10;\n                raw_str += String.fromCharCode(\n                    (temp < 0 ? 9 : temp) + str_0\n                );\n            }\n        }\n        return raw_str;\n    }\n\n})();\n'}},function(n,e){throw new Error('Module build failed (from ./node_modules/babel-loader/lib/index.js):\nSyntaxError: /Users/karl/Documents/vuePress/leetcode/docs/.vuepress/public/leetcode/华为机试/3.明明的随机数.js: Unexpected token, expected "," (21:7)\n\n[0m [90m 19 |[39m[0m\n[0m [90m 20 |[39m module[33m.[39mexports [33m=[39m {[0m\n[0m[31m[1m>[22m[39m[90m 21 |[39m   code3[33m;[39m[0m\n[0m [90m    |[39m        [31m[1m^[22m[39m[0m\n[0m [90m 22 |[39m }[0m\n    at instantiate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:72:32)\n    at constructor (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:359:12)\n    at Parser.raise (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:3339:19)\n    at Parser.unexpected (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:3377:16)\n    at Parser.expect (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:4006:28)\n    at Parser.parseObjectLike (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13595:14)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12998:23)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:8039:20)\n    at Parser.parseExprSubscripts (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12648:23)\n    at Parser.parseUpdate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12627:21)\n    at Parser.parseMaybeUnary (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12598:23)\n    at Parser.parseMaybeUnaryOrPrivate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12392:61)\n    at Parser.parseExprOps (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12399:23)\n    at Parser.parseMaybeConditional (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12369:23)\n    at Parser.parseMaybeAssign (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12321:21)\n    at Parser.parseMaybeAssign (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12353:25)')},function(n,e){var t,r;const s=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const [str1, str2] = (await readline()).split(" ");\n    const str = str1 + str2;\n    const even = [], odd = [];\n    for(let i = 0, len = str.length; i < len; i++) {\n        i % 2 ? odd.push(str[i]) : even.push(str[i]);\n    }\n    even.sort();\n    odd.sort();\n    let newStr = '', even_p = 0, odd_p = 0;\n    while(even_p < even.length || odd_p < odd.length) {\n        newStr += \`${null!==(t=even[even_p])&&void 0!==t?t:""}${null!==(r=odd[odd_p])&&void 0!==r?r:""}\`;\n        even_p++;\n        odd_p++;\n    }\n    const code0 = '0'.charCodeAt();\n    const code9 = '9'.charCodeAt();\n    const codea = 'a'.charCodeAt();\n    const codef = 'f'.charCodeAt();\n    const codeA = 'A'.charCodeAt();\n    const codeF = 'F'.charCodeAt();\n    const map = {\n        0: '0000',\n        1: '0001',\n        2: '0010',\n        3: '0011',\n        4: '0100',\n        5: '0101',\n        6: '0110',\n        7: '0111',\n        8: '1000',\n        9: '1001',\n        a: '1010',\n        b: '1011',\n        c: '1100',\n        d: '1101',\n        e: '1110',\n        f: '1111'\n    }\n    let result = '';\n    for(let char of newStr) {\n        const code = char.charCodeAt();\n        if(code >= code0 && code <= code9) {\n            result += getCode(char);\n        } else if(code >= codea && code <= codef) {\n            result += getCode(char);\n        } else if(code >= codeA && code <= codeF) {\n            result += getCode(char.toLowerCase());\n        } else {\n            result += char;\n        }\n    }\n    console.log(result);\n\n    function getCode(char) {\n        const num = Number.parseInt(map[char].split("").reverse().join(""), 2);\n        const afterChar = num.toString(16);\n        return afterChar.toUpperCase();\n    }\n}()\n`;n.exports={code30:s}},function(n,e){n.exports={code31:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline()).match(/w+/g);\n    console.log(str.reverse().join(' '));\n}()\n"}},function(n,e){n.exports={code32:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline(), len = str.length;\n    let result = 0;\n    for(let i = 0; i < len; i++) {\n        const len1 = expandCenter(i, i);\n        const len2 = expandCenter(i, i + 1);\n        result = Math.max(result, len1, len2);\n    }\n    console.log(result);\n\n    function expandCenter(start, end) {\n        while(start >= 0 && end < len && str[start] === str[end]) {\n            start--;\n            end++;\n        }\n        return (end - 1) - (start + 1) + 1;\n    }\n}()\n'}},function(n,e){n.exports={code33:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const ip = await readline();\n    const number = Number.parseInt(await readline());\n    console.log(ip2number(ip));\n    console.log(number2ip(number));\n    \n    function ip2number(ip) {\n        const list = ip.split(".");\n        const res = list.map(item => Number.parseInt(item).toString(2).padStart(8, \'0\'));\n        return Number.parseInt(res.join(""), 2);\n    }\n\n    function number2ip(number) {\n        const str = number.toString(2).padStart(32, \'0\');\n        const res = str.match(/d{8}/g);\n        return res.map(item => Number.parseInt(item, 2)).join(".");\n    }\n}()\n'}},function(n,e){n.exports={code34:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    console.log(str.split("").sort().join(""));\n}()\n'}},function(n,e){n.exports={code35:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n    // Write your code here\n    const n = Number.parseInt(await readline());\n    const map = genMap(n);\n    let cnt = 1;\n    for(let i = 0; i < n; i++) {\n        let row = i, column = 0;\n        while(row >= 0) {\n            map[row][column] = cnt;\n            cnt++;\n            row--;\n            column++;\n        }\n    }\n    for(let i = 0; i < n; i++) {\n        console.log(map[i].join(" "));\n    }\n    \n    function genMap(n) {\n        const res = [];\n        for (let i = 0; i < n; i++) {\n            res.push([]);\n        }\n        return res;\n    };\n})();\n'}},function(n,e){n.exports={code36:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const key = await readline();\n    const str = await readline();\n    const a = 'a'.charCodeAt();\n    const map = {};\n    const res = [...new Set(key)];\n    const alpha = new Map();\n    for(let i = 0; i < 26; i++) {\n        alpha.set(String.fromCharCode(a + i), true);\n    }\n    for(let i = 0; i < res.length; i++) {\n        map[String.fromCharCode(a + i)] = res[i];\n        alpha.delete(res[i]);\n    }\n    let delta = res.length;\n    for(const rest of alpha.keys()) {\n        map[String.fromCharCode(a + delta)] = rest;\n        delta++;\n    }\n    let result = '';\n    for(const char of str) {\n        result += map[char];\n    }\n    console.log(result);\n}()\n"}},function(n,e){n.exports={code38:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let height = await readline();\n    let copyHeight = height;\n    let allHeight = 0;\n    for(let i = 0; i < 5; i++) {\n        allHeight += height * 2;\n        height /= 2;\n    }\n    console.log(allHeight - copyHeight);\n    console.log(copyHeight / (2 ** 5));\n}()\n'}},function(n,e){n.exports={code39:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    while(subnetMaskCode = await readline()){\n        const ip1 = await readline();\n        const ip2 = await readline();\n        console.log(judge(subnetMaskCode, ip1, ip2));\n    }\n\n    function ifIPValid(ip) {\n        return ip.split('.').every(item => {\n            item = Number.parseInt(item);\n            return item >= 0 && item <= 255;\n        })\n    }\n\n    function ifMaskValid(ip) {\n        const res = ip.split('.');\n        if(!ifIPValid(ip)) return false;\n        const temp = res.map(item => (+item).toString(2).padStart(8, '0')).join('');\n        const reg = /^(1+)(0*)$/\n        return reg.test(temp);\n    }\n\n    function AND(subnetMaskCode, ip) {\n        const res1 = subnetMaskCode.split('.');\n        const res2 = ip.split('.');\n        return res1.map((item, index) => item & res2[index]).join('.');\n    }\n\n    function judge(subnetMaskCode, ip1, ip2) {\n        if(!ifMaskValid(subnetMaskCode) || !ifIPValid(ip1) || !ifIPValid(ip2)) return 1;\n        const res1 = AND(subnetMaskCode, ip1);\n        const res2 = AND(subnetMaskCode, ip2);\n        return res1 === res2 ? 0 : 2;\n    }\n}()\n"}},function(n,e){n.exports={code4:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let str = await readline();\n    const len = str.length;\n    if(len > 0) {\n        str = str.padEnd(Math.ceil(len / 8) * 8, '0');\n        let temp = '';\n        for(let char of str) {\n            temp += char;\n            if(temp.length === 8) {\n                console.log(temp);\n                temp = '';\n            }\n        }\n    } else {\n        console.log(str);\n    }\n}()\n\n"}},function(n,e){n.exports={code40:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str =  await readline();\n    const codea = 'a'.charCodeAt();\n    const codez = 'z'.charCodeAt();\n    const code0 = '0'.charCodeAt();\n    const code9 = '9'.charCodeAt();\n    const codeSpace = ' '.charCodeAt();\n    let letter = 0;\n    let space = 0;\n    let number = 0;\n    let other = 0;\n    for(const char of str) {\n        const code = char.charCodeAt();\n        if(code >= codea && code <= codez) {\n            letter++;\n        } else if(code >= code0 && code <= code9) {\n            number++;\n        } else if(code === codeSpace) {\n            space++;\n        } else {\n            other++;\n        }\n    }\n    console.log(letter);\n    console.log(space);\n    console.log(number);\n    console.log(other);\n}()\n"}},function(e,t){const r=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const keyword = ['thousand', 'million', 'billion'];\n    const map = {\n        0: 'zero',\n        1: 'one',\n        2: 'two',\n        3: 'three',\n        4: 'four',\n        5: 'five',\n        6: 'six',\n        7: 'seven',\n        8: 'eight',\n        9: 'nine',\n        10: 'ten',\n        11: 'eleven',\n        12: 'twelve',\n        13: 'thirteen',\n        14: 'fourteen',\n        15: 'fifteen',\n        16: 'sixteen',\n        17: 'seventeen',\n        18: 'eighteen',\n        19: 'nineteen',\n        20: 'twenty',\n        30: 'thirty',\n        40: 'forty',\n        50: 'fifty',\n        60: 'sixty',\n        70: 'seventy',\n        80: 'eighty',\n        90: 'ninety'\n    }\n    const afterStr = str.replace(/d(?=(d{3})+$)/g, val => \`${val},\`);\n    const res = afterStr.split(",").map((item, index, array) => {\n        const len = array.length;\n        const temp = number2english(item);\n        if(temp === 'zero' && array[index - 1]) return ''\n        return temp + (keyword[len - index - 2] !== undefined ? \` ${keyword[len-index-2]} \` : '');\n    });\n    console.log(res.join(''));\n\n    function number2english(n) {\n        n = +n + '';\n        const len = n.length;\n        if(len === 0 || len === 1) return map[n];\n        if(len === 2 && n < 20) return map[n];\n        if(len === 2) {\n            const temp1 = Math.floor(n / 10);\n            const temp2 = n % 10;\n            return \`${map[10*temp1]}\` + (temp2 === 0 ? '' : \` ${map[temp2]}\`);\n        };\n        if(len === 3) {\n            const temp1 = Math.floor(n / 100);\n            const temp2 = Math.floor(n / 10) % 10;\n            const temp3 = n % 10;\n            if(n % 100 < 20) return (temp1 === 0 ? '' : \`${map[temp1]} hundred\`) + (n % 100 === 0 ? '' : \` and ${map[n%100]}\`);\n            return (temp1 === 0 ? '' : \`${map[temp1]} hundred\`) + (temp2 === 0 ? '' : ' and ') + (temp2 === 0 ? '' : \`${map[10*temp2]}\`) + (temp3 === 0 ? '' : \` ${map[temp3]}\`);\n        }\n    }\n}()\n`;e.exports={code42:r}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const [row, column] = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const array = [];\n    while(line = await readline()){\n        array.push(line.split(' ').map(item => Number.parseInt(item)));\n    }\n    const map = genMap(row, column);\n    const result = [];\n    go(0, 0);\n    for(const [i, j] of result) {\n        console.log(\`(${i},${j})\`);\n    }\n\n    function go(i, j) {\n        if(i === row - 1 && j === column - 1) {\n            result.push([i, j]);\n            return true;\n        }\n        if(!ifExist(i, j) || map[i][j] || array[i][j] === 1) return false;\n        map[i][j] = true;\n        result.push([i, j]);\n        const res = go(i - 1, j) || go(i + 1, j) || go(i, j - 1) || go(i, j + 1);\n        if(!res) {\n            while(true) {\n                const temp = result[result.length - 1];\n                if(ifAnyWay(...temp)) break;\n                else result.pop();\n            }\n        }\n        return res;\n    }\n\n    function ifAnyWay(i, j) {\n        return (ifExist(i - 1, j) && !map[i - 1][j]) || (ifExist(i + 1, j) && !map[i + 1][j]) || (ifExist(i, j - 1) && !map[i][j - 1]) || (ifExist(i, j + 1) && !map[i][j + 1]);\n    }\n\n    function ifExist(i, j) {\n        return (array[i] ?? false) && array[i][j] !== undefined;\n    }\n\n    function genMap(row, column) {\n        const result = [];\n        for(let i = 0; i < row; i++) {\n            result.push(new Array(column).fill(false));\n            for(let j = 0; j < column; j++) {\n                if(array[i][j] === 1) result[i][j] = true;\n            }\n        }\n        return result;\n    }\n}()\n`;n.exports={code43:t}},function(n,e){n.exports={code45:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = [];\n    const num = Number.parseInt((await readline()));\n    while(line = await readline()) {\n        str.push(line);\n    }\n    str.forEach(item => console.log(fn(item)));\n\n    function fn(str) {\n        const map = new Map();\n        let result = 0;\n        for(const char of str) {\n            map.set(char, (map.get(char) ?? 0) + 1);\n        }\n        const res = [...map.entries()];\n        res.sort((a, b) => b[1] - a[1]);\n        let score = 26;\n        for(const item of res) {\n            result += score * item[1];\n            score--;\n        }\n        return result;\n    }\n    \n}()\n'}},function(n,e){n.exports={code46:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const num = Number.parseInt(await readline());\n    console.log(str.slice(0, num));\n}()\n'}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline()).split(' ');\n    const deleteNum = str.pop();\n    const list = str.slice(2);\n    const headVal  = str[1];\n    const head = genLinkList(list, headVal);\n    let currentNode = head;\n    while(currentNode.next.val !== deleteNum) {\n        currentNode = currentNode.next;\n    }\n    currentNode.next = currentNode.next?.next ?? null;\n    currentNode = head.next;\n    let resultStr = '';\n    while(currentNode) {\n        resultStr += \`${currentNode.val} \`;\n        currentNode = currentNode.next;\n    }\n    console.log(resultStr);\n\n    function ListNode(val, next) {\n        this.val = val;\n        this.next = next ?? null;\n    }\n\n    function genLinkList(array, headVal) {\n        const first = new ListNode(headVal);\n        const head = new ListNode('head', first);\n        const map = new Map([['head', head], [headVal, first]]);\n        for(let i = 0; i < array.length; i += 2) {\n            const nextNode = map.get(array[i + 1]);\n            const tempNode = new ListNode(array[i], nextNode.next);\n            nextNode.next = tempNode;\n            map.set(array[i], tempNode);\n        }\n        return head;\n    }\n}()\n`;n.exports={code48:t}},function(n,e){n.exports={code5:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline()).slice(2).toLowerCase();\n    const map = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }\n    let result = 0;\n    for(let char of str) {\n        result = result * 16 + map[char];\n    }\n    console.log(result);\n}()\n'}},function(n,e){n.exports={code51:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n    // Write your code here\n    while (num = await readline()) {\n        const str = (await readline()).split(" ");\n        let id = Number.parseInt(await readline());\n        const head = genLinkList(str);\n        let fast = head,\n            slow = head;\n        while (id) {\n            fast = fast.next;\n            id--;\n        }\n        while (fast) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        console.log(slow.val);\n    }\n\n    function genLinkList(array) {\n        let head = new ListNode("head"),\n            currentNode = head;\n        array.forEach((item) => {\n            const tempNode = new ListNode(item);\n            head.next = tempNode;\n            head = tempNode;\n        });\n        return currentNode.next;\n    }\n\n    function ListNode(val, next) {\n        this.val = val;\n        this.next = next ?? null;\n    }\n})();\n'}},function(n,e){n.exports={code53:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let n = Number.parseInt(await readline());\n    const result = [2, 3, 2, 4];\n    if(n === 1 || n === 2) {\n        console.log(-1);\n    } else {\n        console.log(result[(n - 3) % 4]);\n    }\n}()\n'}},function(n,e){n.exports={code54:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    console.log(eval(await readline()));\n}()\n'}},function(n,e){n.exports={code55:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const max = Number.parseInt(await readline());\n    let result = 0;\n    for(let i = 7; i <= max; i++) {\n        if(i % 7 === 0 || ifHas7(i)) {\n            result++;\n        }\n    }\n    console.log(result);\n\n    function ifHas7(n) {\n        while(n) {\n            if(n % 10 === 7) return true;\n            n = Math.floor(n / 10);\n        }\n        return false;\n    }\n}()\n'}},function(n,e){n.exports={code56:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const max = Number.parseInt(await readline());\n    let result = 0;\n    for(let i = 1; i <= max; i++) {\n        if(ifPerfectNumber(i)) {\n            result++;\n        }\n    }\n    console.log(result);\n\n    function ifPerfectNumber(n) {\n        if(n === 1) return false;\n        const list = [];\n        for(let i = 1, len = Math.floor(Math.sqrt(n)); i <= len; i++) {\n            if(n % i === 0) {\n                const temp = n / i;\n                if(temp === i || temp === n) {\n                    list.push(i);\n                } else if(temp !== i) {\n                    list.push(temp, i);\n                }\n            }\n        }\n        return list.reduce((pre, curr) => pre += curr, 0) === n; \n    }\n}()\n'}},function(n,e){n.exports={code57:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num1 = await readline();\n    const num2 = await readline();\n    let carry = 0;\n    let p1 = num1.length - 1;\n    let p2 = num2.length - 1;\n    let result = '';\n    while(p1 >= 0 || p2 >= 0) {\n        const temp = +(num1[p1] ?? 0) + +(num2[p2] ?? 0) + carry;\n        carry = Math.floor(temp / 10);\n        result = (temp % 10) + result;\n        p1--;\n        p2--;\n    }\n    if(carry === 1) result = 1 + result;\n    console.log(result);\n}()\n"}},function(n,e){n.exports={code58:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = +(await readline()).split(' ').pop();\n    const list = (await readline()).split(' ').map(item => Number.parseInt(item)).sort((a, b) => a - b);\n    console.log(list.slice(0, num).join(' '));\n}()\n"}},function(n,e){n.exports={code59:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline()).split('');\n    const map = new Map();\n    for(const char of str) {\n        map.set(char, (map.get(char) ?? 0) + 1);\n    }\n    const result = [...map.entries()].find(item => item[1] === 1);\n    console.log(result ? result[0] : -1);\n}()\n"}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let num = Number.parseInt(await readline());\n    let str = '';\n    for(let i = 2, len = Math.floor(Math.sqrt(num)); i <= len; i++) {\n        while(num % i === 0) {\n            str += \`${i} \`;\n            num = num / i;\n        }\n    }\n    if(str === '') console.log('' + num);\n    else {\n        if(num !== 1) {\n            str += \`${num}\`;\n        }\n        console.log(str);\n    }\n}()\n\n`;n.exports={code6:t}},function(n,e){n.exports={code60:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nconst map = [];\nfor(let i = 2; i <= 1000; i++) {\n    if(isPrime(i)) map.push(i);\n}\n\nfunction isPrime(n) {\n    for(let i = 2, len = Math.floor(Math.sqrt(n)); i <= len; i++) {\n        if(n % i === 0) return false;\n    }\n    return true;\n}\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    let left = 0, right = map.length - 1, mid = 0;\n    while(left < right) {\n        mid = Math.ceil((left + right) / 2);\n        if(map[mid] <= num) left = mid;\n        else right = mid - 1;\n    }\n    const list = map.slice(0, left + 1);\n    const len = list.length;\n    const map2 = new Map();\n    let result = [-Infinity, Infinity];\n    for(let i = 0; i < len; i++) {\n        map2.set(list[i], true);\n    }\n    for(let i = 0; i < len; i++) {\n        const temp = num - list[i];\n        if(map2.get(temp) !== undefined) {\n            result = Math.abs(list[i] - temp) < (result[1] - result[0]) ? [list[i], temp] : result;\n        }\n    }\n    console.log(result[0]);\n    console.log(result[1]);\n}()\n'}},function(n,e){n.exports={code62:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    while(num = Number.parseInt(await readline())) {\n        let cnt = 0;\n        while(num) {\n            (num & 1) && cnt++;\n            num = num >> 1;\n        }\n        console.log(cnt);\n    }\n}()\n'}},function(n,e){n.exports={code63:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const num = Number.parseInt(await readline());\n    let start = 0, cnt = 0, max = 0;\n    const result = [0, num - 1];\n    for(let i = 0; i < num; i++) {\n        if(ifValid(str[i])) cnt++;\n    }\n    max = cnt;\n    for(let i = 1, len = str.length - num; i <= len; i++) {\n        cnt += (ifValid(str[i - 1]) ? -1 : 0) + (ifValid(str[i + num - 1]) ? 1 : 0);\n        if(cnt > max) {\n            result[0] = i;\n            result[1] = i + num - 1;\n            max = cnt;\n        }\n    }\n    console.log(str.slice(result[0], result[1] + 1));\n\n    function ifValid(char) {\n        return ['G', 'C'].includes(char);\n    }\n}()\n"}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const map = [\n        'reset board', \n        'board add', \n        'board delete',\n        'reboot backplane',\n        'backplane abort',\n    ];\n    const map2 = {\n        'reset board': 'board fault',\n        'board add': 'where to add', \n        'board delete': 'no board at all',\n        'reboot backplane': 'impossible',\n        'backplane abort': 'install first',\n    }\n    while(command = await readline()){\n        console.log(matchCommand(command));\n    }\n\n    function matchCommand(command) {\n        command = command.split(' ');\n        if(command.length === 1) {\n            return 'reset'.includes(command[0]) ? 'reset what' : 'unknown command';\n        } else if(command.length === 2) {\n            const reg = new RegExp(\`^${command[0]}.*? ${command[1]}.*$\`);\n            const res = map.filter(item => reg.test(item));\n            if(res.length === 1) {\n                return map2[res[0]];\n            } else {\n                return 'unknown command';\n            }\n        }\n    }\n}()\n`;n.exports={code66:t}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    const method = Number.parseInt(await readline()) ? (a, b) => a.score - b.score : (a, b) => b.score - a.score;\n    const people = [];\n    while(line = await readline()){\n        const [name, score] = line.split(" ");\n        people.push({\n            name,\n            score: Number.parseInt(score)\n        });\n    }\n    people.sort(method);\n    for(const item of people) {\n        console.log(\`${item.name} ${item.score}\`);\n    }\n}()\n`;n.exports={code68:t}},function(n,e){n.exports={code69:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let row1 = Number.parseInt(await readline());\n    let row2 = Number.parseInt(await readline());\n    let column = await readline();\n    const matrix1 = [];\n    const matrix2 = [];\n    let copyrow1 = row1;\n    let copyrow2 = row2;\n    while(copyrow1){\n        matrix1.push((await readline()).split(' ').map(item => Number.parseInt(item)));\n        copyrow1--;\n    };\n    while(copyrow2){\n        matrix2.push((await readline()).split(' ').map(item => Number.parseInt(item)));\n        copyrow2--;\n    };\n    const matrix3 = [];\n    for(let i = 0; i < row1; i ++) {\n        matrix3.push(new Array(column).fill(0));\n    }\n    for(let i = 0; i < row1; i++) {\n        const row = matrix1[i];\n        for(let j = 0; j < column; j++) {\n            let res = 0;\n            row.forEach((item, index) => {\n                res += item * matrix2[index][j];\n            });\n            matrix3[i][j] = res;\n        }\n    }\n    for(const row of matrix3) {\n        console.log(row.join(' '));\n    }\n}()\n"}},function(n,e){n.exports={code7:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = (await readline()).split(".");\n    const num = Number.parseInt(str[0]) + (str[1][0] >= 5 ? 1 : 0);\n    console.log(num);\n}()\n'}},function(n,e){n.exports={code70:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let num = Number.parseInt(await readline());\n    const matrix = {};\n    const A = 'A'.charCodeAt();\n    let cnt = 0;\n    while(num){\n        const [row, column] = (await readline()).split(' ').map(item => Number.parseInt(item));\n        matrix[String.fromCharCode(A + cnt)] = {\n            row,\n            column\n        }\n        cnt++;\n        num--;\n    };\n    const str = await readline();\n    const stack = [];\n    for(const char of str) {\n        if(!['(', ')'].includes(char)) {\n            stack.push(char);\n        } else if(char === ')') {\n            const { row: row1, column: column1 } = matrix[stack.pop()];\n            const { row: row2, column: column2 } = matrix[stack.pop()];\n            num += row2 * column2 * column1;\n            const currentChar = String.fromCharCode(A + cnt);\n            matrix[currentChar] = {\n                row: row2,\n                column: column1\n            };\n            stack.push(currentChar);\n            cnt++;\n        }\n    };\n    console.log(num);\n}()\n"}},function(n,e){n.exports={code71:"\n  \n"}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n    // Write your code here\n    const line = Number.parseInt(await readline());\n    for (let i = 0; i <= 20; i++) {\n        for (let j = 0; j <= 33; j++) {\n            for (let k = 1; k <= 100; k++) {\n                if((5 * i + 3 * j + k / 3 === 100) && (i + k + j === 100)) {\n                    console.log(\`${i} ${j} ${k}\`);\n                }\n            }\n        }\n    }\n})();\n`;n.exports={code72:t}},function(n,e){n.exports={code73:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    let [year, month, day] = (await readline()).split(' ').map(item => +item);\n    const monthList = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    ifLeapYear(year) && (monthList[1] = 29);\n    let cnt = 0, idx = 0;\n    while(month > 1) {\n        cnt += monthList[idx];\n        idx++;\n        month--;\n    }\n    console.log(cnt + day);\n\n    function ifLeapYear(n) {\n        if(n % 100 === 0) {\n            return n % 400 === 0;\n        }\n        return n % 4 === 0;\n    }\n}()\n"}},function(n,e){n.exports={code74:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const command = (await readline()) + ' ';\n    const stack = [], result = [];\n    let cnt = 0, flag = false;\n    for(const char of command) {\n        if(char === '\"') {\n            flag = !flag;\n        } else if(char !== ' ') {\n            stack.push(char);\n        } else if(char === ' ') {\n            if(!flag) {\n                result.push(stack.join(''));\n                stack.length = 0;\n            } else {\n                stack.push(char);\n            }\n        }\n    }\n    console.log(result.length);\n    for(const char of result) {\n        console.log(char)\n    }\n}()\n"}},function(n,e){n.exports={code75:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str1 = await readline();\n    const str2 = await readline();\n    let short_str = '', long_str = '';\n    if(str1.length >= str2.length) {\n        long_str = str1;\n        short_str = str2;\n    } else {\n        long_str = str2;\n        short_str = str1;\n    }\n    let maxSubStringLength = 0;\n    for(let start = 0; start < short_str.length; start++) {\n        for(let end = start + 1; end <= short_str.length; end++) {\n            const substr = short_str.slice(start, end);\n            if(long_str.includes(substr)) {\n                maxSubStringLength = Math.max(maxSubStringLength, substr.length);\n            }\n        }\n    }\n    console.log(maxSubStringLength);\n}()\n"}},function(n,e){n.exports={code76:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nconst array = Object.keys(Array.from({ length: 5050 })).map(item => 2 * item + 1);\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    const target = num ** 3;\n    let left = 0, right = num - 1;\n    let sum = array.slice(left, right + 1).reduce((pre, curr) => pre += curr, 0);\n    left++;\n    right++;\n    while(sum !== target) {\n        sum = sum - array[left - 1] + array[right];\n        if(sum === target) break;\n        left++;\n        right++;\n    }\n    console.log(array.slice(left, right + 1).join('+'));\n}()\n"}},function(n,e){n.exports={code77:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    const id = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const copyid = [...id];\n    id.sort((a, b) => a - b);\n\n    const path = [], result = [];\n    recursion();\n    for(const item of result) {\n        console.log(item.join(' '));\n    }\n    function recursion() {\n        if(path.length === num && ifValidStackSequence(copyid, path)) {\n            result.push([...path]);\n        }\n        for(let i = 0; i < num; i++) {\n            if(path.includes(id[i])) continue;\n            path.push(id[i]);\n            recursion();\n            path.pop();\n        }\n    }\n\n    function ifValidStackSequence(origin, stackSequence) {\n        const stack = [];\n        let p1 = 0, p2 = 0;\n        while(p2 < stackSequence.length && p1 < origin.length) {\n            stack.push(origin[p1]);\n            while(stack[stack.length - 1] === stackSequence[p2] && p2 < stackSequence.length) {\n                stack.pop();\n                p2++;\n            }\n            p1++;\n        }\n        return stack.length === 0;\n    }\n}()\n"}},function(n,e){n.exports={code8:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = await readline(), map = {};\n    while(line = await readline()){\n        let tokens = line.split(' ');\n        let a = parseInt(tokens[0]);\n        let b = parseInt(tokens[1]);\n        map[a] = map[a] === undefined ? b : map[a] + b;\n    }\n    for(const [key, value] of Object.entries(map)) {\n        console.log(key, value);\n    }\n}()\n\n"}},function(n,e){n.exports={code80:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num1 = await readline();\n    const list1 = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const num2 = await readline();\n    const list2 = (await readline()).split(' ').map(item => Number.parseInt(item));\n    console.log([...new Set([...list1, ...list2])].sort((a, b) => a - b).join(''));\n}()\n"}},function(n,e){n.exports={code81:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str1 = await readline();\n    const str2 = await readline();\n    const map1 = countLetters(str1);\n    const map2 = countLetters(str2);\n    console.log(Object.entries(map1).sort((a, b) => a[0] - b[0]));\n    console.log(Object.entries(map2).sort((a, b) => a[0] - b[0]));\n    let flag = true;\n    for(const [key, val] of Object.entries(map1)) {\n        if(map2[key] === undefined || map2[key] < val) {\n            flag = false;\n            break;\n        }\n    }\n    console.log('' + flag);\n\n    function countLetters(str) {\n        return str.split('').reduce((pre, curr) => (pre[curr] = (pre[curr] ?? 0) + 1, pre) , {});\n    }\n}()\n"}},function(n,e){n.exports={code84:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = (await readline()).match(/[A-Z]+/g).join('').length;\n    console.log(num)\n}()\n"}},function(n,e){n.exports={code85:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    let max = 0;\n    for(let i = 0; i < str.length; i++) {\n        const len1 = centerExpand(i, i);\n        const len2 = centerExpand(i, i + 1);\n        max = Math.max(max, len1, len2);\n    }\n    console.log(max);\n\n    function centerExpand(left, right) {\n        while(str[left] === str[right] && left >= 0 && right < str.length) {\n            left--;\n            right++;\n        }\n        return (right - 1) - (left + 1) + 1;\n    }\n}()\n'}},function(n,e){n.exports={code86:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline()).toString(2).match(/1+/g);\n    let max = 0;\n    for(const item of num) {\n        max = Math.max(max, item.length);\n    }\n    console.log(max);\n}()\n'}},function(n,e){n.exports={code87:"\n  const rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const passwordLength = [\n        len => len >= 0,\n        len => len >= 5,\n        len => len >= 8\n    ];\n    const passwordLengthScore = [0, 5, 10, 25];\n    const letter = [\n        str => /[a-zA-Z]/.test(str),\n        str => /^((?=.*[a-z])|(?=.*[A-Z]))/.test(str),\n        str => /^(?=.*[a-z])(?=.*[A-Z])/.test(str),\n    ];\n    const letterScore = [0, 10, 10, 20];\n    const number = [\n        str => /d/.test(str),\n        str => /d/.test(str),\n        str => /d.*?d/.test(str),\n    ];\n    const numberSocre = [0, 0, 10, 20];\n    const symbol = [\n        str => /[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]/.test(str),\n        str => /[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]/.test(str),\n        str => /[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~].*[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]/.test(str),\n    ];\n    const symbolSocre = [0, 0, 10, 25];\n    const prize = [\n        str => /^(?=.*[a-zA-Z])(?=.*[0-9])/.test(str),\n        str => /^(?=.*[a-zA-Z])(?=.*[0-9])(?=.*[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~])/.test(str),\n        str => /^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~])/.test(str),\n    ];\n    const prizeScore = [0, 2, 3, 5];\n    let score = 0;\n    score += passwordLengthScore[passwordLength.filter(fn => fn(str.length)).length];\n    score += letterScore[letter.filter(fn => fn(str)).length];\n    score += numberSocre[number.filter(fn => fn(str)).length];\n    score += symbolSocre[symbol.filter(fn => fn(str)).length];\n    score += prizeScore[prize.filter(fn => fn(str)).length];\n    if(score >= 90) console.log('VERY_SECURE');\n    else if(score >= 80) console.log('SECURE');\n    else if(score >= 70) console.log('VERY_STRONG');\n    else if(score >= 60) console.log('STRONG');\n    else if(score >= 50) console.log('AVERAGE');\n    else if(score >= 25) console.log('WEAK');\n    else if(score >= 0) console.log('VERY_WEAK');\n}()\n"}},function(n,e){n.exports={code9:'\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = await readline();\n    const result = [...new Set(num.split("").reverse())].join("");\n    console.log(result);\n}()\n\n'}},function(n,e){n.exports={code90:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const ip = (line = await readline()).split('.');\n    const flag = ip.every(item => /^(1[0-9][0-9])$|^(2([0-4][0-9]|5[0-5]))$|^([1-9][0-9])$|^[0-9]$/.test(item));\n    console.log(ip.length === 4 && flag ? 'YES' : 'NO');\n}()\n"}},function(n,e){n.exports={code91:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const [row, column] = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const dp = [];\n    for(let i = 0; i <= row; i++) {\n        dp.push([]);\n        for(let j = 0; j <= column; j++) {\n            if(i === 0 || j === 0) dp[i][j] = 1;\n            else dp[i][j] = 0;\n        }\n    }\n    for(let i = 1; i <= row; i++) {\n        for(let j = 1; j <= column; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    console.log(dp[row][column])\n}()\n"}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    while(line = await readline()) {\n        const res = line.match(/d+/g);\n        res.sort((a, b) => b.length - a.length);\n        let p = 0;\n        for(let i = 1; i < res.length; i++) {\n            if(res[i].length === res[0].length) {\n                p = i;\n            } else {\n                break;\n            }\n        }\n        console.log(\`${res.slice(0,p+1).join("")},${res[0].length}\`);\n    }\n}()\n`;n.exports={code92:t}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num1 = Number.parseInt(await readline());\n    const type1 = (await readline()).split(' ');\n    const num2 = Number.parseInt(await readline());\n    const type2 = (await readline()).split(' ');\n\n    const map = {};\n    type1.forEach(item => map[item] = 0);\n    map['Invalid'] = 0;\n    type2.forEach(item => map[item] !== undefined ? map[item]++ : map['Invalid']++);\n    for(const [key, val] of Object.entries(map)) {\n        console.log(\`${key} : ${val}\`);\n    }\n}()\n`;n.exports={code94:t}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const str = await readline();\n    const res = str.replaceAll(/d+/g, val => \`*${val}*\`);\n    console.log(res);\n}()\n`;n.exports={code96:t}},function(n,e){const t=`\nconst rl = require("readline").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    const list = (await readline()).split(' ').map(item => Number.parseInt(item));\n    const negativeNumber = [];\n    const positiveNumber = [];\n    for(const item of list) {\n        if(item > 0) positiveNumber.push(item);\n        else if(item < 0) negativeNumber.push(item);\n    }\n    let average = positiveNumber.length !== 0 ? positiveNumber.reduce((pre, curr) => pre += curr, 0) / positiveNumber.length : 0;\n    console.log(\`${negativeNumber.length} ${average.toFixed(1)}\`);\n}()\n`;n.exports={code97:t}},function(n,e){n.exports={code99:"\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid async function () {\n    // Write your code here\n    const num = Number.parseInt(await readline());\n    let cnt = 0;\n    for(let i = 0; i <= num; i++) {\n        isSelfControlledNumber(i) && cnt++;\n    }\n    console.log(cnt);\n\n    function isSelfControlledNumber(n) {\n        return (n * n + '').endsWith(n);\n    }\n}()\n"}},function(n,e){n.exports={code1019:"\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {number[]}\n */\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nconst list = new LinkedListHelper([2, 7, 4, 3, 5]).getNthNode();\n\nfunction nextLargerNodes(head) {\n  let node1 = head;\n  const result = [];\n  while (node1) {\n    let node2 = node1.next;\n    let val = node1.val, flag = false;\n    while (node2) {\n      if (node2.val > val) {\n        flag = true;\n        break;\n      }\n      node2 = node2.next;\n    }\n    result.push(flag ? node2.val : 0);\n    node1 = node1.next;\n  }\n  return result;\n};\n\nconsole.log(nextLargerNodes(list));\n"}},function(n,e){n.exports={code1207:"\n/**\n * @param {number[]} arr\n * @return {boolean}\n */\n\nfunction uniqueOccurrences(arr) {\n  const map = new Map();\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    const res = map.get(item);\n    map.set(item, (res ?? 0) + 1);\n  }\n  const nums = [...map.values()];\n  return new Set(nums).size === nums.length;\n};\n\nconsole.log(uniqueOccurrences([1, 2, 2, 1, 1, 3]));\n"}},function(n,e){n.exports={code1657:'\n/**\n * @param {string} word1\n * @param {string} word2\n * @return {boolean}\n */\n\nfunction calcLetters(str) {\n  const map = new Map(), len = str.length;\n  for (let i = 0; i < len; i++) {\n    const res = map.get(str[i]);\n    map.set(str[i], (res ?? 0) + 1);\n  }\n  const map1 = new Map();\n  for (const [char, num] of map.entries()) {\n    const res = map1.get(num);\n    res === undefined ? map1.set(num, [char]) : res.push(char);\n  }\n  return [map, map1];\n}\n\nfunction closeStrings(word1, word2) {\n  if (word1.length !== word2.length) return false;\n  const [map1, map2] = calcLetters(word1), [map3, map4] = calcLetters(word2);\n  for (const [char, num] of map1.entries()) {\n    if (map3.get(char) === undefined) return false;\n  }\n  for (const [num, letters] of map2.entries()) {\n    if (map4.get(num)?.length !== letters.length) return false;\n  }\n  return true;\n};\n\nconsole.log(closeStrings("aabbcccddd", "abccccdddd"));\n'}},function(n,e){n.exports={code1663:"\n/**\n * @param {number} n\n * @param {number} k\n * @return {string}\n */\n\nfunction getSmallestString(n, k) {\n  let result = '', rest = n;\n  for (let i = 1; i <= n; i++) {\n    if (k - 1 > (n - i) * 26) break;\n    result += 'a';\n    k--;\n    rest--;\n  }\n  let num = Math.floor(k / 26);\n  let code = 97 + k - num * 26 - 1;\n  return result + (code < 97 ? '' : String.fromCharCode(97 + k - num * 26 - 1)) + 'z'.repeat(num);\n};\n\nconsole.log(getSmallestString(5, 130));\n"}},function(n,e){n.exports={code1664:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction waysToMakeFair(nums) {\n  let result = 0, prefixSum = [], len = nums.length, last = len - 1;\n  for (let i = 0; i < len; i++) {\n    prefixSum[i] = (prefixSum[i - 2] ?? 0) + nums[i];\n  }\n  const lastEven = len % 2 === 0 ? get(last - 1) : get(last);\n  const lastOdd = len % 2 === 1 ? get(last - 1) : get(last);\n  for (let i = 0; i < len; i++) {\n    let oddSum = 0, evenSum = 0;\n    if (i % 2 === 0) {\n      oddSum = get(i - 1) + lastEven - get(i);\n      evenSum = get(i - 2) + lastOdd - get(i - 1);\n    } else {\n      oddSum = get(i - 2) + lastEven - get(i - 1);\n      evenSum = get(i - 1) + lastOdd - get(i);\n    }\n    oddSum === evenSum && result++;\n  }\n  return result;\n\n  function get(i) {\n    return prefixSum[i] ?? 0;\n  }\n};\n\nconsole.log(waysToMakeFair([1]));\n"}},function(n,e){n.exports={code1669:"\n/**\n * @param {ListNode} list1\n * @param {number} a\n * @param {number} b\n * @param {ListNode} list2\n * @return {ListNode}\n */\n\nimport { LinkedListHelper } from '@karl_fang/data-structure';\nconst list1 = new LinkedListHelper([0, 1, 2, 3, 4, 5]).getNthNode();\nconst list2 = new LinkedListHelper([1000000, 1000001, 1000002]).getNthNode();\n\nfunction ListNode(val, next) {\n  this.val = (val === undefined ? 0 : val)\n  this.next = (next === undefined ? null : next)\n}\n\nfunction mergeInBetween(list1, a, b, list2) {\n  const head = new ListNode('head', list1);\n  let cnt = -1, currentNode = head, start = null, end = null;\n  while (currentNode) {\n    if (cnt + 1 === a) start = currentNode;\n    else if (cnt === b) {\n      end = currentNode;\n      break;\n    }\n    currentNode = currentNode.next;\n    cnt++;\n  }\n  start.next = list2;\n  currentNode = list2;\n  while (currentNode.next) currentNode = currentNode.next;\n  currentNode.next = end.next;\n  return head.next;\n};\n\nLinkedListHelper.LinkedListToString(mergeInBetween(list1, 3, 4, list2));\n"}},function(n,e){n.exports={code1802:"\n/**\n * @param {number} n\n * @param {number} index\n * @param {number} maxSum\n * @return {number}\n */\n\nfunction calcSum(space, num) {\n  if (num === 0) return 0;\n  return space >= num ? (num + 1) * num / 2 + space - num : (num * 2 - space + 1) * space / 2 ;\n}\n\nfunction maxValue(n, index, maxSum) {\n  let left = 1, right = maxSum, mid;\n  while (left < right) {\n    mid = Math.ceil((left + right) / 2);\n    if (calcSum(index, mid - 1) + calcSum(n - index, mid) <= maxSum) left = mid;\n    else right = mid - 1;\n  }\n  return left;\n};\n\nconsole.log(maxValue(1, 0, 780055968));\n"}},function(n,e){n.exports={code1807:'\n/**\n * @param {string} s\n * @param {string[][]} knowledge\n * @return {string}\n */\n\nfunction evaluate(s, knowledge) {\n  const map = new Map(knowledge);\n  return s.replace(/((.*?))/g, word => map.get(word.slice(1, -1)) ?? \'?\');\n};\n\nconsole.log(evaluate("(name)is(age)yearsold", [["a","b"]]));\n'}},function(n,e){n.exports={code1813:'\n/**\n * @param {string} sentence1\n * @param {string} sentence2\n * @return {boolean}\n */\n\nfunction areSentencesSimilar(sentence1, sentence2) {\n  const list1 = sentence1.split(" ");\n  const list2 = sentence2.split(" ");\n  let i = 0, j = 0, minLen = Math.min(list1.length, list2.length);\n  while (i < minLen && list1[i] === list2[i]) i++;\n  while (j < minLen && minLen - j - 1 >= i && list1[list1.length - j - 1] === list2[list2.length - j - 1]) j++;\n  return i + j === minLen;\n};\n\nconsole.log(areSentencesSimilar("My name is Haley", "My Haley"));\n'}},function(n,e){n.exports={code1814:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction countNicePairs(nums) {\n  const MAX = 1e9 + 7, map = new Map(), len = nums.length;\n  for (let i = 0; i < len; i++) {\n    const res = calc(nums[i]);\n    map.set(res, (map.get(res) ?? 0) + 1);\n  }\n  return [...map.values()].reduce((pre, curr) => pre += (curr - 1) * curr / 2, 0) % MAX;\n};\n\nfunction calc(nums) {\n  return nums - ('' + nums).split('').reverse().join('');\n}\n\nconsole.log(countNicePairs([42, 11, 1, 97]));\n"}},function(n,e){n.exports={code1817:"\n/**\n * @param {number[][]} logs\n * @param {number} k\n * @return {number[]}\n */\n\nfunction findingUsersActiveMinutes(logs, k) {\n  const map1 = new Map(), map2 = new Map(), result = [];\n  for (let i = 0, len = logs.length; i < len; i++) {\n    const [id, time] = logs[i], temp = map1.get(id);\n    temp === undefined ? map1.set(id, new Set([time])) : temp.add(time);\n  }\n  [...map1.entries()].forEach(item => {\n    const size = item[1].size, temp = map2.get(size);\n    map2.set(size, (temp ?? 0) + 1);\n  })\n  for (let i = 0; i < k; i++) {\n    result[i] = map2.get(i + 1) ?? 0;\n  }\n  return result;\n};\n\nconsole.log(findingUsersActiveMinutes([[0, 5], [1, 2], [0, 2], [0, 5], [1, 3]], 5));\n"}},function(n,e){n.exports={code1828:"\n/**\n * @param {number[][]} points\n * @param {number[][]} queries\n * @return {number[]}\n */\n\nfunction square(n) {\n  return Math.pow(n, 2);\n}\n\nfunction calcDistance(p1, center) {\n  return square(p1[0] - center[0]) + square(p1[1] - center[1]) <= square(center[2]);\n}\n\nfunction countPoints(points, queries) {\n  const result = new Array(queries.length).fill(0);\n  for (let i = 0, len1 = queries.length; i < len1; i++) {\n    for (let j = 0, len2 = points.length; j < len2; j++) {\n      const num = result[i];\n      result[i] = calcDistance(points[j], queries[i]) ? num + 1 : num;\n    }\n  }\n  return result;\n};\n\nconsole.log(countPoints([[1, 3], [3, 3], [5, 3], [2, 2]], [[2, 3, 1], [4, 3, 1], [1, 1, 2]]));\n"}},function(n,e){n.exports={code209:"\n/**\n * @param {number} target\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction minSubArrayLen(target, nums) {\n  const idx = nums.length - 1;\n  let p1 = 0, p2 = 0, sum = 0, result = Infinity;\n  while (p1 <= idx) {\n    while (p2 <= idx && sum < target) {\n      sum += nums[p2];\n      p2++;\n    }\n    if (sum >= target) {\n      result = Math.min(result, p2 - p1);\n    }\n    sum -= nums[p1];\n    p1++;\n  }\n  return result === Infinity ? 0 : result;\n};\n\nconsole.log(minSubArrayLen(7, [2, 3, 1, 2, 4, 3]));\n"}},function(n,e){n.exports={code2149:"\n/**\n * @param {number[]} nums\n * @return {number[]}\n*/\n\nfunction rearrangeArray(nums) {\n  const result = [], negative = [], positive = [], len = nums.length / 2;\n  for (let i = 0, len = nums.length; i < len; i++) {\n    const item = nums[i];\n    if (item > 0) positive.push(item);\n    else negative.push(item);\n  }\n  let p = 0;\n  while (p < len) {\n    result.push(positive[p], negative[p]);\n    p++;\n  }\n  return result;\n};\n\nconsole.log(rearrangeArray([3, 1, -2, -5, 2, -4]));\n"}},function(n,e){n.exports={code2180:"\n/**\n * @param {number} num\n * @return {number}\n */\n\nfunction calcSum(num) {\n  let result = 0;\n  while (num) {\n    result += num % 10;\n    num = Math.floor(num / 10);\n  }\n  return result;\n}\n\nfunction countEven(num) {\n  let result = 0;\n  for (let i = 1; i <= num; i++) {\n    calcSum(i) % 2 === 0 && result++;\n  }\n  return result;\n};\n\nconsole.log(countEven(30));\n"}},function(n,e){const t=`\n/**\n * @param {number[]} nums\n * @return {string[]}\n */\n\nfunction summaryRanges(nums) {\n  let result = [], left = 0, right = 0, len = nums.length;\n  while (right < len) {\n    while (nums[left] + right - left === nums[right]) right++;\n    result.push(left === right - 1 ? \`${nums[left]}\` : \`${nums[left]}->${nums[right-1]}\`);\n    left = right;\n  }\n  return result;\n};\n\nconsole.log(summaryRanges([0, 1, 2, 4, 5, 7]));\n`;n.exports={code228:t}},function(n,e){n.exports={code2287:'\n/**\n * @param {string} s\n * @param {string} target\n * @return {number}\n */\n\nfunction countChar(str) {\n  const map = {};\n  for (const char of str) {\n    map[char] = map[char] === undefined ? 1 : map[char] + 1;\n  }\n  return map;\n}\n\nfunction rearrangeCharacters(s, target) {\n  const map1 = countChar(s), map2 = countChar(target);\n  let result = Infinity;\n  Object.keys(map2).forEach(char => {\n    map2[char] = Math.floor((map1[char] ?? 0) / map2[char]);\n    result = Math.min(result, map2[char]);\n  })\n  return result;\n};\n\nconsole.log(rearrangeCharacters("a", "hhexd"));\n'}},function(n,e){n.exports={code2293:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction minMaxGame(nums) {\n  return nums.length === 1 ? nums[0] : recursion(nums, 'min');\n\n  function recursion(nums, tag) {\n    const len = nums.length;\n    if (len === 2) {\n      return Math[tag](...nums);\n    }\n\n    return Math[tag](\n      recursion(nums.slice(0, len / 2), 'min'),\n      recursion(nums.slice(len / 2), 'max')\n    )\n  }\n};\n\nconsole.log(minMaxGame([70, 38, 21, 22]));\n"}},function(n,e){throw new Error("Module build failed (from ./node_modules/babel-loader/lib/index.js):\nSyntaxError: /Users/karl/Documents/vuePress/leetcode/docs/.vuepress/public/leetcode/面试练习/2299. 强密码检验器 II.js: Invalid escape sequence in template. (1:19)\n\n[0m[31m[1m>[22m[39m[90m 1 |[39m [36mconst[39m code2299 [33m=[39m [32m`[39m[0m\n[0m [90m   |[39m                    [31m[1m^[22m[39m[0m\n[0m [90m 2 |[39m [32m/**[39m[0m\n[0m [90m 3 |[39m [32m * @param {string} password[39m[0m\n[0m [90m 4 |[39m [32m * @return {boolean}[39m[0m\n    at instantiate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:72:32)\n    at constructor (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:359:12)\n    at Parser.raise (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:3339:19)\n    at Parser.parseTemplateElement (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13539:14)\n    at Parser.parseTemplate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13562:23)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:13017:21)\n    at Parser.parseExprAtom (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:8039:20)\n    at Parser.parseExprSubscripts (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12648:23)\n    at Parser.parseUpdate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12627:21)\n    at Parser.parseMaybeUnary (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12598:23)\n    at Parser.parseMaybeUnaryOrPrivate (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12392:61)\n    at Parser.parseExprOps (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12399:23)\n    at Parser.parseMaybeConditional (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12369:23)\n    at Parser.parseMaybeAssign (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12321:21)\n    at /Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:12279:39\n    at Parser.allowInAnd (/Users/karl/Documents/vuePress/leetcode/node_modules/@babel/parser/lib/index.js:14346:16)")},function(n,e){n.exports={code2303:"\n/**\n * @param {number[][]} brackets\n * @param {number} income\n * @return {number}\n */\n\nfunction calculateTax(brackets, income) {\n  let result = 0, preUpper = 0;\n  for (let i = 0, len = brackets.length; i < len; i++) {\n    const [upper, percent] = brackets[i];\n    if (income <= upper) {\n      result += (income - preUpper) * percent;\n      return result / 100;\n    } else {\n      result += (upper - preUpper) * percent;\n      preUpper = upper;\n    }\n  }\n};\n\nconsole.log(calculateTax([[3, 50], [7, 10], [12, 25]], 10));\n"}},function(n,e){n.exports={code2309:"\n/**\n * @param {string} s\n * @return {string}\n */\n\nfunction greatestLetter(s) {\n  let result = '';\n  const map = new Map();\n  for (let i = 0, len = s.length; i < len; i++) {\n    const code = s[i].charCodeAt();\n    map.set(s[i], true);\n    if (code >= 65 && code <= 90) {\n      const temp = map.get(String.fromCharCode(code + 32));\n      if (temp && (result.charCodeAt() < code || result === '')) {\n        result = s[i];\n      }\n    }\n    if (code >= 97 && code <= 122) {\n      const temp = map.get(String.fromCharCode(code - 32));\n      if (temp && (result.charCodeAt() < code - 32 || result === '')) {\n        result = s[i].toUpperCase();\n      }\n    }\n  }\n  return result;\n};\n\nconsole.log(greatestLetter(\"AbCdEfGhIjK\"));\n"}},function(n,e){n.exports={code2315:"\n/**\n * @param {string} s\n * @return {number}\n */\n\nfunction countAsterisks(s) {\n  let result = 0, flag = true;\n  for (const char of s) {\n    if (flag && char === '*') result++;\n    else if (char === '|') flag = !flag;\n  }\n  return result;\n};\n\nconsole.log(countAsterisks(\"**l|*e*et|c**o|*de|\"));\n"}},function(n,e){n.exports={code2319:"\n/**\n * @param {number[][]} grid\n * @return {boolean}\n */\n\nfunction checkXMatrix(grid) {\n  for (let i = 0, row = grid.length; i < row; i++) {\n    for (let j = 0, column = grid[0].length; j < column; j++) {\n      const item = grid[i][j];\n      if (i === j || i + j === column - 1) {\n        if (item === 0) return false;\n      } else {\n        if (item !== 0) return false;\n      }\n    }\n  }\n  return true;\n};\n\nconsole.log(checkXMatrix([[2, 0, 0, 1], [0, 3, 1, 0], [0, 5, 2, 0], [4, 0, 0, 2]]));\n"}},function(n,e){n.exports={code2325:"\n/**\n * @param {string} key\n * @param {string} message\n * @return {string}\n */\n\nfunction decodeMessage(key, message) {\n  const set = [...new Set(key.replace(/s*/g, ''))];\n  const map = new Map();\n  let start = 97, result = [];\n  for (let i = 0, len = set.length; i < len; i++, start++) {\n    map.set(set[i], String.fromCharCode(start));\n  }\n  for (let i = 0, len = message.length; i < len; i++) {\n    const char = message[i];\n    result[i] = char === ' ' ? ' ' : map.get(char);\n  }\n  return result.join('');\n};\n\nconsole.log(decodeMessage(\"the quick brown fox jumps over the lazy dog\", \"vkbs bs t suepuv\"));\n"}},function(n,e){n.exports={code326:"\n/**\n * @param {number} n\n * @return {boolean}\n */\n\nfunction isPowerOfThree(n) {\n  if (n === 0) return false;\n  while (n !== 1) {\n    n /= 3;\n    if (!Number.isInteger(n)) return false;\n  }\n  return true;\n};\n\nconsole.log(isPowerOfThree(1));\n"}},function(n,e){n.exports={code42:"\n/**\n * @param {number[]} height\n * @return {number}\n */\n\nfunction trap(height) {\n  const array1 = [], array2 = [], len = height.length - 1;\n  let temp1 = -Infinity, temp2 = -Infinity, result = 0;\n  for (let i = 0; i <= len; i++) {\n    temp1 = Math.max(temp1, height[i]);\n    array1[i] = temp1;\n    temp2 = Math.max(temp2, height[len - i]);\n    array2[len - i] = temp2;\n  }\n  for (let i = 0; i <= len; i++) {\n    result += Math.min(array1[i], array2[i]) - height[i];\n  }\n  return result;\n};\n\nconsole.log(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]));\n"}},function(n,e){n.exports={code705:"\nvar MyHashSet = function () {\n  this.index = 0;\n  this.set = [];\n  this.indexMap = {}\n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.add = function (key) {\n  if (this.indexMap[key] === undefined) {\n    this.set[this.index] = key;\n    this.indexMap[key] = this.index;\n    this.index++;\n  }\n};\n\n/** \n * @param {number} key\n * @return {void}\n */\nMyHashSet.prototype.remove = function (key) {\n  const idx = this.indexMap[key];\n  if (idx !== undefined) {\n    this.set[this.index] = undefined;\n    delete this.indexMap[key];\n  }\n};\n\n/** \n * @param {number} key\n * @return {boolean}\n */\nMyHashSet.prototype.contains = function (key) {\n  return this.indexMap[key] !== undefined;\n};\n\n/**\n * Your MyHashSet object will be instantiated and called as such:\n * var obj = new MyHashSet()\n * obj.add(key)\n * obj.remove(key)\n * var param_3 = obj.contains(key)\n */\nconst myHashSet = new MyHashSet();\nmyHashSet.add(1);      // set = [1]\nmyHashSet.add(2);      // set = [1, 2]\nconsole.log(myHashSet.contains(1)); // 返回 True\nconsole.log(myHashSet.contains(3)); // 返回 False ，（未找到）\nmyHashSet.add(2);      // set = [1, 2]\nconsole.log(myHashSet.contains(2)); // 返回 True\nmyHashSet.remove(2);   // set = [1]\nconsole.log(myHashSet.contains(2)); // 返回 False ，（已移除）\n"}},function(n,e){n.exports={code747:"\n/**\n * @param {number[]} nums\n * @return {number}\n */\n\nfunction dominantIndex(nums) {\n  let result = 0, max = 0, index = 0;\n  for (let i = 0, len = nums.length; i < len; i++) {\n    const item = nums[i];\n    if (item > max) {\n      max = item;\n      index = i;\n    }\n  }\n  for (let i = 0, len = nums.length; i < len; i++) {\n    const item = nums[i];\n    if (item === max) continue;\n    if (max / item < 2) return -1;\n  }\n  return index;\n};\n\nconsole.log(dominantIndex([3]));\n"}},function(n,e){n.exports={code860:"\n/**\n * @param {number[]} bills\n * @return {boolean}\n */\n\nfunction lemonadeChange(bills) {\n  let fiveDollarnums = 0, tenDollarnums = 0;\n  for (i = 0, len = bills.length; i < len; i++) {\n    const bill = bills[i];\n    if (bill === 5) fiveDollarnums++;\n    else if (bill === 10) {\n      if (fiveDollarnums >= 1) {\n        fiveDollarnums--;\n        tenDollarnums++;\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      if (fiveDollarnums >= 1 && tenDollarnums >= 1) {\n        fiveDollarnums--;\n        tenDollarnums--;\n      } else if (fiveDollarnums >= 3) {\n        fiveDollarnums -= 3;\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\nconsole.log(lemonadeChange([5, 5, 10, 10, 20]));\n"}},function(n,e){n.exports={code866:"\n// 首先利用程序生成全部结果\nfunction isPrime(n) {\n  for (let i = 2, max = Math.sqrt(n); i <= max; i++) {\n    if (n % i === 0) return false;\n  }\n  return true;\n}\n\nfunction isPalindrome(n) {\n  n = String(n);\n  return n.split('').reverse().join('') === n;\n}\n\nfunction get() {\n  const UPPER = 2e8;\n  const result = [];\n  for (let i = 2; i <= UPPER; i++) {\n    if (isPrime(i) && isPalindrome(i)) result.push(i);\n  }\n  return result;\n}\n\n/**\n * @param {number} n\n * @return {number}\n */\nfunction primePalindrome(n) {\n  const map = [\n    2,\n    3,\n    5,\n    7,\n    11,\n    101,\n    131,\n    151,\n    181,\n    191,\n    313,\n    353,\n    373,\n    383,\n    727,\n    757,\n    787,\n    797,\n    919,\n    929,\n    10301,\n    10501,\n    10601,\n    11311,\n    11411,\n    12421,\n    12721,\n    12821,\n    13331,\n    13831,\n    13931,\n    14341,\n    14741,\n    15451,\n    15551,\n    16061,\n    16361,\n    16561,\n    16661,\n    17471,\n    17971,\n    18181,\n    18481,\n    19391,\n    19891,\n    19991,\n    30103,\n    30203,\n    30403,\n    30703,\n    30803,\n    31013,\n    31513,\n    32323,\n    32423,\n    33533,\n    34543,\n    34843,\n    35053,\n    35153,\n    35353,\n    35753,\n    36263,\n    36563,\n    37273,\n    37573,\n    38083,\n    38183,\n    38783,\n    39293,\n    70207,\n    70507,\n    70607,\n    71317,\n    71917,\n    72227,\n    72727,\n    73037,\n    73237,\n    73637,\n    74047,\n    74747,\n    75557,\n    76367,\n    76667,\n    77377,\n    77477,\n    77977,\n    78487,\n    78787,\n    78887,\n    79397,\n    79697,\n    79997,\n    90709,\n    91019,\n    93139,\n    93239,\n    93739,\n    94049,\n    94349,\n    94649,\n    94849,\n    94949,\n    95959,\n    96269,\n    96469,\n    96769,\n    97379,\n    97579,\n    97879,\n    98389,\n    98689,\n    1003001,\n    1008001,\n    1022201,\n    1028201,\n    1035301,\n    1043401,\n    1055501,\n    1062601,\n    1065601,\n    1074701,\n    1082801,\n    1085801,\n    1092901,\n    1093901,\n    1114111,\n    1117111,\n    1120211,\n    1123211,\n    1126211,\n    1129211,\n    1134311,\n    1145411,\n    1150511,\n    1153511,\n    1160611,\n    1163611,\n    1175711,\n    1177711,\n    1178711,\n    1180811,\n    1183811,\n    1186811,\n    1190911,\n    1193911,\n    1196911,\n    1201021,\n    1208021,\n    1212121,\n    1215121,\n    1218121,\n    1221221,\n    1235321,\n    1242421,\n    1243421,\n    1245421,\n    1250521,\n    1253521,\n    1257521,\n    1262621,\n    1268621,\n    1273721,\n    1276721,\n    1278721,\n    1280821,\n    1281821,\n    1286821,\n    1287821,\n    1300031,\n    1303031,\n    1311131,\n    1317131,\n    1327231,\n    1328231,\n    1333331,\n    1335331,\n    1338331,\n    1343431,\n    1360631,\n    1362631,\n    1363631,\n    1371731,\n    1374731,\n    1390931,\n    1407041,\n    1409041,\n    1411141,\n    1412141,\n    1422241,\n    1437341,\n    1444441,\n    1447441,\n    1452541,\n    1456541,\n    1461641,\n    1463641,\n    1464641,\n    1469641,\n    1486841,\n    1489841,\n    1490941,\n    1496941,\n    1508051,\n    1513151,\n    1520251,\n    1532351,\n    1535351,\n    1542451,\n    1548451,\n    1550551,\n    1551551,\n    1556551,\n    1557551,\n    1565651,\n    1572751,\n    1579751,\n    1580851,\n    1583851,\n    1589851,\n    1594951,\n    1597951,\n    1598951,\n    1600061,\n    1609061,\n    1611161,\n    1616161,\n    1628261,\n    1630361,\n    1633361,\n    1640461,\n    1643461,\n    1646461,\n    1654561,\n    1657561,\n    1658561,\n    1660661,\n    1670761,\n    1684861,\n    1685861,\n    1688861,\n    1695961,\n    1703071,\n    1707071,\n    1712171,\n    1714171,\n    1730371,\n    1734371,\n    1737371,\n    1748471,\n    1755571,\n    1761671,\n    1764671,\n    1777771,\n    1793971,\n    1802081,\n    1805081,\n    1820281,\n    1823281,\n    1824281,\n    1826281,\n    1829281,\n    1831381,\n    1832381,\n    1842481,\n    1851581,\n    1853581,\n    1856581,\n    1865681,\n    1876781,\n    1878781,\n    1879781,\n    1880881,\n    1881881,\n    1883881,\n    1884881,\n    1895981,\n    1903091,\n    1908091,\n    1909091,\n    1917191,\n    1924291,\n    1930391,\n    1936391,\n    1941491,\n    1951591,\n    1952591,\n    1957591,\n    1958591,\n    1963691,\n    1968691,\n    1969691,\n    1970791,\n    1976791,\n    1981891,\n    1982891,\n    1984891,\n    1987891,\n    1988891,\n    1993991,\n    1995991,\n    1998991,\n    3001003,\n    3002003,\n    3007003,\n    3016103,\n    3026203,\n    3064603,\n    3065603,\n    3072703,\n    3073703,\n    3075703,\n    3083803,\n    3089803,\n    3091903,\n    3095903,\n    3103013,\n    3106013,\n    3127213,\n    3135313,\n    3140413,\n    3155513,\n    3158513,\n    3160613,\n    3166613,\n    3181813,\n    3187813,\n    3193913,\n    3196913,\n    3198913,\n    3211123,\n    3212123,\n    3218123,\n    3222223,\n    3223223,\n    3228223,\n    3233323,\n    3236323,\n    3241423,\n    3245423,\n    3252523,\n    3256523,\n    3258523,\n    3260623,\n    3267623,\n    3272723,\n    3283823,\n    3285823,\n    3286823,\n    3288823,\n    3291923,\n    3293923,\n    3304033,\n    3305033,\n    3307033,\n    3310133,\n    3315133,\n    3319133,\n    3321233,\n    3329233,\n    3331333,\n    3337333,\n    3343433,\n    3353533,\n    3362633,\n    3364633,\n    3365633,\n    3368633,\n    3380833,\n    3391933,\n    3392933,\n    3400043,\n    3411143,\n    3417143,\n    3424243,\n    3425243,\n    3427243,\n    3439343,\n    3441443,\n    3443443,\n    3444443,\n    3447443,\n    3449443,\n    3452543,\n    3460643,\n    3466643,\n    3470743,\n    3479743,\n    3485843,\n    3487843,\n    3503053,\n    3515153,\n    3517153,\n    3528253,\n    3541453,\n    3553553,\n    3558553,\n    3563653,\n    3569653,\n    3586853,\n    3589853,\n    3590953,\n    3591953,\n    3594953,\n    3601063,\n    3607063,\n    3618163,\n    3621263,\n    3627263,\n    3635363,\n    3643463,\n    3646463,\n    3670763,\n    3673763,\n    3680863,\n    3689863,\n    3698963,\n    3708073,\n    3709073,\n    3716173,\n    3717173,\n    3721273,\n    3722273,\n    3728273,\n    3732373,\n    3743473,\n    3746473,\n    3762673,\n    3763673,\n    3765673,\n    3768673,\n    3769673,\n    3773773,\n    3774773,\n    3781873,\n    3784873,\n    3792973,\n    3793973,\n    3799973,\n    3804083,\n    3806083,\n    3812183,\n    3814183,\n    3826283,\n    3829283,\n    3836383,\n    3842483,\n    3853583,\n    3858583,\n    3863683,\n    3864683,\n    3867683,\n    3869683,\n    3871783,\n    3878783,\n    3893983,\n    3899983,\n    3913193,\n    3916193,\n    3918193,\n    3924293,\n    3927293,\n    3931393,\n    3938393,\n    3942493,\n    3946493,\n    3948493,\n    3964693,\n    3970793,\n    3983893,\n    3991993,\n    3994993,\n    3997993,\n    3998993,\n    7014107,\n    7035307,\n    7036307,\n    7041407,\n    7046407,\n    7057507,\n    7065607,\n    7069607,\n    7073707,\n    7079707,\n    7082807,\n    7084807,\n    7087807,\n    7093907,\n    7096907,\n    7100017,\n    7114117,\n    7115117,\n    7118117,\n    7129217,\n    7134317,\n    7136317,\n    7141417,\n    7145417,\n    7155517,\n    7156517,\n    7158517,\n    7159517,\n    7177717,\n    7190917,\n    7194917,\n    7215127,\n    7226227,\n    7246427,\n    7249427,\n    7250527,\n    7256527,\n    7257527,\n    7261627,\n    7267627,\n    7276727,\n    7278727,\n    7291927,\n    7300037,\n    7302037,\n    7310137,\n    7314137,\n    7324237,\n    7327237,\n    7347437,\n    7352537,\n    7354537,\n    7362637,\n    7365637,\n    7381837,\n    7388837,\n    7392937,\n    7401047,\n    7403047,\n    7409047,\n    7415147,\n    7434347,\n    7436347,\n    7439347,\n    7452547,\n    7461647,\n    7466647,\n    7472747,\n    7475747,\n    7485847,\n    7486847,\n    7489847,\n    7493947,\n    7507057,\n    7508057,\n    7518157,\n    7519157,\n    7521257,\n    7527257,\n    7540457,\n    7562657,\n    7564657,\n    7576757,\n    7586857,\n    7592957,\n    7594957,\n    7600067,\n    7611167,\n    7619167,\n    7622267,\n    7630367,\n    7632367,\n    7644467,\n    7654567,\n    7662667,\n    7665667,\n    7666667,\n    7668667,\n    7669667,\n    7674767,\n    7681867,\n    7690967,\n    7693967,\n    7696967,\n    7715177,\n    7718177,\n    7722277,\n    7729277,\n    7733377,\n    7742477,\n    7747477,\n    7750577,\n    7758577,\n    7764677,\n    7772777,\n    7774777,\n    7778777,\n    7782877,\n    7783877,\n    7791977,\n    7794977,\n    7807087,\n    7819187,\n    7820287,\n    7821287,\n    7831387,\n    7832387,\n    7838387,\n    7843487,\n    7850587,\n    7856587,\n    7865687,\n    7867687,\n    7868687,\n    7873787,\n    7884887,\n    7891987,\n    7897987,\n    7913197,\n    7916197,\n    7930397,\n    7933397,\n    7935397,\n    7938397,\n    7941497,\n    7943497,\n    7949497,\n    7957597,\n    7958597,\n    7960697,\n    7977797,\n    7984897,\n    7985897,\n    7987897,\n    7996997,\n    9002009,\n    9015109,\n    9024209,\n    9037309,\n    9042409,\n    9043409,\n    9045409,\n    9046409,\n    9049409,\n    9067609,\n    9073709,\n    9076709,\n    9078709,\n    9091909,\n    9095909,\n    9103019,\n    9109019,\n    9110119,\n    9127219,\n    9128219,\n    9136319,\n    9149419,\n    9169619,\n    9173719,\n    9174719,\n    9179719,\n    9185819,\n    9196919,\n    9199919,\n    9200029,\n    9209029,\n    9212129,\n    9217129,\n    9222229,\n    9223229,\n    9230329,\n    9231329,\n    9255529,\n    9269629,\n    9271729,\n    9277729,\n    9280829,\n    9286829,\n    9289829,\n    9318139,\n    9320239,\n    9324239,\n    9329239,\n    9332339,\n    9338339,\n    9351539,\n    9357539,\n    9375739,\n    9384839,\n    9397939,\n    9400049,\n    9414149,\n    9419149,\n    9433349,\n    9439349,\n    9440449,\n    9446449,\n    9451549,\n    9470749,\n    9477749,\n    9492949,\n    9493949,\n    9495949,\n    9504059,\n    9514159,\n    9526259,\n    9529259,\n    9547459,\n    9556559,\n    9558559,\n    9561659,\n    9577759,\n    9583859,\n    9585859,\n    9586859,\n    9601069,\n    9602069,\n    9604069,\n    9610169,\n    9620269,\n    9624269,\n    9626269,\n    9632369,\n    9634369,\n    9645469,\n    9650569,\n    9657569,\n    9670769,\n    9686869,\n    9700079,\n    9709079,\n    9711179,\n    9714179,\n    9724279,\n    9727279,\n    9732379,\n    9733379,\n    9743479,\n    9749479,\n    9752579,\n    9754579,\n    9758579,\n    9762679,\n    9770779,\n    9776779,\n    9779779,\n    9781879,\n    9782879,\n    9787879,\n    9788879,\n    9795979,\n    9801089,\n    9807089,\n    9809089,\n    9817189,\n    9818189,\n    9820289,\n    9822289,\n    9836389,\n    9837389,\n    9845489,\n    9852589,\n    9871789,\n    9888889,\n    9889889,\n    9896989,\n    9902099,\n    9907099,\n    9908099,\n    9916199,\n    9918199,\n    9919199,\n    9921299,\n    9923299,\n    9926299,\n    9927299,\n    9931399,\n    9932399,\n    9935399,\n    9938399,\n    9957599,\n    9965699,\n    9978799,\n    9980899,\n    9981899,\n    9989899,\n    100030001,\n    100050001,\n    100060001,\n    100111001,\n    100131001,\n    100161001,\n    100404001,\n    100656001,\n    100707001,\n    100767001,\n    100888001,\n    100999001,\n    101030101,\n    101060101,\n    101141101,\n    101171101,\n    101282101,\n    101292101,\n    101343101,\n    101373101,\n    101414101,\n    101424101,\n    101474101,\n    101595101,\n    101616101,\n    101717101,\n    101777101,\n    101838101,\n    101898101,\n    101919101,\n    101949101,\n    101999101,\n    102040201,\n    102070201,\n    102202201,\n    102232201,\n    102272201,\n    102343201,\n    102383201,\n    102454201,\n    102484201,\n    102515201,\n    102676201,\n    102686201,\n    102707201,\n    102808201,\n    102838201,\n    103000301,\n    103060301,\n    103161301,\n    103212301,\n    103282301,\n    103303301,\n    103323301,\n    103333301,\n    103363301,\n    103464301,\n    103515301,\n    103575301,\n    103696301,\n    103777301,\n    103818301,\n    103828301,\n    103909301,\n    103939301,\n    104000401,\n    104030401,\n    104040401,\n    104111401,\n    104222401,\n    104282401,\n    104333401,\n    104585401,\n    104616401,\n    104787401,\n    104838401,\n    104919401,\n    104949401,\n    105121501,\n    105191501,\n    105202501,\n    105262501,\n    105272501,\n    105313501,\n    105323501,\n    105343501,\n    105575501,\n    105616501,\n    105656501,\n    105757501,\n    105818501,\n    105868501,\n    105929501,\n    106060601,\n    106111601,\n    106131601,\n    106191601,\n    106222601,\n    106272601,\n    106353601,\n    106444601,\n    106464601,\n    106545601,\n    106555601,\n    106717601,\n    106909601,\n    106929601,\n    107000701,\n    107070701,\n    107121701,\n    107232701,\n    107393701,\n    107414701,\n    107424701,\n    107595701,\n    107636701,\n    107646701,\n    107747701,\n    107757701,\n    107828701,\n    107858701,\n    107868701,\n    107888701,\n    107939701,\n    107949701,\n    108070801,\n    108101801,\n    108121801,\n    108151801,\n    108212801,\n    108323801,\n    108373801,\n    108383801,\n    108434801,\n    108464801,\n    108484801,\n    108494801,\n    108505801,\n    108565801,\n    108686801,\n    108707801,\n    108767801,\n    108838801,\n    108919801,\n    108959801,\n    109000901,\n    109101901,\n    109111901,\n    109161901,\n    109333901,\n    109404901,\n    109434901,\n    109444901,\n    109474901,\n    109575901,\n    109656901,\n    109747901,\n    109777901,\n    109797901,\n    109818901,\n    109909901,\n    109929901,\n    110111011,\n    110232011,\n    110252011,\n    110343011,\n    110424011,\n    110505011,\n    110565011,\n    110676011,\n    110747011,\n    110757011,\n    110909011,\n    110949011,\n    110999011,\n    111010111,\n    111020111,\n    111050111,\n    111070111,\n    111181111,\n    111191111,\n    111262111,\n    111272111,\n    111454111,\n    111484111,\n    111515111,\n    111616111,\n    111686111,\n    111757111,\n    111848111,\n    112030211,\n    112060211,\n    112111211,\n    112161211,\n    112171211,\n    112212211,\n    112434211,\n    112494211,\n    112545211,\n    112636211,\n    112878211,\n    112959211,\n    112969211,\n    112989211,\n    113030311,\n    113090311,\n    113111311,\n    113262311,\n    113282311,\n    113474311,\n    113535311,\n    113565311,\n    113616311,\n    113636311,\n    113888311,\n    113939311,\n    114040411,\n    114191411,\n    114232411,\n    114353411,\n    114383411,\n    114484411,\n    114494411,\n    114535411,\n    114727411,\n    114808411,\n    114818411,\n    114848411,\n    114878411,\n    114898411,\n    115000511,\n    115020511,\n    115060511,\n    115111511,\n    115141511,\n    115191511,\n    115212511,\n    115222511,\n    115404511,\n    115464511,\n    115545511,\n    115636511,\n    115737511,\n    115767511,\n    115797511,\n    115828511,\n    115959511,\n    116000611,\n    116010611,\n    116040611,\n    116424611,\n    116505611,\n    116646611,\n    116696611,\n    116757611,\n    116777611,\n    116828611,\n    116868611,\n    116919611,\n    117070711,\n    117101711,\n    117262711,\n    117272711,\n    117323711,\n    117484711,\n    117505711,\n    117515711,\n    117616711,\n    117686711,\n    117757711,\n    117767711,\n    117797711,\n    117818711,\n    117959711,\n    118252811,\n    118272811,\n    118414811,\n    118464811,\n    118525811,\n    118626811,\n    118686811,\n    118696811,\n    118717811,\n    118818811,\n    118848811,\n    118909811,\n    118959811,\n    119010911,\n    119171911,\n    119202911,\n    119343911,\n    119363911,\n    119454911,\n    119585911,\n    119595911,\n    119646911,\n    119676911,\n    119696911,\n    119717911,\n    119787911,\n    119868911,\n    119888911,\n    119969911,\n    120191021,\n    120242021,\n    120434021,\n    120454021,\n    120494021,\n    120535021,\n    120565021,\n    120646021,\n    120808021,\n    120868021,\n    120989021,\n    121080121,\n    121111121,\n    121131121,\n    121161121,\n    121272121,\n    121282121,\n    121393121,\n    121414121,\n    121555121,\n    121747121,\n    121818121,\n    121878121,\n    121939121,\n    121989121,\n    122040221,\n    122232221,\n    122262221,\n    122292221,\n    122333221,\n    122363221,\n    122373221,\n    122393221,\n    122444221,\n    122484221,\n    122535221,\n    122696221,\n    122787221,\n    122858221,\n    122919221,\n    123161321,\n    123292321,\n    123424321,\n    123484321,\n    123494321,\n    123575321,\n    123767321,\n    123838321,\n    123989321,\n    124000421,\n    124080421,\n    124101421,\n    124131421,\n    124252421,\n    124323421,\n    124333421,\n    124434421,\n    124515421,\n    124525421,\n    124626421,\n    124656421,\n    124717421,\n    124737421,\n    124959421,\n    124989421,\n    125000521,\n    125010521,\n    125232521,\n    125252521,\n    125292521,\n    125343521,\n    125474521,\n    125505521,\n    125565521,\n    125606521,\n    125616521,\n    125757521,\n    125838521,\n    125939521,\n    125979521,\n    125999521,\n    126101621,\n    126161621,\n    126181621,\n    126202621,\n    126212621,\n    126323621,\n    126424621,\n    126484621,\n    126535621,\n    126595621,\n    126616621,\n    126676621,\n    126686621,\n    126727621,\n    126737621,\n    126757621,\n    126878621,\n    127060721,\n    127090721,\n    127131721,\n    127212721,\n    127383721,\n    127494721,\n    127545721,\n    127636721,\n    127656721,\n    127686721,\n    127717721,\n    127747721,\n    127828721,\n    127909721,\n    127929721,\n    128070821,\n    128090821,\n    128121821,\n    128181821,\n    128202821,\n    128252821,\n    128262821,\n    128282821,\n    128444821,\n    128474821,\n    128525821,\n    128535821,\n    128595821,\n    128646821,\n    128747821,\n    128787821,\n    128868821,\n    128919821,\n    128939821,\n    129080921,\n    129202921,\n    129292921,\n    129323921,\n    129373921,\n    129484921,\n    129494921,\n    129535921,\n    129737921,\n    129919921,\n    129979921,\n    130020031,\n    130030031,\n    130060031,\n    130141031,\n    130171031,\n    130222031,\n    130333031,\n    130444031,\n    130464031,\n    130545031,\n    130555031,\n    130585031,\n    130606031,\n    130636031,\n    130717031,\n    130767031,\n    130818031,\n    130828031,\n    130858031,\n    130969031,\n    131030131,\n    131111131,\n    131121131,\n    131222131,\n    131252131,\n    131333131,\n    131555131,\n    131565131,\n    131585131,\n    131646131,\n    131676131,\n    131828131,\n    132010231,\n    132191231,\n    132464231,\n    132535231,\n    132595231,\n    132646231,\n    132676231,\n    132757231,\n    133020331,\n    133060331,\n    133111331,\n    133161331,\n    133252331,\n    133474331,\n    133494331,\n    133575331,\n    133686331,\n    133767331,\n    133818331,\n    133909331,\n    134090431,\n    134181431,\n    134232431,\n    134424431,\n    134505431,\n    134525431,\n    134535431,\n    134616431,\n    134757431,\n    134808431,\n    134858431,\n    134888431,\n    134909431,\n    134919431,\n    134979431,\n    135010531,\n    135040531,\n    135101531,\n    135121531,\n    135161531,\n    135262531,\n    135434531,\n    135494531,\n    135515531,\n    135626531,\n    135646531,\n    135707531,\n    135838531,\n    135868531,\n    135878531,\n    135929531,\n    135959531,\n    135979531,\n    136090631,\n    136171631,\n    136222631,\n    136252631,\n    136303631,\n    136363631,\n    136474631,\n    136545631,\n    136737631,\n    136797631,\n    136818631,\n    136909631,\n    136969631,\n    137030731,\n    137040731,\n    137060731,\n    137090731,\n    137151731,\n    137171731,\n    137232731,\n    137282731,\n    137333731,\n    137363731,\n    137424731,\n    137474731,\n    137606731,\n    137636731,\n    137696731,\n    137757731,\n    137808731,\n    137838731,\n    137939731,\n    137999731,\n    138040831,\n    138131831,\n    138242831,\n    138292831,\n    138313831,\n    138383831,\n    138454831,\n    138575831,\n    138616831,\n    138646831,\n    138757831,\n    138898831,\n    138959831,\n    138989831,\n    139131931,\n    139161931,\n    139222931,\n    139252931,\n    139282931,\n    139383931,\n    139474931,\n    139515931,\n    139606931,\n    139626931,\n    139717931,\n    139848931,\n    139959931,\n    139969931,\n    139999931,\n    140000041,\n    140030041,\n    140151041,\n    140303041,\n    140505041,\n    140565041,\n    140606041,\n    140777041,\n    140787041,\n    140828041,\n    140868041,\n    140898041,\n    141020141,\n    141070141,\n    141131141,\n    141151141,\n    141242141,\n    141262141,\n    141313141,\n    141343141,\n    141383141,\n    141484141,\n    141494141,\n    141575141,\n    141595141,\n    141616141,\n    141767141,\n    141787141,\n    141848141,\n    142000241,\n    142030241,\n    142080241,\n    142252241,\n    142272241,\n    142353241,\n    142363241,\n    142464241,\n    142545241,\n    142555241,\n    142686241,\n    142707241,\n    142797241,\n    142858241,\n    142888241,\n    143090341,\n    143181341,\n    143262341,\n    143303341,\n    143454341,\n    143474341,\n    143585341,\n    143636341,\n    143787341,\n    143828341,\n    143919341,\n    143969341,\n    144010441,\n    144020441,\n    144202441,\n    144212441,\n    144313441,\n    144353441,\n    144404441,\n    144434441,\n    144484441,\n    144505441,\n    144707441,\n    144757441,\n    144808441,\n    144818441,\n    144848441,\n    144878441,\n    144898441,\n    144979441,\n    144989441,\n    145020541,\n    145030541,\n    145090541,\n    145353541,\n    145363541,\n    145393541,\n    145464541,\n    145494541,\n    145575541,\n    145666541,\n    145767541,\n    146030641,\n    146040641,\n    146181641,\n    146222641,\n    146252641,\n    146313641,\n    146363641,\n    146505641,\n    146555641,\n    146565641,\n    146676641,\n    146858641,\n    146909641,\n    147191741,\n    147232741,\n    147242741,\n    147313741,\n    147343741,\n    147373741,\n    147434741,\n    147515741,\n    147565741,\n    147616741,\n    147686741,\n    147707741,\n    147757741,\n    147838741,\n    147929741,\n    148020841,\n    148060841,\n    148080841,\n    148414841,\n    148444841,\n    148525841,\n    148545841,\n    148585841,\n    148666841,\n    148686841,\n    148707841,\n    148818841,\n    148858841,\n    148888841,\n    148969841,\n    149000941,\n    149333941,\n    149343941,\n    149484941,\n    149535941,\n    149555941,\n    149616941,\n    149646941,\n    149696941,\n    149858941,\n    149888941,\n    149909941,\n    149919941,\n    149939941,\n    150070051,\n    150151051,\n    150181051,\n    150202051,\n    150272051,\n    150434051,\n    150494051,\n    150505051,\n    150626051,\n    150686051,\n    150727051,\n    150808051,\n    150818051,\n    150979051,\n    151080151,\n    151161151,\n    151212151,\n    151222151,\n    151282151,\n    151353151,\n    151545151,\n    151585151,\n    151656151,\n    151737151,\n    151777151,\n    151858151,\n    151878151,\n    151888151,\n    151959151,\n    151969151,\n    151999151,\n    152090251,\n    152111251,\n    152171251,\n    152181251,\n    152252251,\n    152363251,\n    152393251,\n    152454251,\n    152505251,\n    152565251,\n    152616251,\n    152646251,\n    152666251,\n    152696251,\n    152888251,\n    152939251,\n    153212351,\n    153272351,\n    153292351,\n    153313351,\n    153323351,\n    153404351,\n    153424351,\n    153454351,\n    153484351,\n    153494351,\n    153626351,\n    153808351,\n    153818351,\n    153838351,\n    153979351,\n    154030451,\n    154191451,\n    154252451,\n    154272451,\n    154303451,\n    154323451,\n    154383451,\n    154393451,\n    154474451,\n    154494451,\n    154555451,\n    154575451,\n    154989451,\n    155060551,\n    155141551,\n    155171551,\n    155292551,\n    155313551,\n    155333551,\n    155373551,\n    155424551,\n    155474551,\n    155535551,\n    155646551,\n    155666551,\n    155676551,\n    155808551,\n    155828551,\n    155868551,\n    156151651,\n    156262651,\n    156343651,\n    156424651,\n    156434651,\n    156494651,\n    156545651,\n    156595651,\n    156656651,\n    156707651,\n    156727651,\n    156757651,\n    156848651,\n    156878651,\n    156949651,\n    157090751,\n    157101751,\n    157161751,\n    157252751,\n    157393751,\n    157444751,\n    157555751,\n    157717751,\n    157878751,\n    157888751,\n    157939751,\n    157959751,\n    157989751,\n    158090851,\n    158111851,\n    158222851,\n    158252851,\n    158363851,\n    158474851,\n    158595851,\n    158676851,\n    158696851,\n    158747851,\n    158808851,\n    158858851,\n    158898851,\n    158909851,\n    159020951,\n    159040951,\n    159050951,\n    159121951,\n    159181951,\n    159191951,\n    159202951,\n    159232951,\n    159262951,\n    159292951,\n    159323951,\n    159404951,\n    159464951,\n    159565951,\n    159595951,\n    159646951,\n    159757951,\n    159808951,\n    159919951,\n    159929951,\n    159959951,\n    160020061,\n    160050061,\n    160080061,\n    160101061,\n    160131061,\n    160141061,\n    160161061,\n    160171061,\n    160393061,\n    160545061,\n    160696061,\n    160707061,\n    160717061,\n    160797061,\n    160878061,\n    161171161,\n    161282161,\n    161313161,\n    161363161,\n    161474161,\n    161484161,\n    161535161,\n    161585161,\n    161636161,\n    161787161,\n    161838161,\n    161969161,\n    162040261,\n    162232261,\n    162404261,\n    162464261,\n    162484261,\n    162565261,\n    162686261,\n    162707261,\n    162757261,\n    162898261,\n    162919261,\n    162949261,\n    162959261,\n    162979261,\n    162989261,\n    163101361,\n    163333361,\n    163434361,\n    163464361,\n    163474361,\n    163494361,\n    163515361,\n    163555361,\n    163606361,\n    163686361,\n    163696361,\n    163878361,\n    163959361,\n    164000461,\n    164070461,\n    164151461,\n    164292461,\n    164333461,\n    164454461,\n    164484461,\n    164585461,\n    164616461,\n    164696461,\n    164717461,\n    164727461,\n    164838461,\n    165101561,\n    165161561,\n    165191561,\n    165212561,\n    165343561,\n    165515561,\n    165535561,\n    165808561,\n    165878561,\n    165898561,\n    165919561,\n    165949561,\n    166000661,\n    166080661,\n    166171661,\n    166191661,\n    166404661,\n    166545661,\n    166555661,\n    166636661,\n    166686661,\n    166818661,\n    166828661,\n    166878661,\n    166888661,\n    166929661,\n    167000761,\n    167111761,\n    167262761,\n    167393761,\n    167454761,\n    167474761,\n    167484761,\n    167636761,\n    167646761,\n    167787761,\n    167888761,\n    167898761,\n    167979761,\n    168151861,\n    168191861,\n    168232861,\n    168404861,\n    168505861,\n    168515861,\n    168565861,\n    168818861,\n    168898861,\n    168929861,\n    168949861,\n    169060961,\n    169131961,\n    169141961,\n    169282961,\n    169333961,\n    169383961,\n    169464961,\n    169555961,\n    169606961,\n    169656961,\n    169666961,\n    169686961,\n    169777961,\n    169797961,\n    169858961,\n    169999961,\n    170040071,\n    170060071,\n    170232071,\n    170303071,\n    170333071,\n    170414071,\n    170424071,\n    170484071,\n    170606071,\n    170616071,\n    170646071,\n    170828071,\n    170838071,\n    170909071,\n    170979071,\n    171080171,\n    171262171,\n    171292171,\n    171343171,\n    171565171,\n    171575171,\n    171767171,\n    171919171,\n    171959171,\n    172060271,\n    172090271,\n    172161271,\n    172353271,\n    172363271,\n    172393271,\n    172474271,\n    172585271,\n    172656271,\n    172747271,\n    172767271,\n    172797271,\n    172878271,\n    172909271,\n    172959271,\n    173000371,\n    173030371,\n    173090371,\n    173252371,\n    173373371,\n    173454371,\n    173525371,\n    173585371,\n    173696371,\n    173757371,\n    173777371,\n    173828371,\n    173868371,\n    173888371,\n    173898371,\n    173919371,\n    174080471,\n    174121471,\n    174131471,\n    174181471,\n    174313471,\n    174343471,\n    174595471,\n    174646471,\n    174676471,\n    174919471,\n    174949471,\n    174979471,\n    174989471,\n    175000571,\n    175090571,\n    175101571,\n    175111571,\n    175353571,\n    175444571,\n    175555571,\n    175626571,\n    175747571,\n    175777571,\n    175848571,\n    175909571,\n    176090671,\n    176111671,\n    176141671,\n    176181671,\n    176232671,\n    176313671,\n    176333671,\n    176373671,\n    176393671,\n    176414671,\n    176585671,\n    176636671,\n    176646671,\n    176666671,\n    176696671,\n    176757671,\n    176787671,\n    176888671,\n    176898671,\n    176939671,\n    177121771,\n    177161771,\n    177202771,\n    177242771,\n    177323771,\n    177565771,\n    177616771,\n    177707771,\n    177757771,\n    177868771,\n    178101871,\n    178131871,\n    178141871,\n    178161871,\n    178353871,\n    178414871,\n    178515871,\n    178525871,\n    178656871,\n    178717871,\n    178747871,\n    178878871,\n    178969871,\n    178989871,\n    178999871,\n    179010971,\n    179060971,\n    179222971,\n    179232971,\n    179262971,\n    179414971,\n    179454971,\n    179484971,\n    179717971,\n    179777971,\n    179808971,\n    179858971,\n    179868971,\n    179909971,\n    179969971,\n    179999971,\n    180070081,\n    180101081,\n    180161081,\n    180292081,\n    180515081,\n    180535081,\n    180545081,\n    180565081,\n    180616081,\n    180757081,\n    180959081,\n    181111181,\n    181515181,\n    181545181,\n    181666181,\n    181737181,\n    181797181,\n    181888181,\n    182010281,\n    182202281,\n    182373281,\n    182585281,\n    182616281,\n    182636281,\n    182777281,\n    182858281,\n    182949281,\n    183232381,\n    183626381,\n    183656381,\n    183737381,\n    183898381,\n    183979381,\n    183989381,\n    184030481,\n    184212481,\n    184222481,\n    184303481,\n    184393481,\n    184414481,\n    184545481,\n    184585481,\n    184606481,\n    184636481,\n    184747481,\n    184818481,\n    184878481,\n    185232581,\n    185373581,\n    185393581,\n    185525581,\n    185555581,\n    185595581,\n    185676581,\n    185757581,\n    185838581,\n    185858581,\n    185868581,\n    185999581,\n    186010681,\n    186040681,\n    186050681,\n    186070681,\n    186101681,\n    186131681,\n    186151681,\n    186161681,\n    186424681,\n    186484681,\n    186505681,\n    186565681,\n    186656681,\n    186676681,\n    186787681,\n    186898681,\n    187090781,\n    187101781,\n    187111781,\n    187161781,\n    187272781,\n    187404781,\n    187434781,\n    187444781,\n    187525781,\n    187767781,\n    187909781,\n    187939781,\n    187999781,\n    188010881,\n    188060881,\n    188141881,\n    188151881,\n    188303881,\n    188373881,\n    188414881,\n    188454881,\n    188505881,\n    188525881,\n    188535881,\n    188616881,\n    188636881,\n    188646881,\n    188727881,\n    188777881,\n    188868881,\n    188888881,\n    188898881,\n    188979881,\n    189080981,\n    189131981,\n    189262981,\n    189292981,\n    189464981,\n    189535981,\n    189595981,\n    189727981,\n    189787981,\n    189838981,\n    189898981,\n    189929981,\n    190000091,\n    190020091,\n    190080091,\n    190101091,\n    190252091,\n    190404091,\n    190434091,\n    190464091,\n    190494091,\n    190656091,\n    190696091,\n    190717091,\n    190747091,\n    190777091,\n    190858091,\n    190909091,\n    191090191,\n    191171191,\n    191232191,\n    191292191,\n    191313191,\n    191565191,\n    191595191,\n    191727191,\n    191757191,\n    191838191,\n    191868191,\n    191939191,\n    191969191,\n    192101291,\n    192191291,\n    192202291,\n    192242291,\n    192313291,\n    192404291,\n    192454291,\n    192484291,\n    192767291,\n    192797291,\n    192898291,\n    193000391,\n    193030391,\n    193191391,\n    193212391,\n    193282391,\n    193303391,\n    193383391,\n    193414391,\n    193464391,\n    193555391,\n    193686391,\n    193858391,\n    193888391,\n    194000491,\n    194070491,\n    194121491,\n    194222491,\n    194232491,\n    194292491,\n    194303491,\n    194393491,\n    194505491,\n    194595491,\n    194606491,\n    194787491,\n    194939491,\n    194999491,\n    195010591,\n    195040591,\n    195070591,\n    195151591,\n    195202591,\n    195242591,\n    195353591,\n    195505591,\n    195545591,\n    195707591,\n    195767591,\n    195868591,\n    195878591,\n    195949591,\n    195979591,\n    196000691,\n    196090691,\n    196323691,\n    196333691,\n    196363691,\n    196696691,\n    196797691,\n    196828691,\n    196878691,\n    197030791,\n    197060791,\n    197070791,\n    197090791,\n    197111791,\n    197121791,\n    197202791,\n    197292791,\n    197343791,\n    197454791,\n    197525791,\n    197606791,\n    197616791,\n    197868791,\n    197898791,\n    197919791,\n    198040891,\n    198070891,\n    198080891,\n    198131891,\n    198292891,\n    198343891,\n    198353891,\n    198383891,\n    198454891,\n    198565891,\n    198656891,\n    198707891,\n    198787891,\n    198878891,\n    198919891,\n    199030991,\n    199080991,\n    199141991,\n    199171991,\n    199212991,\n    199242991,\n    199323991,\n    199353991,\n    199363991,\n    199393991,\n    199494991,\n    199515991,\n    199545991,\n    199656991,\n    199767991,\n    199909991,\n    199999991\n]\n  let left = 0, right = map.length - 1, mid = 0;\n  while (left < right) {\n    mid = Math.floor((left + right) / 2);\n    if (map[mid] >= n) right = mid;\n    else left = mid + 1;\n  }\n  return map[left];\n};\n\nconsole.log(primePalindrome(13));\n"}},,,,,,,,,,,,,,,,,function(n,e,t){},,,,,,,,,,,,,,,,,,,,,,,,,,,,function(n,e,t){var r={"./Hot100/1.两数之和.js":234,"./Hot100/101.对称二叉树.js":235,"./Hot100/102.二叉树的层序遍历.js":236,"./Hot100/104.二叉树的最大深度.js":237,"./Hot100/105.从前序与中序遍历序列构造二叉树.js":238,"./Hot100/11.盛最多水的容器.js":239,"./Hot100/114.二叉树展开为链表.js":240,"./Hot100/121.买卖股票的最佳时机.js":241,"./Hot100/128.最长连续序列.js":242,"./Hot100/136.只出现一次的数字.js":243,"./Hot100/139.单词拆分.js":244,"./Hot100/141.环形链表.js":245,"./Hot100/142.环形链表 II.js":246,"./Hot100/146.LRU 缓存.js":247,"./Hot100/148.排序链表.js":248,"./Hot100/15.三数之和.js":249,"./Hot100/152.乘积最大子数组.js":250,"./Hot100/155.最小栈.js":251,"./Hot100/160.相交链表.js":252,"./Hot100/169.多数元素.js":253,"./Hot100/17.电话号码的字母组合.js":254,"./Hot100/19.删除链表的倒数第 N 个结点.js":255,"./Hot100/198.打家劫舍.js":256,"./Hot100/2.两数相加.js":257,"./Hot100/20.有效的括号.js":258,"./Hot100/200.岛屿数量.js":259,"./Hot100/206.反转链表.js":260,"./Hot100/208.实现 Trie (前缀树).js":261,"./Hot100/21.合并两个有序链表.js":262,"./Hot100/215.数组中的第K个最大元素.js":263,"./Hot100/22.括号生成.js":264,"./Hot100/221.最大正方形.js":265,"./Hot100/226.翻转二叉树.js":266,"./Hot100/234.回文链表.js":267,"./Hot100/236.二叉树的最近公共祖先.js":268,"./Hot100/238.除自身以外数组的乘积.js":269,"./Hot100/240.搜索二维矩阵 II.js":270,"./Hot100/279.完全平方数.js":271,"./Hot100/283.移动零.js":272,"./Hot100/287.寻找重复数.js":273,"./Hot100/3.无重复字符的最长子串.js":274,"./Hot100/300.最长递增子序列.js":275,"./Hot100/31.下一个排列.js":276,"./Hot100/322.零钱兑换.js":277,"./Hot100/33.搜索旋转排序数组.js":278,"./Hot100/338.比特位计数.js":279,"./Hot100/34.在排序数组中查找元素的第一个和最后一个位置.js":280,"./Hot100/347.前 K 个高频元素.js":281,"./Hot100/39.组合总和.js":282,"./Hot100/394.字符串解码.js":283,"./Hot100/4.寻找两个正序数组的中位数.js":284,"./Hot100/416.分割等和子集.js":285,"./Hot100/437.路径总和 III.js":286,"./Hot100/448.找到所有数组中消失的数字.js":287,"./Hot100/46.全排列.js":288,"./Hot100/461.汉明距离.js":289,"./Hot100/48.旋转图像.js":290,"./Hot100/49.字母异位词分组.js":291,"./Hot100/494.目标和.js":292,"./Hot100/5.最长回文子串.js":293,"./Hot100/53.最大子数组和.js":294,"./Hot100/543.二叉树的直径.js":295,"./Hot100/55.跳跃游戏.js":296,"./Hot100/56.合并区间.js":297,"./Hot100/560.和为 K 的子数组.js":298,"./Hot100/581.最短无序连续子数组.js":299,"./Hot100/617.合并二叉树.js":300,"./Hot100/62.不同路径.js":301,"./Hot100/64.最小路径和.js":302,"./Hot100/70.爬楼梯.js":303,"./Hot100/739.每日温度.js":304,"./Hot100/75.颜色分类.js":305,"./Hot100/78.子集.js":306,"./Hot100/79.单词搜索.js":307,"./Hot100/94.二叉树的中序遍历.js":308,"./Hot100/96.不同的二叉搜索树.js":309,"./Hot100/98.验证二叉搜索树.js":310,"./else/103.二叉树的锯齿形层序遍历.js":311,"./else/112.路径总和.js":312,"./else/1143.最长公共子序列.js":313,"./else/12.整数转罗马数字.js":314,"./else/122.买卖股票的最佳时机 II.js":315,"./else/123.买卖股票的最佳时机 III.js":316,"./else/125.验证回文串.js":317,"./else/1282.用户分组.js":318,"./else/129.求根节点到叶节点数字之和.js":319,"./else/13.罗马数字转整数.js":320,"./else/1302.层数最深叶子节点的和.js":321,"./else/1374.生成每种字符都是奇数个的字符串.js":322,"./else/14.最长公共前缀.js":323,"./else/1408.数组中的字符串匹配.js":324,"./else/1413.逐步求和得到正数的最小值.js":325,"./else/1417.重新格式化字符串.js":326,"./else/1422.分割字符串的最大得分.js":327,"./else/143.重排链表.js":328,"./else/144.二叉树的前序遍历.js":329,"./else/145.二叉树的后序遍历.js":330,"./else/1450.在既定时间做作业的学生人数.js":331,"./else/1455.检查单词是否为句中其他单词的前缀.js":332,"./else/1460.通过翻转子数组使两个数组相等.js":333,"./else/1464.数组中两元素的最大乘积.js":334,"./else/1470.重新排列数组.js":335,"./else/150.逆波兰表达式求值.js":336,"./else/151.反转字符串中的单词.js":337,"./else/1582.二进制矩阵中的特殊位置.js":338,"./else/1592.重新排列单词间的空格.js":339,"./else/1598.文件夹操作日志搜集器.js":340,"./else/16.最接近的三数之和.js":341,"./else/165.比较版本号.js":342,"./else/1656.设计有序流.js":343,"./else/179.最大数.js":344,"./else/18.四数之和.js":345,"./else/199.二叉树的右视图.js":346,"./else/2042.检查句子中的数字是否递增.js":347,"./else/2055.蜡烛之间的盘子.js":348,"./else/213.打家劫舍 II.js":349,"./else/2351.第一个出现两次的字母.js":350,"./else/24.两两交换链表中的节点.js":351,"./else/25.K 个一组翻转链表.js":352,"./else/26.删除有序数组中的重复项.js":353,"./else/27.移除元素.js":354,"./else/28.实现 strStr().js":355,"./else/29.两数相除.js":356,"./else/300.最长递增子序列.js":357,"./else/342.4的幂.js":358,"./else/35.搜索插入位置.js":359,"./else/36.有效的数独.js":360,"./else/38.外观数列.js":361,"./else/415.字符串相加.js":362,"./else/43.字符串相乘.js":363,"./else/47.全排列 II.js":364,"./else/50.Pow(x, n).js":365,"./else/504.七进制数.js":366,"./else/54.螺旋矩阵.js":367,"./else/57.插入区间.js":368,"./else/58.最后一个单词的长度.js":369,"./else/59.螺旋矩阵 II.js":370,"./else/6.Z 字形变换.js":371,"./else/636.函数的独占时间.js":372,"./else/646.最长数对链.js":373,"./else/654.最大二叉树.js":374,"./else/655.输出二叉树.js":375,"./else/66.加一.js":376,"./else/662.二叉树最大宽度.js":377,"./else/67.二进制求和.js":378,"./else/69.x 的平方根.js":379,"./else/695.岛屿的最大面积.js":380,"./else/7.整数反转.js":381,"./else/704.二分查找.js":382,"./else/74.搜索二维矩阵.js":383,"./else/8.字符串转换整数 (atoi).js":384,"./else/863.二叉树中所有距离为 K 的结点.js":385,"./else/88.合并两个有序数组.js":386,"./else/9.回文数.js":387,"./else/912.排序数组.js":388,"./else/92.反转链表 II.js":389,"./else/93.复原IP.js":390,"./剑指Offer/Offer10_1.斐波那契数列.js":391,"./剑指Offer/Offer10_2.青蛙跳台阶问题.js":392,"./剑指Offer/Offer11.旋转数组的最小数字.js":393,"./剑指Offer/Offer12.矩阵中的路径.js":394,"./剑指Offer/Offer14_1.剪绳子.js":395,"./剑指Offer/Offer14_2.剪绳子.js":396,"./剑指Offer/Offer15.二进制中1的个数.js":397,"./剑指Offer/Offer16.数值的整数次方.js":398,"./剑指Offer/Offer18.删除链表的节点.js":399,"./剑指Offer/Offer20.表示数值的字符串.js":400,"./剑指Offer/Offer21.调整数组顺序使奇数位于偶数前面.js":401,"./剑指Offer/Offer22.链表中倒数第k个节点.js":402,"./剑指Offer/Offer24.反转链表.js":403,"./剑指Offer/Offer25.合并两个排序的链表.js":404,"./剑指Offer/Offer27.二叉树的镜像.js":405,"./剑指Offer/Offer28.对称的二叉树.js":406,"./剑指Offer/Offer29.顺时针打印矩阵.js":407,"./剑指Offer/Offer3.数组中重复的数字.js":408,"./剑指Offer/Offer30.包含min函数的栈.js":409,"./剑指Offer/Offer31.栈的压入、弹出序列.js":410,"./剑指Offer/Offer32_1.从上到下打印二叉树.js":411,"./剑指Offer/Offer32_2.从上到下打印二叉树 II.js":412,"./剑指Offer/Offer32_3.从上到下打印二叉树 III.js":413,"./剑指Offer/Offer33.二叉搜索树的后序遍历序列.js":414,"./剑指Offer/Offer34.二叉树中和为某一值的路径.js":415,"./剑指Offer/Offer36. 后缀表达式.js":416,"./剑指Offer/Offer38.字符串的排列.js":417,"./剑指Offer/Offer39.数组中出现次数超过一半的数字.js":418,"./剑指Offer/Offer4.二维数组中的查找.js":419,"./剑指Offer/Offer40.最小的k个数.js":420,"./剑指Offer/Offer42.连续子数组的最大和.js":421,"./剑指Offer/Offer44.数字序列中某一位的数字.js":422,"./剑指Offer/Offer45.把数组排成最小的数.js":423,"./剑指Offer/Offer46.把数字翻译成字符串.js":424,"./剑指Offer/Offer47.礼物的最大价值.js":425,"./剑指Offer/Offer48.最长不含重复字符的子字符串.js":426,"./剑指Offer/Offer49.丑数.js":427,"./剑指Offer/Offer5.替换空格.js":428,"./剑指Offer/Offer50.第一个只出现一次的字符.js":429,"./剑指Offer/Offer51.数组中的逆序对.js":430,"./剑指Offer/Offer52.两个链表的第一个公共节点.js":431,"./剑指Offer/Offer53_1.在排序数组中查找数字 I.js":432,"./剑指Offer/Offer53_2.0～n-1中缺失的数字.js":433,"./剑指Offer/Offer54.二叉搜索树的第k大节点.js":434,"./剑指Offer/Offer55_1.二叉树的深度.js":435,"./剑指Offer/Offer55_2.平衡二叉树.js":436,"./剑指Offer/Offer56_1.数组中数字出现的次数.js":437,"./剑指Offer/Offer56_2.数组中数字出现的次数 II.js":438,"./剑指Offer/Offer57.和为s的两个数字.js":439,"./剑指Offer/Offer57_2.和为s的连续正数序列.js":440,"./剑指Offer/Offer58_1.翻转单词顺序.js":441,"./剑指Offer/Offer58_2.左旋转字符串.js":442,"./剑指Offer/Offer6.从尾到头打印链表.js":443,"./剑指Offer/Offer61.扑克牌中的顺子.js":444,"./剑指Offer/Offer62.圆圈中最后剩下的数字.js":445,"./剑指Offer/Offer63.股票的最大利润.js":446,"./剑指Offer/Offer64.求1+2+…+n.js":447,"./剑指Offer/Offer65.不用加减乘除做加法.js":448,"./剑指Offer/Offer66.构建乘积数组.js":449,"./剑指Offer/Offer67.把字符串转换成整数.js":450,"./剑指Offer/Offer68_1.二叉搜索树的最近公共祖先.js":451,"./剑指Offer/Offer68_2.二叉树的最近公共祖先.js":452,"./剑指Offer/Offer7.打印从1到最大的n位数.js":453,"./剑指Offer/Offer7.重建二叉树.js":454,"./剑指Offer/Offer9.用两个栈实现队列.js":455,"./华为机试/1.字符串最后一个单词的长度.js":456,"./华为机试/10.字符个数统计.js":457,"./华为机试/100.等差数列.js":458,"./华为机试/101.输入整型数组和排序标识，对其元素按照升序或降序进行排序.js":459,"./华为机试/102.字符统计.js":460,"./华为机试/103.Redraiment的走法.js":461,"./华为机试/105.记负均正II.js":462,"./华为机试/106.字符逆序.js":463,"./华为机试/11.数字颠倒.js":464,"./华为机试/12.字符串反转.js":465,"./华为机试/13.句子逆序.js":466,"./华为机试/14.字符串排序.js":467,"./华为机试/15.求int型正整数在内存中存储时1的个数.js":468,"./华为机试/17.坐标移动.js":469,"./华为机试/19.简单错误记录.js":470,"./华为机试/2.计算某字符出现次数.js":471,"./华为机试/20.密码验证合格程序.js":472,"./华为机试/21.简单密码.js":473,"./华为机试/22.汽水瓶.js":474,"./华为机试/23.删除字符串中出现次数最少的字符.js":475,"./华为机试/25.数据分类处理.js":476,"./华为机试/26.字符串排序.js":477,"./华为机试/27.查找兄弟单词.js":478,"./华为机试/29.字符串加解密.js":479,"./华为机试/3.明明的随机数.js":480,"./华为机试/30.字符串合并处理.js":481,"./华为机试/31.单词倒排.js":482,"./华为机试/32.密码截取.js":483,"./华为机试/33.整数与IP地址间的转换.js":484,"./华为机试/34.图片整理.js":485,"./华为机试/35.蛇形矩阵.js":486,"./华为机试/36.字符串加密.js":487,"./华为机试/38.求小球落地5次后所经历的路程和第5次反弹的高度.js":488,"./华为机试/39.判断两个IP是否属于同一子网.js":489,"./华为机试/4.字符串分隔.js":490,"./华为机试/40.统计字符.js":491,"./华为机试/42.学英语.js":492,"./华为机试/43.迷宫问题.js":493,"./华为机试/45.名字的漂亮度.js":494,"./华为机试/46.截取字符串.js":495,"./华为机试/48.从单向链表中删除指定值的节点.js":496,"./华为机试/5.进制转换.js":497,"./华为机试/51.输出单向链表中倒数第k个结点.js":498,"./华为机试/53.杨辉三角的变形.js":499,"./华为机试/54.表达式求值.js":500,"./华为机试/55.挑7.js":501,"./华为机试/56.完全数计算.js":502,"./华为机试/57.高精度整数加法.js":503,"./华为机试/58.输入n个整数，输出其中最小的k个.js":504,"./华为机试/59.找出字符串中第一个只出现一次的字符.js":505,"./华为机试/6.质数因子.js":506,"./华为机试/60.查找组成一个偶数最接近的两个素数.js":507,"./华为机试/62.查找输入整数二进制中1的个数.js":508,"./华为机试/63.DNA序列.js":509,"./华为机试/66.配置文件恢复.js":510,"./华为机试/68.成绩排序.js":511,"./华为机试/69.矩阵乘法.js":512,"./华为机试/7.取近似值.js":513,"./华为机试/70.矩阵乘法计算量估算.js":514,"./华为机试/71.字符串通配符.js":515,"./华为机试/72.百钱买百鸡问题.js":516,"./华为机试/73.计算日期到天数转换.js":517,"./华为机试/74.参数解析.js":518,"./华为机试/75.公共子串计算.js":519,"./华为机试/76.尼科彻斯定理.js":520,"./华为机试/77.火车进站.js":521,"./华为机试/8.合并表记录.js":522,"./华为机试/80.整型数组合并.js":523,"./华为机试/81.字符串字符匹配.js":524,"./华为机试/84.统计大写字母个数.js":525,"./华为机试/85.最长回文子串.js":526,"./华为机试/86.求最大连续bit数.js":527,"./华为机试/87.密码强度等级.js":528,"./华为机试/9.提取不重复的整数.js":529,"./华为机试/90.合法IP.js":530,"./华为机试/91.走方格的方案数.js":531,"./华为机试/92.在字符串中找出连续最长的数字串.js":532,"./华为机试/94.记票统计.js":533,"./华为机试/96.表示数字.js":534,"./华为机试/97.记负均正.js":535,"./华为机试/99.自守数.js":536,"./面试练习/1019. 链表中的下一个更大节点.js":537,"./面试练习/1207. 独一无二的出现次数.js":538,"./面试练习/1657. 确定两个字符串是否接近.js":539,"./面试练习/1663. 具有给定数值的最小字符串.js":540,"./面试练习/1664. 生成平衡数组的方案数.js":541,"./面试练习/1669. 合并两个链表.js":542,"./面试练习/1802. 有界数组中指定下标处的最大值.js":543,"./面试练习/1807.替换字符串中的括号内容.js":544,"./面试练习/1813.句子相似性 III.js":545,"./面试练习/1814.统计一个数组中好对子的数目.js":546,"./面试练习/1817. 查找用户活跃分钟数.js":547,"./面试练习/1828. 统计一个圆中点的数目.js":548,"./面试练习/209.长度最小的子数组.js":549,"./面试练习/2149. 按符号重排数组.js":550,"./面试练习/2180. 统计各位数字之和为偶数的整数个数.js":551,"./面试练习/228. 汇总区间.js":552,"./面试练习/2287.重排字符形成目标字符串.js":553,"./面试练习/2293.极大极小游戏.js":554,"./面试练习/2299. 强密码检验器 II.js":555,"./面试练习/2303. 计算应缴税款总额.js":556,"./面试练习/2309. 兼具大小写的最好英文字母.js":557,"./面试练习/2315. 统计星号.js":558,"./面试练习/2319. 判断矩阵是否是一个 X 矩阵.js":559,"./面试练习/2325. 解密消息.js":560,"./面试练习/326. 3 的幂.js":561,"./面试练习/42.接雨水.js":562,"./面试练习/705. 设计哈希集合.js":563,"./面试练习/747. 至少是其他数字两倍的最大数.js":564,"./面试练习/860. 柠檬水找零.js":565,"./面试练习/866. 回文素数.js":566};function s(n){var e=o(n);return t(e)}function o(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}s.keys=function(){return Object.keys(r)},s.resolve=o,n.exports=s,s.id=611},function(n,e,t){var r={"./Hot100/1.两数之和":234,"./Hot100/1.两数之和.js":234,"./Hot100/101.对称二叉树":235,"./Hot100/101.对称二叉树.js":235,"./Hot100/102.二叉树的层序遍历":236,"./Hot100/102.二叉树的层序遍历.js":236,"./Hot100/104.二叉树的最大深度":237,"./Hot100/104.二叉树的最大深度.js":237,"./Hot100/105.从前序与中序遍历序列构造二叉树":238,"./Hot100/105.从前序与中序遍历序列构造二叉树.js":238,"./Hot100/11.盛最多水的容器":239,"./Hot100/11.盛最多水的容器.js":239,"./Hot100/114.二叉树展开为链表":240,"./Hot100/114.二叉树展开为链表.js":240,"./Hot100/121.买卖股票的最佳时机":241,"./Hot100/121.买卖股票的最佳时机.js":241,"./Hot100/128.最长连续序列":242,"./Hot100/128.最长连续序列.js":242,"./Hot100/136.只出现一次的数字":243,"./Hot100/136.只出现一次的数字.js":243,"./Hot100/139.单词拆分":244,"./Hot100/139.单词拆分.js":244,"./Hot100/141.环形链表":245,"./Hot100/141.环形链表.js":245,"./Hot100/142.环形链表 II":246,"./Hot100/142.环形链表 II.js":246,"./Hot100/146.LRU 缓存":247,"./Hot100/146.LRU 缓存.js":247,"./Hot100/148.排序链表":248,"./Hot100/148.排序链表.js":248,"./Hot100/15.三数之和":249,"./Hot100/15.三数之和.js":249,"./Hot100/152.乘积最大子数组":250,"./Hot100/152.乘积最大子数组.js":250,"./Hot100/155.最小栈":251,"./Hot100/155.最小栈.js":251,"./Hot100/160.相交链表":252,"./Hot100/160.相交链表.js":252,"./Hot100/169.多数元素":253,"./Hot100/169.多数元素.js":253,"./Hot100/17.电话号码的字母组合":254,"./Hot100/17.电话号码的字母组合.js":254,"./Hot100/19.删除链表的倒数第 N 个结点":255,"./Hot100/19.删除链表的倒数第 N 个结点.js":255,"./Hot100/198.打家劫舍":256,"./Hot100/198.打家劫舍.js":256,"./Hot100/2.两数相加":257,"./Hot100/2.两数相加.js":257,"./Hot100/20.有效的括号":258,"./Hot100/20.有效的括号.js":258,"./Hot100/200.岛屿数量":259,"./Hot100/200.岛屿数量.js":259,"./Hot100/206.反转链表":260,"./Hot100/206.反转链表.js":260,"./Hot100/208.实现 Trie (前缀树)":261,"./Hot100/208.实现 Trie (前缀树).js":261,"./Hot100/21.合并两个有序链表":262,"./Hot100/21.合并两个有序链表.js":262,"./Hot100/215.数组中的第K个最大元素":263,"./Hot100/215.数组中的第K个最大元素.js":263,"./Hot100/22.括号生成":264,"./Hot100/22.括号生成.js":264,"./Hot100/221.最大正方形":265,"./Hot100/221.最大正方形.js":265,"./Hot100/226.翻转二叉树":266,"./Hot100/226.翻转二叉树.js":266,"./Hot100/234.回文链表":267,"./Hot100/234.回文链表.js":267,"./Hot100/236.二叉树的最近公共祖先":268,"./Hot100/236.二叉树的最近公共祖先.js":268,"./Hot100/238.除自身以外数组的乘积":269,"./Hot100/238.除自身以外数组的乘积.js":269,"./Hot100/240.搜索二维矩阵 II":270,"./Hot100/240.搜索二维矩阵 II.js":270,"./Hot100/279.完全平方数":271,"./Hot100/279.完全平方数.js":271,"./Hot100/283.移动零":272,"./Hot100/283.移动零.js":272,"./Hot100/287.寻找重复数":273,"./Hot100/287.寻找重复数.js":273,"./Hot100/3.无重复字符的最长子串":274,"./Hot100/3.无重复字符的最长子串.js":274,"./Hot100/300.最长递增子序列":275,"./Hot100/300.最长递增子序列.js":275,"./Hot100/31.下一个排列":276,"./Hot100/31.下一个排列.js":276,"./Hot100/322.零钱兑换":277,"./Hot100/322.零钱兑换.js":277,"./Hot100/33.搜索旋转排序数组":278,"./Hot100/33.搜索旋转排序数组.js":278,"./Hot100/338.比特位计数":279,"./Hot100/338.比特位计数.js":279,"./Hot100/34.在排序数组中查找元素的第一个和最后一个位置":280,"./Hot100/34.在排序数组中查找元素的第一个和最后一个位置.js":280,"./Hot100/347.前 K 个高频元素":281,"./Hot100/347.前 K 个高频元素.js":281,"./Hot100/39.组合总和":282,"./Hot100/39.组合总和.js":282,"./Hot100/394.字符串解码":283,"./Hot100/394.字符串解码.js":283,"./Hot100/4.寻找两个正序数组的中位数":284,"./Hot100/4.寻找两个正序数组的中位数.js":284,"./Hot100/416.分割等和子集":285,"./Hot100/416.分割等和子集.js":285,"./Hot100/437.路径总和 III":286,"./Hot100/437.路径总和 III.js":286,"./Hot100/448.找到所有数组中消失的数字":287,"./Hot100/448.找到所有数组中消失的数字.js":287,"./Hot100/46.全排列":288,"./Hot100/46.全排列.js":288,"./Hot100/461.汉明距离":289,"./Hot100/461.汉明距离.js":289,"./Hot100/48.旋转图像":290,"./Hot100/48.旋转图像.js":290,"./Hot100/49.字母异位词分组":291,"./Hot100/49.字母异位词分组.js":291,"./Hot100/494.目标和":292,"./Hot100/494.目标和.js":292,"./Hot100/5.最长回文子串":293,"./Hot100/5.最长回文子串.js":293,"./Hot100/53.最大子数组和":294,"./Hot100/53.最大子数组和.js":294,"./Hot100/543.二叉树的直径":295,"./Hot100/543.二叉树的直径.js":295,"./Hot100/55.跳跃游戏":296,"./Hot100/55.跳跃游戏.js":296,"./Hot100/56.合并区间":297,"./Hot100/56.合并区间.js":297,"./Hot100/560.和为 K 的子数组":298,"./Hot100/560.和为 K 的子数组.js":298,"./Hot100/581.最短无序连续子数组":299,"./Hot100/581.最短无序连续子数组.js":299,"./Hot100/617.合并二叉树":300,"./Hot100/617.合并二叉树.js":300,"./Hot100/62.不同路径":301,"./Hot100/62.不同路径.js":301,"./Hot100/64.最小路径和":302,"./Hot100/64.最小路径和.js":302,"./Hot100/70.爬楼梯":303,"./Hot100/70.爬楼梯.js":303,"./Hot100/739.每日温度":304,"./Hot100/739.每日温度.js":304,"./Hot100/75.颜色分类":305,"./Hot100/75.颜色分类.js":305,"./Hot100/78.子集":306,"./Hot100/78.子集.js":306,"./Hot100/79.单词搜索":307,"./Hot100/79.单词搜索.js":307,"./Hot100/94.二叉树的中序遍历":308,"./Hot100/94.二叉树的中序遍历.js":308,"./Hot100/96.不同的二叉搜索树":309,"./Hot100/96.不同的二叉搜索树.js":309,"./Hot100/98.验证二叉搜索树":310,"./Hot100/98.验证二叉搜索树.js":310,"./else/103.二叉树的锯齿形层序遍历":311,"./else/103.二叉树的锯齿形层序遍历.js":311,"./else/112.路径总和":312,"./else/112.路径总和.js":312,"./else/1143.最长公共子序列":313,"./else/1143.最长公共子序列.js":313,"./else/12.整数转罗马数字":314,"./else/12.整数转罗马数字.js":314,"./else/122.买卖股票的最佳时机 II":315,"./else/122.买卖股票的最佳时机 II.js":315,"./else/123.买卖股票的最佳时机 III":316,"./else/123.买卖股票的最佳时机 III.js":316,"./else/125.验证回文串":317,"./else/125.验证回文串.js":317,"./else/1282.用户分组":318,"./else/1282.用户分组.js":318,"./else/129.求根节点到叶节点数字之和":319,"./else/129.求根节点到叶节点数字之和.js":319,"./else/13.罗马数字转整数":320,"./else/13.罗马数字转整数.js":320,"./else/1302.层数最深叶子节点的和":321,"./else/1302.层数最深叶子节点的和.js":321,"./else/1374.生成每种字符都是奇数个的字符串":322,"./else/1374.生成每种字符都是奇数个的字符串.js":322,"./else/14.最长公共前缀":323,"./else/14.最长公共前缀.js":323,"./else/1408.数组中的字符串匹配":324,"./else/1408.数组中的字符串匹配.js":324,"./else/1413.逐步求和得到正数的最小值":325,"./else/1413.逐步求和得到正数的最小值.js":325,"./else/1417.重新格式化字符串":326,"./else/1417.重新格式化字符串.js":326,"./else/1422.分割字符串的最大得分":327,"./else/1422.分割字符串的最大得分.js":327,"./else/143.重排链表":328,"./else/143.重排链表.js":328,"./else/144.二叉树的前序遍历":329,"./else/144.二叉树的前序遍历.js":329,"./else/145.二叉树的后序遍历":330,"./else/145.二叉树的后序遍历.js":330,"./else/1450.在既定时间做作业的学生人数":331,"./else/1450.在既定时间做作业的学生人数.js":331,"./else/1455.检查单词是否为句中其他单词的前缀":332,"./else/1455.检查单词是否为句中其他单词的前缀.js":332,"./else/1460.通过翻转子数组使两个数组相等":333,"./else/1460.通过翻转子数组使两个数组相等.js":333,"./else/1464.数组中两元素的最大乘积":334,"./else/1464.数组中两元素的最大乘积.js":334,"./else/1470.重新排列数组":335,"./else/1470.重新排列数组.js":335,"./else/150.逆波兰表达式求值":336,"./else/150.逆波兰表达式求值.js":336,"./else/151.反转字符串中的单词":337,"./else/151.反转字符串中的单词.js":337,"./else/1582.二进制矩阵中的特殊位置":338,"./else/1582.二进制矩阵中的特殊位置.js":338,"./else/1592.重新排列单词间的空格":339,"./else/1592.重新排列单词间的空格.js":339,"./else/1598.文件夹操作日志搜集器":340,"./else/1598.文件夹操作日志搜集器.js":340,"./else/16.最接近的三数之和":341,"./else/16.最接近的三数之和.js":341,"./else/165.比较版本号":342,"./else/165.比较版本号.js":342,"./else/1656.设计有序流":343,"./else/1656.设计有序流.js":343,"./else/179.最大数":344,"./else/179.最大数.js":344,"./else/18.四数之和":345,"./else/18.四数之和.js":345,"./else/199.二叉树的右视图":346,"./else/199.二叉树的右视图.js":346,"./else/2042.检查句子中的数字是否递增":347,"./else/2042.检查句子中的数字是否递增.js":347,"./else/2055.蜡烛之间的盘子":348,"./else/2055.蜡烛之间的盘子.js":348,"./else/213.打家劫舍 II":349,"./else/213.打家劫舍 II.js":349,"./else/2351.第一个出现两次的字母":350,"./else/2351.第一个出现两次的字母.js":350,"./else/24.两两交换链表中的节点":351,"./else/24.两两交换链表中的节点.js":351,"./else/25.K 个一组翻转链表":352,"./else/25.K 个一组翻转链表.js":352,"./else/26.删除有序数组中的重复项":353,"./else/26.删除有序数组中的重复项.js":353,"./else/27.移除元素":354,"./else/27.移除元素.js":354,"./else/28.实现 strStr()":355,"./else/28.实现 strStr().js":355,"./else/29.两数相除":356,"./else/29.两数相除.js":356,"./else/300.最长递增子序列":357,"./else/300.最长递增子序列.js":357,"./else/342.4的幂":358,"./else/342.4的幂.js":358,"./else/35.搜索插入位置":359,"./else/35.搜索插入位置.js":359,"./else/36.有效的数独":360,"./else/36.有效的数独.js":360,"./else/38.外观数列":361,"./else/38.外观数列.js":361,"./else/415.字符串相加":362,"./else/415.字符串相加.js":362,"./else/43.字符串相乘":363,"./else/43.字符串相乘.js":363,"./else/47.全排列 II":364,"./else/47.全排列 II.js":364,"./else/50.Pow(x, n)":365,"./else/50.Pow(x, n).js":365,"./else/504.七进制数":366,"./else/504.七进制数.js":366,"./else/54.螺旋矩阵":367,"./else/54.螺旋矩阵.js":367,"./else/57.插入区间":368,"./else/57.插入区间.js":368,"./else/58.最后一个单词的长度":369,"./else/58.最后一个单词的长度.js":369,"./else/59.螺旋矩阵 II":370,"./else/59.螺旋矩阵 II.js":370,"./else/6.Z 字形变换":371,"./else/6.Z 字形变换.js":371,"./else/636.函数的独占时间":372,"./else/636.函数的独占时间.js":372,"./else/646.最长数对链":373,"./else/646.最长数对链.js":373,"./else/654.最大二叉树":374,"./else/654.最大二叉树.js":374,"./else/655.输出二叉树":375,"./else/655.输出二叉树.js":375,"./else/66.加一":376,"./else/66.加一.js":376,"./else/662.二叉树最大宽度":377,"./else/662.二叉树最大宽度.js":377,"./else/67.二进制求和":378,"./else/67.二进制求和.js":378,"./else/69.x 的平方根":379,"./else/69.x 的平方根.js":379,"./else/695.岛屿的最大面积":380,"./else/695.岛屿的最大面积.js":380,"./else/7.整数反转":381,"./else/7.整数反转.js":381,"./else/704.二分查找":382,"./else/704.二分查找.js":382,"./else/74.搜索二维矩阵":383,"./else/74.搜索二维矩阵.js":383,"./else/8.字符串转换整数 (atoi)":384,"./else/8.字符串转换整数 (atoi).js":384,"./else/863.二叉树中所有距离为 K 的结点":385,"./else/863.二叉树中所有距离为 K 的结点.js":385,"./else/88.合并两个有序数组":386,"./else/88.合并两个有序数组.js":386,"./else/9.回文数":387,"./else/9.回文数.js":387,"./else/912.排序数组":388,"./else/912.排序数组.js":388,"./else/92.反转链表 II":389,"./else/92.反转链表 II.js":389,"./else/93.复原IP":390,"./else/93.复原IP.js":390,"./剑指Offer/Offer10_1.斐波那契数列":391,"./剑指Offer/Offer10_1.斐波那契数列.js":391,"./剑指Offer/Offer10_2.青蛙跳台阶问题":392,"./剑指Offer/Offer10_2.青蛙跳台阶问题.js":392,"./剑指Offer/Offer11.旋转数组的最小数字":393,"./剑指Offer/Offer11.旋转数组的最小数字.js":393,"./剑指Offer/Offer12.矩阵中的路径":394,"./剑指Offer/Offer12.矩阵中的路径.js":394,"./剑指Offer/Offer14_1.剪绳子":395,"./剑指Offer/Offer14_1.剪绳子.js":395,"./剑指Offer/Offer14_2.剪绳子":396,"./剑指Offer/Offer14_2.剪绳子.js":396,"./剑指Offer/Offer15.二进制中1的个数":397,"./剑指Offer/Offer15.二进制中1的个数.js":397,"./剑指Offer/Offer16.数值的整数次方":398,"./剑指Offer/Offer16.数值的整数次方.js":398,"./剑指Offer/Offer18.删除链表的节点":399,"./剑指Offer/Offer18.删除链表的节点.js":399,"./剑指Offer/Offer20.表示数值的字符串":400,"./剑指Offer/Offer20.表示数值的字符串.js":400,"./剑指Offer/Offer21.调整数组顺序使奇数位于偶数前面":401,"./剑指Offer/Offer21.调整数组顺序使奇数位于偶数前面.js":401,"./剑指Offer/Offer22.链表中倒数第k个节点":402,"./剑指Offer/Offer22.链表中倒数第k个节点.js":402,"./剑指Offer/Offer24.反转链表":403,"./剑指Offer/Offer24.反转链表.js":403,"./剑指Offer/Offer25.合并两个排序的链表":404,"./剑指Offer/Offer25.合并两个排序的链表.js":404,"./剑指Offer/Offer27.二叉树的镜像":405,"./剑指Offer/Offer27.二叉树的镜像.js":405,"./剑指Offer/Offer28.对称的二叉树":406,"./剑指Offer/Offer28.对称的二叉树.js":406,"./剑指Offer/Offer29.顺时针打印矩阵":407,"./剑指Offer/Offer29.顺时针打印矩阵.js":407,"./剑指Offer/Offer3.数组中重复的数字":408,"./剑指Offer/Offer3.数组中重复的数字.js":408,"./剑指Offer/Offer30.包含min函数的栈":409,"./剑指Offer/Offer30.包含min函数的栈.js":409,"./剑指Offer/Offer31.栈的压入、弹出序列":410,"./剑指Offer/Offer31.栈的压入、弹出序列.js":410,"./剑指Offer/Offer32_1.从上到下打印二叉树":411,"./剑指Offer/Offer32_1.从上到下打印二叉树.js":411,"./剑指Offer/Offer32_2.从上到下打印二叉树 II":412,"./剑指Offer/Offer32_2.从上到下打印二叉树 II.js":412,"./剑指Offer/Offer32_3.从上到下打印二叉树 III":413,"./剑指Offer/Offer32_3.从上到下打印二叉树 III.js":413,"./剑指Offer/Offer33.二叉搜索树的后序遍历序列":414,"./剑指Offer/Offer33.二叉搜索树的后序遍历序列.js":414,"./剑指Offer/Offer34.二叉树中和为某一值的路径":415,"./剑指Offer/Offer34.二叉树中和为某一值的路径.js":415,"./剑指Offer/Offer36. 后缀表达式":416,"./剑指Offer/Offer36. 后缀表达式.js":416,"./剑指Offer/Offer38.字符串的排列":417,"./剑指Offer/Offer38.字符串的排列.js":417,"./剑指Offer/Offer39.数组中出现次数超过一半的数字":418,"./剑指Offer/Offer39.数组中出现次数超过一半的数字.js":418,"./剑指Offer/Offer4.二维数组中的查找":419,"./剑指Offer/Offer4.二维数组中的查找.js":419,"./剑指Offer/Offer40.最小的k个数":420,"./剑指Offer/Offer40.最小的k个数.js":420,"./剑指Offer/Offer42.连续子数组的最大和":421,"./剑指Offer/Offer42.连续子数组的最大和.js":421,"./剑指Offer/Offer44.数字序列中某一位的数字":422,"./剑指Offer/Offer44.数字序列中某一位的数字.js":422,"./剑指Offer/Offer45.把数组排成最小的数":423,"./剑指Offer/Offer45.把数组排成最小的数.js":423,"./剑指Offer/Offer46.把数字翻译成字符串":424,"./剑指Offer/Offer46.把数字翻译成字符串.js":424,"./剑指Offer/Offer47.礼物的最大价值":425,"./剑指Offer/Offer47.礼物的最大价值.js":425,"./剑指Offer/Offer48.最长不含重复字符的子字符串":426,"./剑指Offer/Offer48.最长不含重复字符的子字符串.js":426,"./剑指Offer/Offer49.丑数":427,"./剑指Offer/Offer49.丑数.js":427,"./剑指Offer/Offer5.替换空格":428,"./剑指Offer/Offer5.替换空格.js":428,"./剑指Offer/Offer50.第一个只出现一次的字符":429,"./剑指Offer/Offer50.第一个只出现一次的字符.js":429,"./剑指Offer/Offer51.数组中的逆序对":430,"./剑指Offer/Offer51.数组中的逆序对.js":430,"./剑指Offer/Offer52.两个链表的第一个公共节点":431,"./剑指Offer/Offer52.两个链表的第一个公共节点.js":431,"./剑指Offer/Offer53_1.在排序数组中查找数字 I":432,"./剑指Offer/Offer53_1.在排序数组中查找数字 I.js":432,"./剑指Offer/Offer53_2.0～n-1中缺失的数字":433,"./剑指Offer/Offer53_2.0～n-1中缺失的数字.js":433,"./剑指Offer/Offer54.二叉搜索树的第k大节点":434,"./剑指Offer/Offer54.二叉搜索树的第k大节点.js":434,"./剑指Offer/Offer55_1.二叉树的深度":435,"./剑指Offer/Offer55_1.二叉树的深度.js":435,"./剑指Offer/Offer55_2.平衡二叉树":436,"./剑指Offer/Offer55_2.平衡二叉树.js":436,"./剑指Offer/Offer56_1.数组中数字出现的次数":437,"./剑指Offer/Offer56_1.数组中数字出现的次数.js":437,"./剑指Offer/Offer56_2.数组中数字出现的次数 II":438,"./剑指Offer/Offer56_2.数组中数字出现的次数 II.js":438,"./剑指Offer/Offer57.和为s的两个数字":439,"./剑指Offer/Offer57.和为s的两个数字.js":439,"./剑指Offer/Offer57_2.和为s的连续正数序列":440,"./剑指Offer/Offer57_2.和为s的连续正数序列.js":440,"./剑指Offer/Offer58_1.翻转单词顺序":441,"./剑指Offer/Offer58_1.翻转单词顺序.js":441,"./剑指Offer/Offer58_2.左旋转字符串":442,"./剑指Offer/Offer58_2.左旋转字符串.js":442,"./剑指Offer/Offer6.从尾到头打印链表":443,"./剑指Offer/Offer6.从尾到头打印链表.js":443,"./剑指Offer/Offer61.扑克牌中的顺子":444,"./剑指Offer/Offer61.扑克牌中的顺子.js":444,"./剑指Offer/Offer62.圆圈中最后剩下的数字":445,"./剑指Offer/Offer62.圆圈中最后剩下的数字.js":445,"./剑指Offer/Offer63.股票的最大利润":446,"./剑指Offer/Offer63.股票的最大利润.js":446,"./剑指Offer/Offer64.求1+2+…+n":447,"./剑指Offer/Offer64.求1+2+…+n.js":447,"./剑指Offer/Offer65.不用加减乘除做加法":448,"./剑指Offer/Offer65.不用加减乘除做加法.js":448,"./剑指Offer/Offer66.构建乘积数组":449,"./剑指Offer/Offer66.构建乘积数组.js":449,"./剑指Offer/Offer67.把字符串转换成整数":450,"./剑指Offer/Offer67.把字符串转换成整数.js":450,"./剑指Offer/Offer68_1.二叉搜索树的最近公共祖先":451,"./剑指Offer/Offer68_1.二叉搜索树的最近公共祖先.js":451,"./剑指Offer/Offer68_2.二叉树的最近公共祖先":452,"./剑指Offer/Offer68_2.二叉树的最近公共祖先.js":452,"./剑指Offer/Offer7.打印从1到最大的n位数":453,"./剑指Offer/Offer7.打印从1到最大的n位数.js":453,"./剑指Offer/Offer7.重建二叉树":454,"./剑指Offer/Offer7.重建二叉树.js":454,"./剑指Offer/Offer9.用两个栈实现队列":455,"./剑指Offer/Offer9.用两个栈实现队列.js":455,"./华为机试/1.字符串最后一个单词的长度":456,"./华为机试/1.字符串最后一个单词的长度.js":456,"./华为机试/10.字符个数统计":457,"./华为机试/10.字符个数统计.js":457,"./华为机试/100.等差数列":458,"./华为机试/100.等差数列.js":458,"./华为机试/101.输入整型数组和排序标识，对其元素按照升序或降序进行排序":459,"./华为机试/101.输入整型数组和排序标识，对其元素按照升序或降序进行排序.js":459,"./华为机试/102.字符统计":460,"./华为机试/102.字符统计.js":460,"./华为机试/103.Redraiment的走法":461,"./华为机试/103.Redraiment的走法.js":461,"./华为机试/105.记负均正II":462,"./华为机试/105.记负均正II.js":462,"./华为机试/106.字符逆序":463,"./华为机试/106.字符逆序.js":463,"./华为机试/11.数字颠倒":464,"./华为机试/11.数字颠倒.js":464,"./华为机试/12.字符串反转":465,"./华为机试/12.字符串反转.js":465,"./华为机试/13.句子逆序":466,"./华为机试/13.句子逆序.js":466,"./华为机试/14.字符串排序":467,"./华为机试/14.字符串排序.js":467,"./华为机试/15.求int型正整数在内存中存储时1的个数":468,"./华为机试/15.求int型正整数在内存中存储时1的个数.js":468,"./华为机试/17.坐标移动":469,"./华为机试/17.坐标移动.js":469,"./华为机试/19.简单错误记录":470,"./华为机试/19.简单错误记录.js":470,"./华为机试/2.计算某字符出现次数":471,"./华为机试/2.计算某字符出现次数.js":471,"./华为机试/20.密码验证合格程序":472,"./华为机试/20.密码验证合格程序.js":472,"./华为机试/21.简单密码":473,"./华为机试/21.简单密码.js":473,"./华为机试/22.汽水瓶":474,"./华为机试/22.汽水瓶.js":474,"./华为机试/23.删除字符串中出现次数最少的字符":475,"./华为机试/23.删除字符串中出现次数最少的字符.js":475,"./华为机试/25.数据分类处理":476,"./华为机试/25.数据分类处理.js":476,"./华为机试/26.字符串排序":477,"./华为机试/26.字符串排序.js":477,"./华为机试/27.查找兄弟单词":478,"./华为机试/27.查找兄弟单词.js":478,"./华为机试/29.字符串加解密":479,"./华为机试/29.字符串加解密.js":479,"./华为机试/3.明明的随机数":480,"./华为机试/3.明明的随机数.js":480,"./华为机试/30.字符串合并处理":481,"./华为机试/30.字符串合并处理.js":481,"./华为机试/31.单词倒排":482,"./华为机试/31.单词倒排.js":482,"./华为机试/32.密码截取":483,"./华为机试/32.密码截取.js":483,"./华为机试/33.整数与IP地址间的转换":484,"./华为机试/33.整数与IP地址间的转换.js":484,"./华为机试/34.图片整理":485,"./华为机试/34.图片整理.js":485,"./华为机试/35.蛇形矩阵":486,"./华为机试/35.蛇形矩阵.js":486,"./华为机试/36.字符串加密":487,"./华为机试/36.字符串加密.js":487,"./华为机试/38.求小球落地5次后所经历的路程和第5次反弹的高度":488,"./华为机试/38.求小球落地5次后所经历的路程和第5次反弹的高度.js":488,"./华为机试/39.判断两个IP是否属于同一子网":489,"./华为机试/39.判断两个IP是否属于同一子网.js":489,"./华为机试/4.字符串分隔":490,"./华为机试/4.字符串分隔.js":490,"./华为机试/40.统计字符":491,"./华为机试/40.统计字符.js":491,"./华为机试/42.学英语":492,"./华为机试/42.学英语.js":492,"./华为机试/43.迷宫问题":493,"./华为机试/43.迷宫问题.js":493,"./华为机试/45.名字的漂亮度":494,"./华为机试/45.名字的漂亮度.js":494,"./华为机试/46.截取字符串":495,"./华为机试/46.截取字符串.js":495,"./华为机试/48.从单向链表中删除指定值的节点":496,"./华为机试/48.从单向链表中删除指定值的节点.js":496,"./华为机试/5.进制转换":497,"./华为机试/5.进制转换.js":497,"./华为机试/51.输出单向链表中倒数第k个结点":498,"./华为机试/51.输出单向链表中倒数第k个结点.js":498,"./华为机试/53.杨辉三角的变形":499,"./华为机试/53.杨辉三角的变形.js":499,"./华为机试/54.表达式求值":500,"./华为机试/54.表达式求值.js":500,"./华为机试/55.挑7":501,"./华为机试/55.挑7.js":501,"./华为机试/56.完全数计算":502,"./华为机试/56.完全数计算.js":502,"./华为机试/57.高精度整数加法":503,"./华为机试/57.高精度整数加法.js":503,"./华为机试/58.输入n个整数，输出其中最小的k个":504,"./华为机试/58.输入n个整数，输出其中最小的k个.js":504,"./华为机试/59.找出字符串中第一个只出现一次的字符":505,"./华为机试/59.找出字符串中第一个只出现一次的字符.js":505,"./华为机试/6.质数因子":506,"./华为机试/6.质数因子.js":506,"./华为机试/60.查找组成一个偶数最接近的两个素数":507,"./华为机试/60.查找组成一个偶数最接近的两个素数.js":507,"./华为机试/62.查找输入整数二进制中1的个数":508,"./华为机试/62.查找输入整数二进制中1的个数.js":508,"./华为机试/63.DNA序列":509,"./华为机试/63.DNA序列.js":509,"./华为机试/66.配置文件恢复":510,"./华为机试/66.配置文件恢复.js":510,"./华为机试/68.成绩排序":511,"./华为机试/68.成绩排序.js":511,"./华为机试/69.矩阵乘法":512,"./华为机试/69.矩阵乘法.js":512,"./华为机试/7.取近似值":513,"./华为机试/7.取近似值.js":513,"./华为机试/70.矩阵乘法计算量估算":514,"./华为机试/70.矩阵乘法计算量估算.js":514,"./华为机试/71.字符串通配符":515,"./华为机试/71.字符串通配符.js":515,"./华为机试/72.百钱买百鸡问题":516,"./华为机试/72.百钱买百鸡问题.js":516,"./华为机试/73.计算日期到天数转换":517,"./华为机试/73.计算日期到天数转换.js":517,"./华为机试/74.参数解析":518,"./华为机试/74.参数解析.js":518,"./华为机试/75.公共子串计算":519,"./华为机试/75.公共子串计算.js":519,"./华为机试/76.尼科彻斯定理":520,"./华为机试/76.尼科彻斯定理.js":520,"./华为机试/77.火车进站":521,"./华为机试/77.火车进站.js":521,"./华为机试/8.合并表记录":522,"./华为机试/8.合并表记录.js":522,"./华为机试/80.整型数组合并":523,"./华为机试/80.整型数组合并.js":523,"./华为机试/81.字符串字符匹配":524,"./华为机试/81.字符串字符匹配.js":524,"./华为机试/84.统计大写字母个数":525,"./华为机试/84.统计大写字母个数.js":525,"./华为机试/85.最长回文子串":526,"./华为机试/85.最长回文子串.js":526,"./华为机试/86.求最大连续bit数":527,"./华为机试/86.求最大连续bit数.js":527,"./华为机试/87.密码强度等级":528,"./华为机试/87.密码强度等级.js":528,"./华为机试/9.提取不重复的整数":529,"./华为机试/9.提取不重复的整数.js":529,"./华为机试/90.合法IP":530,"./华为机试/90.合法IP.js":530,"./华为机试/91.走方格的方案数":531,"./华为机试/91.走方格的方案数.js":531,"./华为机试/92.在字符串中找出连续最长的数字串":532,"./华为机试/92.在字符串中找出连续最长的数字串.js":532,"./华为机试/94.记票统计":533,"./华为机试/94.记票统计.js":533,"./华为机试/96.表示数字":534,"./华为机试/96.表示数字.js":534,"./华为机试/97.记负均正":535,"./华为机试/97.记负均正.js":535,"./华为机试/99.自守数":536,"./华为机试/99.自守数.js":536,"./面试练习/1019. 链表中的下一个更大节点":537,"./面试练习/1019. 链表中的下一个更大节点.js":537,"./面试练习/1207. 独一无二的出现次数":538,"./面试练习/1207. 独一无二的出现次数.js":538,"./面试练习/1657. 确定两个字符串是否接近":539,"./面试练习/1657. 确定两个字符串是否接近.js":539,"./面试练习/1663. 具有给定数值的最小字符串":540,"./面试练习/1663. 具有给定数值的最小字符串.js":540,"./面试练习/1664. 生成平衡数组的方案数":541,"./面试练习/1664. 生成平衡数组的方案数.js":541,"./面试练习/1669. 合并两个链表":542,"./面试练习/1669. 合并两个链表.js":542,"./面试练习/1802. 有界数组中指定下标处的最大值":543,"./面试练习/1802. 有界数组中指定下标处的最大值.js":543,"./面试练习/1807.替换字符串中的括号内容":544,"./面试练习/1807.替换字符串中的括号内容.js":544,"./面试练习/1813.句子相似性 III":545,"./面试练习/1813.句子相似性 III.js":545,"./面试练习/1814.统计一个数组中好对子的数目":546,"./面试练习/1814.统计一个数组中好对子的数目.js":546,"./面试练习/1817. 查找用户活跃分钟数":547,"./面试练习/1817. 查找用户活跃分钟数.js":547,"./面试练习/1828. 统计一个圆中点的数目":548,"./面试练习/1828. 统计一个圆中点的数目.js":548,"./面试练习/209.长度最小的子数组":549,"./面试练习/209.长度最小的子数组.js":549,"./面试练习/2149. 按符号重排数组":550,"./面试练习/2149. 按符号重排数组.js":550,"./面试练习/2180. 统计各位数字之和为偶数的整数个数":551,"./面试练习/2180. 统计各位数字之和为偶数的整数个数.js":551,"./面试练习/228. 汇总区间":552,"./面试练习/228. 汇总区间.js":552,"./面试练习/2287.重排字符形成目标字符串":553,"./面试练习/2287.重排字符形成目标字符串.js":553,"./面试练习/2293.极大极小游戏":554,"./面试练习/2293.极大极小游戏.js":554,"./面试练习/2299. 强密码检验器 II":555,"./面试练习/2299. 强密码检验器 II.js":555,"./面试练习/2303. 计算应缴税款总额":556,"./面试练习/2303. 计算应缴税款总额.js":556,"./面试练习/2309. 兼具大小写的最好英文字母":557,"./面试练习/2309. 兼具大小写的最好英文字母.js":557,"./面试练习/2315. 统计星号":558,"./面试练习/2315. 统计星号.js":558,"./面试练习/2319. 判断矩阵是否是一个 X 矩阵":559,"./面试练习/2319. 判断矩阵是否是一个 X 矩阵.js":559,"./面试练习/2325. 解密消息":560,"./面试练习/2325. 解密消息.js":560,"./面试练习/326. 3 的幂":561,"./面试练习/326. 3 的幂.js":561,"./面试练习/42.接雨水":562,"./面试练习/42.接雨水.js":562,"./面试练习/705. 设计哈希集合":563,"./面试练习/705. 设计哈希集合.js":563,"./面试练习/747. 至少是其他数字两倍的最大数":564,"./面试练习/747. 至少是其他数字两倍的最大数.js":564,"./面试练习/860. 柠檬水找零":565,"./面试练习/860. 柠檬水找零.js":565,"./面试练习/866. 回文素数":566,"./面试练习/866. 回文素数.js":566};function s(n){var e=o(n);return t(e)}function o(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}s.keys=function(){return Object.keys(r)},s.resolve=o,n.exports=s,s.id=612},function(n,e,t){"use strict";t(583)},,,,,,,,,function(n,e,t){"use strict";t.r(e);var r=t(609),s=t.n(r),o=(t(608),t(610)),i=t.n(o);s.a.registerLanguage("javascript",i.a);var l={name:"leetcode",props:{},data:()=>({filename:["Hot100","else","剑指Offer","面试练习","华为机试"],code:[],codeNum:[],rowNum:3,maxRow:15,showTable:!0,codeStr:"",codeTitle:"",originCodeStr:""}),created(){},mounted(){const{codeList:n,filenameList:e}=this.init();t(611).keys().forEach(t=>{const[,r,s]=t.split("/");n[e.indexOf(r)].value.push(s)}),this.reshape(n),this.code=n,this.createValine()},updated(){},filters:{formatStr(n){const e=n.slice(0,-3);return e.length>=18?e.slice(0,16)+"...":e}},methods:{os(){let n=navigator.userAgent,e=/(?:Windows Phone)/.test(n),t=/(?:SymbianOS)/.test(n)||e,r=/(?:Android)/.test(n),s=/(?:Firefox)/.test(n),o=(/(?:Chrome|CriOS)/.test(n),/(?:iPad|PlayBook)/.test(n)||r&&!/(?:Mobile)/.test(n)||s&&/(?:Tablet)/.test(n)),i=/(?:iPhone)/.test(n)&&!o;return{isTablet:o,isPhone:i,isAndroid:r,isPc:!i&&!r&&!t}},init(){const{isPhone:n,isAndroid:e}=this.os(),t=[],r=this.filename;return(e||n)&&(this.rowNum=1,this.maxRow=10),r.forEach((n,e)=>t.push({id:e,name:n,value:[]})),this.codeNum=new Array(r.length).fill(this.maxRow),{codeList:t,filenameList:r}},reshape(n){n.forEach(n=>{n.value.sort((n,e)=>n.split(".")[0]-e.split(".")[0]);const e=[],t=this.rowNum;for(let r=0,s=Math.ceil(n.value.length/t);r<s;r++)e.push([]);n.value.forEach((n,r)=>e[Math.floor(r/t)].push(n)),n.value=e})},showMore(n){const e=n.target.dataset.idx;this.codeNum.splice(e,1,this.codeNum[e]+this.maxRow)},showCode(n){const{dirname:e,filename:r}=n.target.dataset;window.scrollTo(0,0),this.showTable=!1;const{["code"+r.split(".")[0]]:o}=t(612)(`./${e}/${r}`);this.originCodeStr=o;const i=s.a.highlight(o,{language:"javascript"}).value;this.codeStr=i,this.codeTitle=r.slice(0,-3)},backList(){this.showTable=!0},async copy(){await navigator.clipboard.writeText(this.originCodeStr);let n=null;this.$refs.copy.classList.add("success"),n=setInterval(()=>{this.$refs.copy.classList.remove("success"),clearTimeout(n)},1500)}}},a=(t(613),t(10)),u=Object(a.a)(l,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"leetcode"},[e("Valine",[e("div",{directives:[{name:"show",rawName:"v-show",value:n.showTable,expression:"showTable"}]},n._l(n.code,(function(t,r){return e("div",{key:t.id},[e("h3",[n._v(n._s(t.name))]),n._v(" "),e("table",[e("tbody",n._l(t.value.slice(0,n.codeNum[r]),(function(r,s){return e("tr",{key:s},n._l(r,(function(r,s){return e("td",{key:s,staticClass:"filename"},[e("a",{attrs:{"data-dirname":t.name,"data-filename":r,title:r.slice(0,-3)},on:{click:n.showCode}},[n._v("\n                      "+n._s(n._f("formatStr")(r))+"\n                    ")])])})),0)})),0)]),n._v(" "),n.codeNum[r]<t.value.length?e("div",{staticClass:"divide"},[e("span"),n._v(" "),e("span",{staticClass:"txt",attrs:{"data-idx":r},on:{click:n.showMore}},[n._v("展开更多")]),n._v(" "),e("span")]):n._e()])})),0),n._v(" "),e("div",{directives:[{name:"show",rawName:"v-show",value:!n.showTable,expression:"!showTable"}]},[e("nav",[e("h3",[n._v(n._s(n.codeTitle))]),n._v(" "),e("img",{attrs:{title:"返回列表",src:n.$withBase("/images/private/back.svg"),alt:"返回列表"},on:{click:n.backList}})]),n._v(" "),e("pre",[n._v("          "),e("code",{domProps:{innerHTML:n._s(n.codeStr)}}),n._v("\n          "),n._v("\n          "),e("svg",{staticClass:"copy",attrs:{width:"24",height:"24",viewBox:"0 0 48 48",fill:"none",xmlns:"http://www.w3.org/2000/svg"},on:{click:n.copy}},[e("path",{attrs:{d:"M13 12.4316V7.8125C13 6.2592 14.2592 5 15.8125 5H40.1875C41.7408 5 43 6.2592 43 7.8125V32.1875C43 33.7408 41.7408 35 40.1875 35H35.5163",stroke:"#9b9b9b","stroke-width":"4","stroke-linecap":"round","stroke-linejoin":"round"}}),e("path",{attrs:{d:"M32.1875 13H7.8125C6.2592 13 5 14.2592 5 15.8125V40.1875C5 41.7408 6.2592 43 7.8125 43H32.1875C33.7408 43 35 41.7408 35 40.1875V15.8125C35 14.2592 33.7408 13 32.1875 13Z",fill:"none",stroke:"#9b9b9b","stroke-width":"4","stroke-linejoin":"round"}})]),n._v("\n          "),e("span",{ref:"copy",staticClass:"tip"},[n._v("Copied")]),n._v("\n          "),e("div",{staticClass:"btn"},[n._v("\n            "),e("span"),n._v("\n            "),e("span"),n._v("\n            "),e("span"),n._v("\n          ")]),n._v("\n        ")])])])],1)}),[],!1,null,"0c570c5a",null);e.default=u.exports}])]);